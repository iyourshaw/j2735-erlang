%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in ITIS.

-module('ITIS').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("ITIS.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'ITIS'},
            {options,[{i,"./ebin"},uper,jer,verbose,{i,"./asn"},{outdir,"./ebin"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_GenericLocations/1,
enc_IncidentResponseEquipment/1,
enc_ITIStext/1,
enc_ResponderGroupAffected/1,
enc_VehicleGroupAffected/1,
enc_ITIScodesAndText/1,
enc_ITIScodes/1
]).

-export([
dec_GenericLocations/1,
dec_IncidentResponseEquipment/1,
dec_ITIStext/1,
dec_ResponderGroupAffected/1,
dec_VehicleGroupAffected/1,
dec_ITIScodesAndText/1,
dec_ITIScodes/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('ITIS', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('ITIS', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('GenericLocations', Data) -> enc_GenericLocations(Data);
encode_disp('IncidentResponseEquipment', Data) -> enc_IncidentResponseEquipment(Data);
encode_disp('ITIStext', Data) -> enc_ITIStext(Data);
encode_disp('ResponderGroupAffected', Data) -> enc_ResponderGroupAffected(Data);
encode_disp('VehicleGroupAffected', Data) -> enc_VehicleGroupAffected(Data);
encode_disp('ITIScodesAndText', Data) -> enc_ITIScodesAndText(Data);
encode_disp('ITIScodes', Data) -> enc_ITIScodes(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('GenericLocations', Data) -> dec_GenericLocations(Data);
decode_disp('IncidentResponseEquipment', Data) -> dec_IncidentResponseEquipment(Data);
decode_disp('ITIStext', Data) -> dec_ITIStext(Data);
decode_disp('ResponderGroupAffected', Data) -> dec_ResponderGroupAffected(Data);
decode_disp('VehicleGroupAffected', Data) -> dec_VehicleGroupAffected(Data);
decode_disp('ITIScodesAndText', Data) -> dec_ITIScodesAndText(Data);
decode_disp('ITIScodes', Data) -> dec_ITIScodes(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_GenericLocations(Val) ->
if Val =:= 'on-bridges' ->
<<0:1,0:7>>;
Val =:= 'in-tunnels' ->
<<0:1,1:7>>;
Val =:= 'entering-or-leaving-tunnels' ->
<<0:1,2:7>>;
Val =:= 'on-ramps' ->
<<0:1,3:7>>;
Val =:= 'in-road-construction-area' ->
<<0:1,4:7>>;
Val =:= 'around-a-curve' ->
<<0:1,5:7>>;
Val =:= 'on-minor-roads' ->
<<0:1,6:7>>;
Val =:= 'in-the-opposing-lanes' ->
<<0:1,7:7>>;
Val =:= 'adjacent-to-roadway' ->
<<0:1,8:7>>;
Val =:= 'on-bend' ->
<<0:1,9:7>>;
Val =:= 'entire-intersection' ->
<<0:1,10:7>>;
Val =:= 'in-the-median' ->
<<0:1,11:7>>;
Val =:= 'moved-to-side-of-road' ->
<<0:1,12:7>>;
Val =:= 'moved-to-shoulder' ->
<<0:1,13:7>>;
Val =:= 'on-the-roadway' ->
<<0:1,14:7>>;
Val =:= 'in-shaded-areas' ->
<<0:1,15:7>>;
Val =:= 'in-low-lying-areas' ->
<<0:1,16:7>>;
Val =:= 'in-the-downtown-area' ->
<<0:1,17:7>>;
Val =:= 'in-the-inner-city-area' ->
<<0:1,18:7>>;
Val =:= 'in-parts' ->
<<0:1,19:7>>;
Val =:= 'in-some-places' ->
<<0:1,20:7>>;
Val =:= 'in-the-ditch' ->
<<0:1,21:7>>;
Val =:= 'in-the-valley' ->
<<0:1,22:7>>;
Val =:= 'on-hill-top' ->
<<0:1,23:7>>;
Val =:= 'near-the-foothills' ->
<<0:1,24:7>>;
Val =:= 'at-high-altitudes' ->
<<0:1,25:7>>;
Val =:= 'near-the-lake' ->
<<0:1,26:7>>;
Val =:= 'near-the-shore' ->
<<0:1,27:7>>;
Val =:= 'over-the-crest-of-a-hill' ->
<<0:1,28:7>>;
Val =:= 'other-than-on-the-roadway' ->
<<0:1,29:7>>;
Val =:= 'near-the-beach' ->
<<0:1,30:7>>;
Val =:= 'near-beach-access-point' ->
<<0:1,31:7>>;
Val =:= 'lower-level' ->
<<0:1,32:7>>;
Val =:= 'upper-level' ->
<<0:1,33:7>>;
Val =:= airport ->
<<0:1,34:7>>;
Val =:= concourse ->
<<0:1,35:7>>;
Val =:= gate ->
<<0:1,36:7>>;
Val =:= 'baggage-claim' ->
<<0:1,37:7>>;
Val =:= 'customs-point' ->
<<0:1,38:7>>;
Val =:= station ->
<<0:1,39:7>>;
Val =:= platform ->
<<0:1,40:7>>;
Val =:= dock ->
<<0:1,41:7>>;
Val =:= depot ->
<<0:1,42:7>>;
Val =:= 'ev-charging-point' ->
<<0:1,43:7>>;
Val =:= 'information-welcome-point' ->
<<0:1,44:7>>;
Val =:= 'at-rest-area' ->
<<0:1,45:7>>;
Val =:= 'at-service-area' ->
<<0:1,46:7>>;
Val =:= 'at-weigh-station' ->
<<0:1,47:7>>;
Val =:= 'picnic-areas' ->
<<0:1,48:7>>;
Val =:= 'rest-area' ->
<<0:1,49:7>>;
Val =:= 'service-stations' ->
<<0:1,50:7>>;
Val =:= toilets ->
<<0:1,51:7>>;
Val =:= 'on-the-right' ->
<<0:1,52:7>>;
Val =:= 'on-the-left' ->
<<0:1,53:7>>;
Val =:= 'in-the-center' ->
<<0:1,54:7>>;
Val =:= 'in-the-opposite-direction' ->
<<0:1,55:7>>;
Val =:= 'cross-traffic' ->
<<0:1,56:7>>;
Val =:= 'northbound-traffic' ->
<<0:1,57:7>>;
Val =:= 'eastbound-traffic' ->
<<0:1,58:7>>;
Val =:= 'southbound-traffic' ->
<<0:1,59:7>>;
Val =:= 'westbound-traffic' ->
<<0:1,60:7>>;
Val =:= north ->
<<0:1,61:7>>;
Val =:= south ->
<<0:1,62:7>>;
Val =:= east ->
<<0:1,63:7>>;
Val =:= west ->
<<0:1,64:7>>;
Val =:= northeast ->
<<0:1,65:7>>;
Val =:= northwest ->
<<0:1,66:7>>;
Val =:= southeast ->
<<0:1,67:7>>;
Val =:= southwest ->
<<0:1,68:7>>;
Val =:= 'mountain-pass' ->
<<0:1,69:7>>;
Val =:= 'reservation-center' ->
<<0:1,70:7>>;
Val =:= 'nearby-basin' ->
<<0:1,71:7>>;
Val =:= 'on-tracks' ->
<<0:1,72:7>>;
Val =:= dip ->
<<0:1,73:7>>;
Val =:= 'traffic-circle' ->
<<0:1,74:7>>;
Val =:= 'park-and-ride-lot' ->
<<0:1,75:7>>;
Val =:= to ->
<<0:1,76:7>>;
Val =:= by ->
<<0:1,77:7>>;
Val =:= through ->
<<0:1,78:7>>;
Val =:= 'area-of' ->
<<0:1,79:7>>;
Val =:= under ->
<<0:1,80:7>>;
Val =:= over ->
<<0:1,81:7>>;
Val =:= from ->
<<0:1,82:7>>;
Val =:= approaching ->
<<0:1,83:7>>;
Val =:= 'entering-at' ->
<<0:1,84:7>>;
Val =:= 'exiting-at' ->
<<0:1,85:7>>;
Val =:= 'across-tracks' ->
<<0:1,86:7>>;
Val =:= 'in-street' ->
<<0:1,87:7>>;
Val =:= 'on-curve' ->
<<0:1,88:7>>;
Val =:= shoulder ->
<<0:1,89:7>>;
Val =:= crossover ->
<<0:1,90:7>>;
Val =:= 'cross-road' ->
<<0:1,91:7>>;
Val =:= 'side-road' ->
<<0:1,92:7>>;
Val =:= 'bus-stop' ->
<<0:1,93:7>>;
Val =:= intersection ->
<<0:1,94:7>>;
Val =:= 'roadside-park' ->
<<0:1,95:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_GenericLocations(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> 'on-bridges';
1 -> 'in-tunnels';
2 -> 'entering-or-leaving-tunnels';
3 -> 'on-ramps';
4 -> 'in-road-construction-area';
5 -> 'around-a-curve';
6 -> 'on-minor-roads';
7 -> 'in-the-opposing-lanes';
8 -> 'adjacent-to-roadway';
9 -> 'on-bend';
10 -> 'entire-intersection';
11 -> 'in-the-median';
12 -> 'moved-to-side-of-road';
13 -> 'moved-to-shoulder';
14 -> 'on-the-roadway';
15 -> 'in-shaded-areas';
16 -> 'in-low-lying-areas';
17 -> 'in-the-downtown-area';
18 -> 'in-the-inner-city-area';
19 -> 'in-parts';
20 -> 'in-some-places';
21 -> 'in-the-ditch';
22 -> 'in-the-valley';
23 -> 'on-hill-top';
24 -> 'near-the-foothills';
25 -> 'at-high-altitudes';
26 -> 'near-the-lake';
27 -> 'near-the-shore';
28 -> 'over-the-crest-of-a-hill';
29 -> 'other-than-on-the-roadway';
30 -> 'near-the-beach';
31 -> 'near-beach-access-point';
32 -> 'lower-level';
33 -> 'upper-level';
34 -> airport;
35 -> concourse;
36 -> gate;
37 -> 'baggage-claim';
38 -> 'customs-point';
39 -> station;
40 -> platform;
41 -> dock;
42 -> depot;
43 -> 'ev-charging-point';
44 -> 'information-welcome-point';
45 -> 'at-rest-area';
46 -> 'at-service-area';
47 -> 'at-weigh-station';
48 -> 'picnic-areas';
49 -> 'rest-area';
50 -> 'service-stations';
51 -> toilets;
52 -> 'on-the-right';
53 -> 'on-the-left';
54 -> 'in-the-center';
55 -> 'in-the-opposite-direction';
56 -> 'cross-traffic';
57 -> 'northbound-traffic';
58 -> 'eastbound-traffic';
59 -> 'southbound-traffic';
60 -> 'westbound-traffic';
61 -> north;
62 -> south;
63 -> east;
64 -> west;
65 -> northeast;
66 -> northwest;
67 -> southeast;
68 -> southwest;
69 -> 'mountain-pass';
70 -> 'reservation-center';
71 -> 'nearby-basin';
72 -> 'on-tracks';
73 -> dip;
74 -> 'traffic-circle';
75 -> 'park-and-ride-lot';
76 -> to;
77 -> by;
78 -> through;
79 -> 'area-of';
80 -> under;
81 -> over;
82 -> from;
83 -> approaching;
84 -> 'entering-at';
85 -> 'exiting-at';
86 -> 'across-tracks';
87 -> 'in-street';
88 -> 'on-curve';
89 -> shoulder;
90 -> crossover;
91 -> 'cross-road';
92 -> 'side-road';
93 -> 'bus-stop';
94 -> intersection;
95 -> 'roadside-park';
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_IncidentResponseEquipment(Val) ->
if Val =:= 'ground-fire-suppression' ->
<<0:1,0:7>>;
Val =:= 'heavy-ground-equipment' ->
<<0:1,1:7>>;
Val =:= aircraft ->
<<0:1,2:7>>;
Val =:= 'marine-equipment' ->
<<0:1,3:7>>;
Val =:= 'support-equipment' ->
<<0:1,4:7>>;
Val =:= 'medical-rescue-unit' ->
<<0:1,5:7>>;
Val =:= other ->
<<0:1,6:7>>;
Val =:= 'ground-fire-suppression-other' ->
<<0:1,7:7>>;
Val =:= engine ->
<<0:1,8:7>>;
Val =:= 'truck-or-aerial' ->
<<0:1,9:7>>;
Val =:= quint ->
<<0:1,10:7>>;
Val =:= 'tanker-pumper-combination' ->
<<0:1,11:7>>;
Val =:= 'brush-truck' ->
<<0:1,12:7>>;
Val =:= 'aircraft-rescue-firefighting' ->
<<0:1,13:7>>;
Val =:= 'heavy-ground-equipment-other' ->
<<0:1,14:7>>;
Val =:= 'dozer-or-plow' ->
<<0:1,15:7>>;
Val =:= tractor ->
<<0:1,16:7>>;
Val =:= 'tanker-or-tender' ->
<<0:1,17:7>>;
Val =:= 'aircraft-other' ->
<<0:1,18:7>>;
Val =:= 'aircraft-fixed-wing-tanker' ->
<<0:1,19:7>>;
Val =:= helitanker ->
<<0:1,20:7>>;
Val =:= helicopter ->
<<0:1,21:7>>;
Val =:= 'marine-equipment-other' ->
<<0:1,22:7>>;
Val =:= 'fire-boat-with-pump' ->
<<0:1,23:7>>;
Val =:= 'boat-no-pump' ->
<<0:1,24:7>>;
Val =:= 'support-apparatus-other' ->
<<0:1,25:7>>;
Val =:= 'breathing-apparatus-support' ->
<<0:1,26:7>>;
Val =:= 'light-and-air-unit' ->
<<0:1,27:7>>;
Val =:= 'medical-rescue-unit-other' ->
<<0:1,28:7>>;
Val =:= 'rescue-unit' ->
<<0:1,29:7>>;
Val =:= 'urban-search-rescue-unit' ->
<<0:1,30:7>>;
Val =:= 'high-angle-rescue' ->
<<0:1,31:7>>;
Val =:= 'crash-fire-rescue' ->
<<0:1,32:7>>;
Val =:= 'bLS-unit' ->
<<0:1,33:7>>;
Val =:= 'aLS-unit' ->
<<0:1,34:7>>;
Val =:= 'mobile-command-post' ->
<<0:1,35:7>>;
Val =:= 'chief-officer-car' ->
<<0:1,36:7>>;
Val =:= 'hAZMAT-unit' ->
<<0:1,37:7>>;
Val =:= 'type-i-hand-crew' ->
<<0:1,38:7>>;
Val =:= 'type-ii-hand-crew' ->
<<0:1,39:7>>;
Val =:= 'privately-owned-vehicle' ->
<<0:1,40:7>>;
Val =:= 'other-apparatus-resource' ->
<<0:1,41:7>>;
Val =:= ambulance ->
<<0:1,42:7>>;
Val =:= 'bomb-squad-van' ->
<<0:1,43:7>>;
Val =:= 'combine-harvester' ->
<<0:1,44:7>>;
Val =:= 'construction-vehicle' ->
<<0:1,45:7>>;
Val =:= 'farm-tractor' ->
<<0:1,46:7>>;
Val =:= 'grass-cutting-machines' ->
<<0:1,47:7>>;
Val =:= 'hAZMAT-containment-tow' ->
<<0:1,48:7>>;
Val =:= 'heavy-tow' ->
<<0:1,49:7>>;
Val =:= 'hedge-cutting-machines' ->
<<0:1,50:7>>;
Val =:= 'light-tow' ->
<<0:1,51:7>>;
Val =:= 'mobile-crane' ->
<<0:1,52:7>>;
Val =:= 'refuse-collection-vehicle' ->
<<0:1,53:7>>;
Val =:= 'resurfacing-vehicle' ->
<<0:1,54:7>>;
Val =:= 'road-sweeper' ->
<<0:1,55:7>>;
Val =:= 'roadside-litter-collection-crews' ->
<<0:1,56:7>>;
Val =:= 'salvage-vehicle' ->
<<0:1,57:7>>;
Val =:= 'sand-truck' ->
<<0:1,58:7>>;
Val =:= snowplow ->
<<0:1,59:7>>;
Val =:= 'steam-roller' ->
<<0:1,60:7>>;
Val =:= 'swat-team-van' ->
<<0:1,61:7>>;
Val =:= 'track-laying-vehicle' ->
<<0:1,62:7>>;
Val =:= 'unknown-vehicle' ->
<<0:1,63:7>>;
Val =:= 'white-lining-vehicle' ->
<<0:1,64:7>>;
Val =:= 'dump-truck' ->
<<0:1,65:7>>;
Val =:= 'supervisor-vehicle' ->
<<0:1,66:7>>;
Val =:= 'snow-blower' ->
<<0:1,67:7>>;
Val =:= 'rotary-snow-blower' ->
<<0:1,68:7>>;
Val =:= 'road-grader' ->
<<0:1,69:7>>;
Val =:= 'steam-truck' ->
<<0:1,70:7>>;
Val =:= 'flatbed-tow' ->
<<0:1,71:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_IncidentResponseEquipment(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> 'ground-fire-suppression';
1 -> 'heavy-ground-equipment';
2 -> aircraft;
3 -> 'marine-equipment';
4 -> 'support-equipment';
5 -> 'medical-rescue-unit';
6 -> other;
7 -> 'ground-fire-suppression-other';
8 -> engine;
9 -> 'truck-or-aerial';
10 -> quint;
11 -> 'tanker-pumper-combination';
12 -> 'brush-truck';
13 -> 'aircraft-rescue-firefighting';
14 -> 'heavy-ground-equipment-other';
15 -> 'dozer-or-plow';
16 -> tractor;
17 -> 'tanker-or-tender';
18 -> 'aircraft-other';
19 -> 'aircraft-fixed-wing-tanker';
20 -> helitanker;
21 -> helicopter;
22 -> 'marine-equipment-other';
23 -> 'fire-boat-with-pump';
24 -> 'boat-no-pump';
25 -> 'support-apparatus-other';
26 -> 'breathing-apparatus-support';
27 -> 'light-and-air-unit';
28 -> 'medical-rescue-unit-other';
29 -> 'rescue-unit';
30 -> 'urban-search-rescue-unit';
31 -> 'high-angle-rescue';
32 -> 'crash-fire-rescue';
33 -> 'bLS-unit';
34 -> 'aLS-unit';
35 -> 'mobile-command-post';
36 -> 'chief-officer-car';
37 -> 'hAZMAT-unit';
38 -> 'type-i-hand-crew';
39 -> 'type-ii-hand-crew';
40 -> 'privately-owned-vehicle';
41 -> 'other-apparatus-resource';
42 -> ambulance;
43 -> 'bomb-squad-van';
44 -> 'combine-harvester';
45 -> 'construction-vehicle';
46 -> 'farm-tractor';
47 -> 'grass-cutting-machines';
48 -> 'hAZMAT-containment-tow';
49 -> 'heavy-tow';
50 -> 'hedge-cutting-machines';
51 -> 'light-tow';
52 -> 'mobile-crane';
53 -> 'refuse-collection-vehicle';
54 -> 'resurfacing-vehicle';
55 -> 'road-sweeper';
56 -> 'roadside-litter-collection-crews';
57 -> 'salvage-vehicle';
58 -> 'sand-truck';
59 -> snowplow;
60 -> 'steam-roller';
61 -> 'swat-team-van';
62 -> 'track-laying-vehicle';
63 -> 'unknown-vehicle';
64 -> 'white-lining-vehicle';
65 -> 'dump-truck';
66 -> 'supervisor-vehicle';
67 -> 'snow-blower';
68 -> 'rotary-snow-blower';
69 -> 'road-grader';
70 -> 'steam-truck';
71 -> 'flatbed-tow';
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_ITIStext(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 500 ->
[<<Enc1@len@sub:9>>|Enc1@bin]
end.


dec_ITIStext(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

enc_ResponderGroupAffected(Val) ->
if Val =:= 'emergency-vehicle-units' ->
<<0:1,0:4>>;
Val =:= 'federal-law-enforcement-units' ->
<<0:1,1:4>>;
Val =:= 'state-police-units' ->
<<0:1,2:4>>;
Val =:= 'county-police-units' ->
<<0:1,3:4>>;
Val =:= 'local-police-units' ->
<<0:1,4:4>>;
Val =:= 'ambulance-units' ->
<<0:1,5:4>>;
Val =:= 'rescue-units' ->
<<0:1,6:4>>;
Val =:= 'fire-units' ->
<<0:1,7:4>>;
Val =:= 'hAZMAT-units' ->
<<0:1,8:4>>;
Val =:= 'light-tow-unit' ->
<<0:1,9:4>>;
Val =:= 'heavy-tow-unit' ->
<<0:1,10:4>>;
Val =:= 'freeway-service-patrols' ->
<<0:1,11:4>>;
Val =:= 'transportation-response-units' ->
<<0:1,12:4>>;
Val =:= 'private-contractor-response-units' ->
<<0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_ResponderGroupAffected(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> 'emergency-vehicle-units';
1 -> 'federal-law-enforcement-units';
2 -> 'state-police-units';
3 -> 'county-police-units';
4 -> 'local-police-units';
5 -> 'ambulance-units';
6 -> 'rescue-units';
7 -> 'fire-units';
8 -> 'hAZMAT-units';
9 -> 'light-tow-unit';
10 -> 'heavy-tow-unit';
11 -> 'freeway-service-patrols';
12 -> 'transportation-response-units';
13 -> 'private-contractor-response-units';
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_VehicleGroupAffected(Val) ->
if Val =:= 'all-vehicles' ->
<<0:1,0:6>>;
Val =:= bicycles ->
<<0:1,1:6>>;
Val =:= motorcycles ->
<<0:1,2:6>>;
Val =:= cars ->
<<0:1,3:6>>;
Val =:= 'light-vehicles' ->
<<0:1,4:6>>;
Val =:= 'cars-and-light-vehicles' ->
<<0:1,5:6>>;
Val =:= 'cars-with-trailers' ->
<<0:1,6:6>>;
Val =:= 'cars-with-recreational-trailers' ->
<<0:1,7:6>>;
Val =:= 'vehicles-with-trailers' ->
<<0:1,8:6>>;
Val =:= 'heavy-vehicles' ->
<<0:1,9:6>>;
Val =:= trucks ->
<<0:1,10:6>>;
Val =:= buses ->
<<0:1,11:6>>;
Val =:= 'articulated-buses' ->
<<0:1,12:6>>;
Val =:= 'school-buses' ->
<<0:1,13:6>>;
Val =:= 'vehicles-with-semi-trailers' ->
<<0:1,14:6>>;
Val =:= 'vehicles-with-double-trailers' ->
<<0:1,15:6>>;
Val =:= 'high-profile-vehicles' ->
<<0:1,16:6>>;
Val =:= 'wide-vehicles' ->
<<0:1,17:6>>;
Val =:= 'long-vehicles' ->
<<0:1,18:6>>;
Val =:= 'hazardous-loads' ->
<<0:1,19:6>>;
Val =:= 'exceptional-loads' ->
<<0:1,20:6>>;
Val =:= 'abnormal-loads' ->
<<0:1,21:6>>;
Val =:= convoys ->
<<0:1,22:6>>;
Val =:= 'maintenance-vehicles' ->
<<0:1,23:6>>;
Val =:= 'delivery-vehicles' ->
<<0:1,24:6>>;
Val =:= 'vehicles-with-even-numbered-license-plates' ->
<<0:1,25:6>>;
Val =:= 'vehicles-with-odd-numbered-license-plates' ->
<<0:1,26:6>>;
Val =:= 'vehicles-with-parking-permits' ->
<<0:1,27:6>>;
Val =:= 'vehicles-with-catalytic-converters' ->
<<0:1,28:6>>;
Val =:= 'vehicles-without-catalytic-converters' ->
<<0:1,29:6>>;
Val =:= 'gas-powered-vehicles' ->
<<0:1,30:6>>;
Val =:= 'diesel-powered-vehicles' ->
<<0:1,31:6>>;
Val =:= 'lPG-vehicles' ->
<<0:1,32:6>>;
Val =:= 'military-convoys' ->
<<0:1,33:6>>;
Val =:= 'military-vehicles' ->
<<0:1,34:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_VehicleGroupAffected(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> 'all-vehicles';
1 -> bicycles;
2 -> motorcycles;
3 -> cars;
4 -> 'light-vehicles';
5 -> 'cars-and-light-vehicles';
6 -> 'cars-with-trailers';
7 -> 'cars-with-recreational-trailers';
8 -> 'vehicles-with-trailers';
9 -> 'heavy-vehicles';
10 -> trucks;
11 -> buses;
12 -> 'articulated-buses';
13 -> 'school-buses';
14 -> 'vehicles-with-semi-trailers';
15 -> 'vehicles-with-double-trailers';
16 -> 'high-profile-vehicles';
17 -> 'wide-vehicles';
18 -> 'long-vehicles';
19 -> 'hazardous-loads';
20 -> 'exceptional-loads';
21 -> 'abnormal-loads';
22 -> convoys;
23 -> 'maintenance-vehicles';
24 -> 'delivery-vehicles';
25 -> 'vehicles-with-even-numbered-license-plates';
26 -> 'vehicles-with-odd-numbered-license-plates';
27 -> 'vehicles-with-parking-permits';
28 -> 'vehicles-with-catalytic-converters';
29 -> 'vehicles-without-catalytic-converters';
30 -> 'gas-powered-vehicles';
31 -> 'diesel-powered-vehicles';
32 -> 'lPG-vehicles';
33 -> 'military-convoys';
34 -> 'military-vehicles';
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_ITIScodesAndText(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 100 ->
[<<Enc1@len@sub:7>>|[enc_ITIScodesAndText_SEQOF(Comp) || Comp <- Val]]
end.

enc_ITIScodesAndText_SEQOF(Val) ->
%% attribute item(1) with type CHOICE
Enc1@element = element(2, Val),
enc_ITIScodesAndText_SEQOF_item(Enc1@element).
enc_ITIScodesAndText_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if 0 =< Enc4@len@sub, Enc4@len@sub < 500 ->
[<<1:1,Enc4@len@sub:9>>|Enc4@bin]
end
end
end.


dec_ITIScodesAndText(Bytes) ->
%% Length with constraint {1,100}
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components1(V1@Add2, V1@Buf1, []).


dec_ITIScodesAndText_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_ITIScodesAndText_SEQOF_item(Bytes),
Res1 = {'ITIScodesAndText_SEQOF',Term1},
{Res1,Bytes1}.


dec_ITIScodesAndText_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:9,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
enc_ITIScodes(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ITIScodes(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

typeinfo('GenericLocations') ->
  {'ENUMERATED_EXT',#{'in-the-ditch' => 7958,'baggage-claim' => 7974,'in-the-opposite-direction' => 7992,'on-hill-top' => 7960,'on-the-right' => 7989,'near-the-shore' => 7964,'in-road-construction-area' => 7941,'southbound-traffic' => 7996,'ev-charging-point' => 7980,west => 8001,northeast => 8002,'rest-area' => 7986,'entering-or-leaving-tunnels' => 7939,dip => 8010,'on-minor-roads' => 7943,northwest => 8003,'cross-road' => 8029,to => 8014,'bus-stop' => 8031,from => 8020,toilets => 7988,'on-tracks' => 8009,'at-service-area' => 7983,'in-the-opposing-lanes' => 7944,'near-the-beach' => 7967,'on-the-roadway' => 7951,depot => 7979,'exiting-at' => 8023,shoulder => 8027,gate => 7973,'eastbound-traffic' => 7995,'in-shaded-areas' => 7952,'information-welcome-point' => 7981,'other-than-on-the-roadway' => 7966,'customs-point' => 7975,crossover => 8028,south => 7999,east => 8000,'picnic-areas' => 7985,'in-the-downtown-area' => 7954,airport => 7971,'in-the-center' => 7991,'park-and-ride-lot' => 8012,'entire-intersection' => 7947,by => 8015,'northbound-traffic' => 7994,'roadside-park' => 8033,'service-stations' => 7987,'near-the-foothills' => 7961,'on-curve' => 8026,'at-rest-area' => 7982,southwest => 8005,'adjacent-to-roadway' => 7945,concourse => 7972,'upper-level' => 7970,'cross-traffic' => 7993,'over-the-crest-of-a-hill' => 7965,southeast => 8004,'near-the-lake' => 7963,'entering-at' => 8022,'in-parts' => 7956,station => 7976,approaching => 8021,'in-the-inner-city-area' => 7955,'moved-to-side-of-road' => 7949,north => 7998,dock => 7978,'reservation-center' => 8007,'lower-level' => 7969,platform => 7977,'in-tunnels' => 7938,'in-low-lying-areas' => 7953,through => 8016,'on-ramps' => 7940,'moved-to-shoulder' => 7950,'on-the-left' => 7990,under => 8018,'in-the-valley' => 7959,'nearby-basin' => 8008,'side-road' => 8030,'at-high-altitudes' => 7962,'near-beach-access-point' => 7968,'across-tracks' => 8024,'in-some-places' => 7957,'in-street' => 8025,'westbound-traffic' => 7997,'at-weigh-station' => 7984,'on-bridges' => 7937,'area-of' => 8017,'traffic-circle' => 8011,'on-bend' => 7946,over => 8019,intersection => 8032,'in-the-median' => 7948,'around-a-curve' => 7942,'mountain-pass' => 8006}};
typeinfo('IncidentResponseEquipment') ->
  {'ENUMERATED_EXT',#{snowplow => 10102,'swat-team-van' => 10104,'urban-search-rescue-unit' => 10056,helitanker => 10026,'rescue-unit' => 10055,'tanker-pumper-combination' => 9998,'marine-equipment-other' => 10034,'farm-tractor' => 10089,'marine-equipment' => 9989,'heavy-tow' => 10092,'aLS-unit' => 10060,'unknown-vehicle' => 10106,'boat-no-pump' => 10036,'breathing-apparatus-support' => 10045,'construction-vehicle' => 10088,'refuse-collection-vehicle' => 10096,'rotary-snow-blower' => 10111,'chief-officer-car' => 10076,'bomb-squad-van' => 10086,'resurfacing-vehicle' => 10097,'crash-fire-rescue' => 10058,'high-angle-rescue' => 10057,'combine-harvester' => 10087,engine => 9995,'roadside-litter-collection-crews' => 10099,'aircraft-fixed-wing-tanker' => 10025,'supervisor-vehicle' => 10109,'type-ii-hand-crew' => 10079,aircraft => 9988,quint => 9997,'tanker-or-tender' => 10008,'hAZMAT-unit' => 10077,'hedge-cutting-machines' => 10093,'bLS-unit' => 10059,'road-grader' => 10112,'dump-truck' => 10108,'privately-owned-vehicle' => 10083,helicopter => 10027,'heavy-ground-equipment' => 9986,'aircraft-other' => 10024,'heavy-ground-equipment-other' => 10004,'steam-truck' => 10113,'mobile-crane' => 10095,other => 9993,'truck-or-aerial' => 9996,'support-equipment' => 9990,'brush-truck' => 10000,'steam-roller' => 10103,'medical-rescue-unit-other' => 10054,'salvage-vehicle' => 10100,'type-i-hand-crew' => 10078,'grass-cutting-machines' => 10090,'medical-rescue-unit' => 9991,'light-and-air-unit' => 10046,'hAZMAT-containment-tow' => 10091,'light-tow' => 10094,'other-apparatus-resource' => 10084,'snow-blower' => 10110,'dozer-or-plow' => 10005,'sand-truck' => 10101,'ground-fire-suppression' => 9985,'mobile-command-post' => 10075,ambulance => 10085,'road-sweeper' => 10098,'track-laying-vehicle' => 10105,tractor => 10006,'flatbed-tow' => 10114,'fire-boat-with-pump' => 10035,'aircraft-rescue-firefighting' => 10001,'support-apparatus-other' => 10044,'ground-fire-suppression-other' => 9994,'white-lining-vehicle' => 10107}};
typeinfo('ITIStext') ->
  string;
typeinfo('ResponderGroupAffected') ->
  {'ENUMERATED_EXT',#{'emergency-vehicle-units' => 9729,'federal-law-enforcement-units' => 9730,'state-police-units' => 9731,'county-police-units' => 9732,'local-police-units' => 9733,'ambulance-units' => 9734,'rescue-units' => 9735,'fire-units' => 9736,'hAZMAT-units' => 9737,'light-tow-unit' => 9738,'heavy-tow-unit' => 9739,'freeway-service-patrols' => 9740,'transportation-response-units' => 9741,'private-contractor-response-units' => 9742}};
typeinfo('VehicleGroupAffected') ->
  {'ENUMERATED_EXT',#{'diesel-powered-vehicles' => 9248,'maintenance-vehicles' => 9240,'heavy-vehicles' => 9226,'cars-with-recreational-trailers' => 9224,'lPG-vehicles' => 9249,'all-vehicles' => 9217,'articulated-buses' => 9229,'vehicles-with-trailers' => 9225,'cars-with-trailers' => 9223,'long-vehicles' => 9235,'vehicles-with-parking-permits' => 9244,'light-vehicles' => 9221,convoys => 9239,'vehicles-with-semi-trailers' => 9231,'delivery-vehicles' => 9241,motorcycles => 9219,'hazardous-loads' => 9236,'vehicles-with-odd-numbered-license-plates' => 9243,'military-vehicles' => 9251,bicycles => 9218,'gas-powered-vehicles' => 9247,'high-profile-vehicles' => 9233,trucks => 9227,cars => 9220,'military-convoys' => 9250,'cars-and-light-vehicles' => 9222,'exceptional-loads' => 9237,'abnormal-loads' => 9238,'vehicles-with-catalytic-converters' => 9245,'school-buses' => 9230,'wide-vehicles' => 9234,'vehicles-without-catalytic-converters' => 9246,'vehicles-with-double-trailers' => 9232,buses => 9228,'vehicles-with-even-numbered-license-plates' => 9242}};
typeinfo('ITIScodesAndText') ->
  {sof,{sequence,'ITIScodesAndText_SEQOF',1,[{<<105,116,101,109>>,{choice,#{<<105,116,105,115>> => {'INTEGER',{0,65535}},<<116,101,120,116>> => string}},mandatory}]}};
typeinfo('ITIScodes') ->
  {'INTEGER',{0,65535}};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

dec_components1(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components1(Num, Bytes, Acc) ->
{Term,Remain} = dec_ITIScodesAndText_SEQOF(Bytes),
dec_components1(Num-1, Remain, [Term|Acc]).

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_chars(Val, N) ->
    [ 
     C ||
         <<C:N>> <= Val
    ].

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

encode_chars(Val, NumBits) ->
    << 
      <<C:NumBits>> ||
          C <- Val
    >>.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).
