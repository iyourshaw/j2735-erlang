%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in TravelerInformation.

-module('TravelerInformation').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("TravelerInformation.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'TravelerInformation'},
            {options,[{i,"./ebin"},uper,jer,verbose,{i,"./asn"},{outdir,"./ebin"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_TravelerInformation/1,
enc_Circle/1,
enc_GeographicalPath/1,
enc_GeometricProjection/1,
enc_ExitService/1,
enc_GenericSignage/1,
enc_SpeedLimit/1,
enc_WorkZone/1,
'enc_Node-LL-24B'/1,
'enc_Node-LL-28B'/1,
'enc_Node-LL-32B'/1,
'enc_Node-LL-36B'/1,
'enc_Node-LL-44B'/1,
'enc_Node-LL-48B'/1,
enc_NodeAttributeLLList/1,
enc_NodeAttributeSetLL/1,
enc_NodeListLL/1,
enc_NodeLL/1,
enc_NodeOffsetPointLL/1,
enc_NodeSetLL/1,
enc_OffsetSystem/1,
enc_RegionList/1,
enc_RegionOffsets/1,
enc_RegionPointSet/1,
enc_RoadSignID/1,
enc_SegmentAttributeLLList/1,
enc_ShapePointSet/1,
enc_TravelerDataFrameList/1,
enc_TravelerDataFrame/1,
enc_TravelerDataFrameNewPartIIIContent/1,
enc_ValidRegion/1,
enc_DirectionOfUse/1,
enc_DistanceUnits/1,
enc_ITIStextPhrase/1,
enc_MinutesDuration/1,
enc_MsgCRC/1,
enc_MUTCDCode/1,
enc_NodeAttributeLL/1,
'enc_OffsetLL-B12'/1,
'enc_OffsetLL-B14'/1,
'enc_OffsetLL-B16'/1,
'enc_OffsetLL-B22'/1,
'enc_OffsetLL-B24'/1,
'enc_Radius-B12'/1,
enc_SegmentAttributeLL/1,
enc_SignPriority/1,
enc_TravelerInfoType/1,
enc_UniqueMSGID/1,
'enc_URL-Base'/1,
'enc_URL-Short'/1,
enc_Zoom/1
]).

-export([
dec_TravelerInformation/1,
dec_Circle/1,
dec_GeographicalPath/1,
dec_GeometricProjection/1,
dec_ExitService/1,
dec_GenericSignage/1,
dec_SpeedLimit/1,
dec_WorkZone/1,
'dec_Node-LL-24B'/1,
'dec_Node-LL-28B'/1,
'dec_Node-LL-32B'/1,
'dec_Node-LL-36B'/1,
'dec_Node-LL-44B'/1,
'dec_Node-LL-48B'/1,
dec_NodeAttributeLLList/1,
dec_NodeAttributeSetLL/1,
dec_NodeListLL/1,
dec_NodeLL/1,
dec_NodeOffsetPointLL/1,
dec_NodeSetLL/1,
dec_OffsetSystem/1,
dec_RegionList/1,
dec_RegionOffsets/1,
dec_RegionPointSet/1,
dec_RoadSignID/1,
dec_SegmentAttributeLLList/1,
dec_ShapePointSet/1,
dec_TravelerDataFrameList/1,
dec_TravelerDataFrame/1,
dec_TravelerDataFrameNewPartIIIContent/1,
dec_ValidRegion/1,
dec_DirectionOfUse/1,
dec_DistanceUnits/1,
dec_ITIStextPhrase/1,
dec_MinutesDuration/1,
dec_MsgCRC/1,
dec_MUTCDCode/1,
dec_NodeAttributeLL/1,
'dec_OffsetLL-B12'/1,
'dec_OffsetLL-B14'/1,
'dec_OffsetLL-B16'/1,
'dec_OffsetLL-B22'/1,
'dec_OffsetLL-B24'/1,
'dec_Radius-B12'/1,
dec_SegmentAttributeLL/1,
dec_SignPriority/1,
dec_TravelerInfoType/1,
dec_UniqueMSGID/1,
'dec_URL-Base'/1,
'dec_URL-Short'/1,
dec_Zoom/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('TravelerInformation', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('TravelerInformation', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('TravelerInformation', Data) -> enc_TravelerInformation(Data);
encode_disp('Circle', Data) -> enc_Circle(Data);
encode_disp('GeographicalPath', Data) -> enc_GeographicalPath(Data);
encode_disp('GeometricProjection', Data) -> enc_GeometricProjection(Data);
encode_disp('ExitService', Data) -> enc_ExitService(Data);
encode_disp('GenericSignage', Data) -> enc_GenericSignage(Data);
encode_disp('SpeedLimit', Data) -> enc_SpeedLimit(Data);
encode_disp('WorkZone', Data) -> enc_WorkZone(Data);
encode_disp('Node-LL-24B', Data) -> 'enc_Node-LL-24B'(Data);
encode_disp('Node-LL-28B', Data) -> 'enc_Node-LL-28B'(Data);
encode_disp('Node-LL-32B', Data) -> 'enc_Node-LL-32B'(Data);
encode_disp('Node-LL-36B', Data) -> 'enc_Node-LL-36B'(Data);
encode_disp('Node-LL-44B', Data) -> 'enc_Node-LL-44B'(Data);
encode_disp('Node-LL-48B', Data) -> 'enc_Node-LL-48B'(Data);
encode_disp('NodeAttributeLLList', Data) -> enc_NodeAttributeLLList(Data);
encode_disp('NodeAttributeSetLL', Data) -> enc_NodeAttributeSetLL(Data);
encode_disp('NodeListLL', Data) -> enc_NodeListLL(Data);
encode_disp('NodeLL', Data) -> enc_NodeLL(Data);
encode_disp('NodeOffsetPointLL', Data) -> enc_NodeOffsetPointLL(Data);
encode_disp('NodeSetLL', Data) -> enc_NodeSetLL(Data);
encode_disp('OffsetSystem', Data) -> enc_OffsetSystem(Data);
encode_disp('RegionList', Data) -> enc_RegionList(Data);
encode_disp('RegionOffsets', Data) -> enc_RegionOffsets(Data);
encode_disp('RegionPointSet', Data) -> enc_RegionPointSet(Data);
encode_disp('RoadSignID', Data) -> enc_RoadSignID(Data);
encode_disp('SegmentAttributeLLList', Data) -> enc_SegmentAttributeLLList(Data);
encode_disp('ShapePointSet', Data) -> enc_ShapePointSet(Data);
encode_disp('TravelerDataFrameList', Data) -> enc_TravelerDataFrameList(Data);
encode_disp('TravelerDataFrame', Data) -> enc_TravelerDataFrame(Data);
encode_disp('TravelerDataFrameNewPartIIIContent', Data) -> enc_TravelerDataFrameNewPartIIIContent(Data);
encode_disp('ValidRegion', Data) -> enc_ValidRegion(Data);
encode_disp('DirectionOfUse', Data) -> enc_DirectionOfUse(Data);
encode_disp('DistanceUnits', Data) -> enc_DistanceUnits(Data);
encode_disp('ITIStextPhrase', Data) -> enc_ITIStextPhrase(Data);
encode_disp('MinutesDuration', Data) -> enc_MinutesDuration(Data);
encode_disp('MsgCRC', Data) -> enc_MsgCRC(Data);
encode_disp('MUTCDCode', Data) -> enc_MUTCDCode(Data);
encode_disp('NodeAttributeLL', Data) -> enc_NodeAttributeLL(Data);
encode_disp('OffsetLL-B12', Data) -> 'enc_OffsetLL-B12'(Data);
encode_disp('OffsetLL-B14', Data) -> 'enc_OffsetLL-B14'(Data);
encode_disp('OffsetLL-B16', Data) -> 'enc_OffsetLL-B16'(Data);
encode_disp('OffsetLL-B22', Data) -> 'enc_OffsetLL-B22'(Data);
encode_disp('OffsetLL-B24', Data) -> 'enc_OffsetLL-B24'(Data);
encode_disp('Radius-B12', Data) -> 'enc_Radius-B12'(Data);
encode_disp('SegmentAttributeLL', Data) -> enc_SegmentAttributeLL(Data);
encode_disp('SignPriority', Data) -> enc_SignPriority(Data);
encode_disp('TravelerInfoType', Data) -> enc_TravelerInfoType(Data);
encode_disp('UniqueMSGID', Data) -> enc_UniqueMSGID(Data);
encode_disp('URL-Base', Data) -> 'enc_URL-Base'(Data);
encode_disp('URL-Short', Data) -> 'enc_URL-Short'(Data);
encode_disp('Zoom', Data) -> enc_Zoom(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('TravelerInformation', Data) -> dec_TravelerInformation(Data);
decode_disp('Circle', Data) -> dec_Circle(Data);
decode_disp('GeographicalPath', Data) -> dec_GeographicalPath(Data);
decode_disp('GeometricProjection', Data) -> dec_GeometricProjection(Data);
decode_disp('ExitService', Data) -> dec_ExitService(Data);
decode_disp('GenericSignage', Data) -> dec_GenericSignage(Data);
decode_disp('SpeedLimit', Data) -> dec_SpeedLimit(Data);
decode_disp('WorkZone', Data) -> dec_WorkZone(Data);
decode_disp('Node-LL-24B', Data) -> 'dec_Node-LL-24B'(Data);
decode_disp('Node-LL-28B', Data) -> 'dec_Node-LL-28B'(Data);
decode_disp('Node-LL-32B', Data) -> 'dec_Node-LL-32B'(Data);
decode_disp('Node-LL-36B', Data) -> 'dec_Node-LL-36B'(Data);
decode_disp('Node-LL-44B', Data) -> 'dec_Node-LL-44B'(Data);
decode_disp('Node-LL-48B', Data) -> 'dec_Node-LL-48B'(Data);
decode_disp('NodeAttributeLLList', Data) -> dec_NodeAttributeLLList(Data);
decode_disp('NodeAttributeSetLL', Data) -> dec_NodeAttributeSetLL(Data);
decode_disp('NodeListLL', Data) -> dec_NodeListLL(Data);
decode_disp('NodeLL', Data) -> dec_NodeLL(Data);
decode_disp('NodeOffsetPointLL', Data) -> dec_NodeOffsetPointLL(Data);
decode_disp('NodeSetLL', Data) -> dec_NodeSetLL(Data);
decode_disp('OffsetSystem', Data) -> dec_OffsetSystem(Data);
decode_disp('RegionList', Data) -> dec_RegionList(Data);
decode_disp('RegionOffsets', Data) -> dec_RegionOffsets(Data);
decode_disp('RegionPointSet', Data) -> dec_RegionPointSet(Data);
decode_disp('RoadSignID', Data) -> dec_RoadSignID(Data);
decode_disp('SegmentAttributeLLList', Data) -> dec_SegmentAttributeLLList(Data);
decode_disp('ShapePointSet', Data) -> dec_ShapePointSet(Data);
decode_disp('TravelerDataFrameList', Data) -> dec_TravelerDataFrameList(Data);
decode_disp('TravelerDataFrame', Data) -> dec_TravelerDataFrame(Data);
decode_disp('TravelerDataFrameNewPartIIIContent', Data) -> dec_TravelerDataFrameNewPartIIIContent(Data);
decode_disp('ValidRegion', Data) -> dec_ValidRegion(Data);
decode_disp('DirectionOfUse', Data) -> dec_DirectionOfUse(Data);
decode_disp('DistanceUnits', Data) -> dec_DistanceUnits(Data);
decode_disp('ITIStextPhrase', Data) -> dec_ITIStextPhrase(Data);
decode_disp('MinutesDuration', Data) -> dec_MinutesDuration(Data);
decode_disp('MsgCRC', Data) -> dec_MsgCRC(Data);
decode_disp('MUTCDCode', Data) -> dec_MUTCDCode(Data);
decode_disp('NodeAttributeLL', Data) -> dec_NodeAttributeLL(Data);
decode_disp('OffsetLL-B12', Data) -> 'dec_OffsetLL-B12'(Data);
decode_disp('OffsetLL-B14', Data) -> 'dec_OffsetLL-B14'(Data);
decode_disp('OffsetLL-B16', Data) -> 'dec_OffsetLL-B16'(Data);
decode_disp('OffsetLL-B22', Data) -> 'dec_OffsetLL-B22'(Data);
decode_disp('OffsetLL-B24', Data) -> 'dec_OffsetLL-B24'(Data);
decode_disp('Radius-B12', Data) -> 'dec_Radius-B12'(Data);
decode_disp('SegmentAttributeLL', Data) -> dec_SegmentAttributeLL(Data);
decode_disp('SignPriority', Data) -> dec_SignPriority(Data);
decode_disp('TravelerInfoType', Data) -> dec_TravelerInfoType(Data);
decode_disp('UniqueMSGID', Data) -> dec_UniqueMSGID(Data);
decode_disp('URL-Base', Data) -> 'dec_URL-Base'(Data);
decode_disp('URL-Short', Data) -> 'dec_URL-Short'(Data);
decode_disp('Zoom', Data) -> dec_Zoom(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_TravelerInformation(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(7, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute msgCnt(1) with type INTEGER
Enc6@element = element(2, Val),
if Enc6@element bsr 7 =:= 0 ->
<<Enc6@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end,
begin
%% attribute timeStamp(2) with type INTEGER
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
0 =< Enc8@element, Enc8@element < 527041 ->
<<Enc8@element:20>>;
true ->
exit({error,{asn1,{illegal_integer,Enc8@element}}})
end
end,
begin
%% attribute packetID(3) with type OCTET STRING
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc12@len = byte_size(Enc11@element),
if Enc12@len =:= 9 ->
Enc11@element
end
end
end
end,
begin
%% attribute urlB(4) with type IA5String
Enc14@element = element(5, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc15@len = length(Enc14@element),
Enc15@bin = encode_chars(Enc14@element, 7),
Enc15@len@sub = Enc15@len - 1,
if 0 =< Enc15@len@sub, Enc15@len@sub < 45 ->
[<<Enc15@len@sub:6>>|Enc15@bin]
end
end
end
end,
begin
%% attribute dataFrames(5) with type TravelerDataFrameList
Enc17@element = element(6, Val),
enc_TravelerDataFrameList(Enc17@element)
end|begin
%% attribute regional(6) with type SEQUENCE OF
Enc18@element = element(7, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
true ->
enc_TravelerInformation_regional(Enc18@element)
end
end].
enc_TravelerInformation_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_TravelerInformation_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_TravelerInformation_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type1(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_TravelerInformation(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute msgCnt(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute timeStamp(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:20,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute packetID(3) with type OCTET STRING
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:9/binary-unit:8,V5@Buf1/bitstring>> = Bytes4,
V5@Conv2 = binary:copy(V5@V0),
{V5@Conv2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute urlB(4) with type IA5String
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:6,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + 1,
<<V6@V3:V6@Add2/binary-unit:7,V6@Buf4/bitstring>> = V6@Buf1,
{V6@V5,V6@Buf6}  = {decode_chars(V6@V3, 7),V6@Buf4},
{V6@V5,V6@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute dataFrames(5) with type TravelerDataFrameList
{Term5,Bytes7} = dec_TravelerDataFrameList(Bytes6),

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_TravelerInformation_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V7@V0,V7@Buf1} = case Bytes8 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = {'TravelerInformation',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes10}.


dec_TravelerInformation_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components2(V1@Add2, V1@Buf1, []).


dec_TravelerInformation_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type3(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_Circle(Val) ->
[begin
%% attribute center(1) with type Position3D
Enc1@element = element(2, Val),
'Common':enc_Position3D(Enc1@element)
end,
begin
%% attribute radius(2) with type INTEGER
Enc2@element = element(3, Val),
if Enc2@element bsr 12 =:= 0 ->
<<Enc2@element:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute units(3) with type ENUMERATED
Enc4@element = element(4, Val),
if Enc4@element =:= centimeter ->
<<0:3>>;
Enc4@element =:= 'cm2-5' ->
<<1:3>>;
Enc4@element =:= decimeter ->
<<2:3>>;
Enc4@element =:= meter ->
<<3:3>>;
Enc4@element =:= kilometer ->
<<4:3>>;
Enc4@element =:= foot ->
<<5:3>>;
Enc4@element =:= yard ->
<<6:3>>;
Enc4@element =:= mile ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc4@element}}})
end
end].


dec_Circle(Bytes) ->

%% attribute center(1) with type Position3D
{Term1,Bytes1} = 'Common':dec_Position3D(Bytes),

%% attribute radius(2) with type INTEGER
{Term2,Bytes2} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,

%% attribute units(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes2,
V2@Int2 = case V2@V0 of
0 -> centimeter;
1 -> 'cm2-5';
2 -> decimeter;
3 -> meter;
4 -> kilometer;
5 -> foot;
6 -> yard;
7 -> mile
end,
{V2@Int2,V2@Buf1}
end,
Res1 = {'Circle',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_GeographicalPath(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
if Enc9@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute name(1) with type IA5String
Enc11@element = element(2, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc12@len = length(Enc11@element),
Enc12@bin = encode_chars(Enc11@element, 7),
Enc12@len@sub = Enc12@len - 1,
if 0 =< Enc12@len@sub, Enc12@len@sub < 63 ->
[<<Enc12@len@sub:6>>|Enc12@bin]
end
end
end
end,
begin
%% attribute id(2) with type RoadSegmentReferenceID
Enc14@element = element(3, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_RoadSegmentReferenceID(Enc14@element)
end
end,
begin
%% attribute anchor(3) with type Position3D
Enc16@element = element(4, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_Position3D(Enc16@element)
end
end,
begin
%% attribute laneWidth(4) with type INTEGER
Enc18@element = element(5, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
Enc18@element bsr 15 =:= 0 ->
<<Enc18@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc18@element}}})
end
end,
begin
%% attribute directionality(5) with type ENUMERATED
Enc21@element = element(6, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
Enc21@element =:= unavailable ->
<<0:2>>;
Enc21@element =:= forward ->
<<1:2>>;
Enc21@element =:= reverse ->
<<2:2>>;
Enc21@element =:= both ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc21@element}}})
end
end,
begin
%% attribute closedPath(6) with type BOOLEAN
Enc24@element = element(7, Val),
if Enc24@element =:= asn1_NOVALUE ->
[];
Enc24@element =:= false ->
<<0:1>>;
Enc24@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc24@element}}})
end
end,
begin
%% attribute direction(7) with type BIT STRING
Enc27@element = element(8, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc28@bs = try bit_string_name2pos_4(Enc27@element) of
Enc28@positions ->
bitstring_from_positions(Enc28@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Enc27@element, 16)
end,
Enc28@bits = bit_size(Enc28@bs),
if Enc28@bits =:= 16 ->
Enc28@bs
end
end
end
end,
begin
%% attribute description(8) with type CHOICE
Enc30@element = element(9, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
true ->
enc_GeographicalPath_description(Enc30@element)
end
end|begin
%% attribute regional(9) with type SEQUENCE OF
Enc32@element = element(10, Val),
if Enc32@element =:= asn1_NOVALUE ->
[];
true ->
enc_GeographicalPath_regional(Enc32@element)
end
end].
enc_GeographicalPath_description(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= path ->
[<<0:1,0:2>>|enc_OffsetSystem(ChoiceVal)];
ChoiceTag =:= geometry ->
[<<0:1,1:2>>|enc_GeometricProjection(ChoiceVal)];
ChoiceTag =:= oldRegion ->
[<<0:1,2:2>>|enc_ValidRegion(ChoiceVal)]
end.
enc_GeographicalPath_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_GeographicalPath_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_GeographicalPath_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type1(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_GeographicalPath(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:9,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute name(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute id(2) with type RoadSegmentReferenceID
{Term2,Bytes4} = case (Opt bsr 7) band 1 of
1 ->
'Common':dec_RoadSegmentReferenceID(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute anchor(3) with type Position3D
{Term3,Bytes5} = case (Opt bsr 6) band 1 of
1 ->
'Common':dec_Position3D(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute laneWidth(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V4@V0:15,V4@Buf1/bitstring>> = Bytes5,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute directionality(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V5@V0:2,V5@Buf1/bitstring>> = Bytes6,
V5@Int2 = case V5@V0 of
0 -> unavailable;
1 -> forward;
2 -> reverse;
3 -> both
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute closedPath(6) with type BOOLEAN
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes7,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute direction(7) with type BIT STRING
{Term7,Bytes9} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V7@V0:16/binary-unit:1,V7@Buf1/bitstring>> = Bytes8,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V7@Buf1},
{V7@V2,V7@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute description(8) with type CHOICE
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
dec_GeographicalPath_description(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute regional(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_GeographicalPath_regional(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V8@V0,V8@Buf1} = case Bytes11 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8};
<<1:1,1:1,V8@V7:6,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
V8@Mul9 = V8@V7 * 16384,
{V8@Mul9,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V10:V8@V0/bitstring-unit:1,V8@Buf11/bitstring>> = V8@Buf1,
{V8@V10,V8@Buf11}
end,
Bytes13= skipextensions(Bytes12, 1, Extensions),
Res1 = {'GeographicalPath',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9},
{Res1,Bytes13}.


dec_GeographicalPath_description(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_OffsetSystem(Bytes2)
end,
{{path,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_GeometricProjection(Bytes2)
end,
{{geometry,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_ValidRegion(Bytes2)
end,
{{oldRegion,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.

dec_GeographicalPath_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components5(V1@Add2, V1@Buf1, []).


dec_GeographicalPath_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type3(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_GeometricProjection(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute direction(1) with type BIT STRING
Enc5@element = element(2, Val),
Enc6@bs = try bit_string_name2pos_4(Enc5@element) of
Enc6@positions ->
bitstring_from_positions(Enc6@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Enc5@element, 16)
end,
Enc6@bits = bit_size(Enc6@bs),
if Enc6@bits =:= 16 ->
Enc6@bs
end
end,
begin
%% attribute extent(2) with type ENUMERATED
Enc7@element = element(3, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
Enc7@element =:= useInstantlyOnly ->
<<0:4>>;
Enc7@element =:= useFor3meters ->
<<1:4>>;
Enc7@element =:= useFor10meters ->
<<2:4>>;
Enc7@element =:= useFor50meters ->
<<3:4>>;
Enc7@element =:= useFor100meters ->
<<4:4>>;
Enc7@element =:= useFor500meters ->
<<5:4>>;
Enc7@element =:= useFor1000meters ->
<<6:4>>;
Enc7@element =:= useFor5000meters ->
<<7:4>>;
Enc7@element =:= useFor10000meters ->
<<8:4>>;
Enc7@element =:= useFor50000meters ->
<<9:4>>;
Enc7@element =:= useFor100000meters ->
<<10:4>>;
Enc7@element =:= useFor500000meters ->
<<11:4>>;
Enc7@element =:= useFor1000000meters ->
<<12:4>>;
Enc7@element =:= useFor5000000meters ->
<<13:4>>;
Enc7@element =:= useFor10000000meters ->
<<14:4>>;
Enc7@element =:= forever ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end
end,
begin
%% attribute laneWidth(3) with type INTEGER
Enc10@element = element(4, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
Enc10@element bsr 15 =:= 0 ->
<<Enc10@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc10@element}}})
end
end,
begin
%% attribute circle(4) with type Circle
Enc13@element = element(5, Val),
enc_Circle(Enc13@element)
end|begin
%% attribute regional(5) with type SEQUENCE OF
Enc14@element = element(6, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
true ->
enc_GeometricProjection_regional(Enc14@element)
end
end].
enc_GeometricProjection_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_GeometricProjection_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_GeometricProjection_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type1(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_GeometricProjection(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute direction(1) with type BIT STRING
{Term1,Bytes3} = begin
<<V3@V0:16/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V3@Buf1},
{V3@V2,V3@Buf3}
end,

%% attribute extent(2) with type ENUMERATED
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> useInstantlyOnly;
1 -> useFor3meters;
2 -> useFor10meters;
3 -> useFor50meters;
4 -> useFor100meters;
5 -> useFor500meters;
6 -> useFor1000meters;
7 -> useFor5000meters;
8 -> useFor10000meters;
9 -> useFor50000meters;
10 -> useFor100000meters;
11 -> useFor500000meters;
12 -> useFor1000000meters;
13 -> useFor5000000meters;
14 -> useFor10000000meters;
15 -> forever
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute laneWidth(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:15,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute circle(4) with type Circle
{Term4,Bytes6} = dec_Circle(Bytes5),

%% attribute regional(5) with type SEQUENCE OF
{Term5,Bytes7} = case Opt band 1 of
1 ->
dec_GeometricProjection_regional(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V6@V0,V6@Buf1} = case Bytes7 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'GeometricProjection',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes9}.


dec_GeometricProjection_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components6(V1@Add2, V1@Buf1, []).


dec_GeometricProjection_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type3(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_ExitService(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_ExitService_SEQOF(Comp) || Comp <- Val]]
end.

enc_ExitService_SEQOF(Val) ->
%% attribute item(1) with type CHOICE
Enc1@element = element(2, Val),
enc_ExitService_SEQOF_item(Enc1@element).
enc_ExitService_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 4 =:= 0 ->
[<<1:1,Enc4@len@sub:4>>|Enc4@bin]
end
end
end.


dec_ExitService(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components7(V1@Add2, V1@Buf1, []).


dec_ExitService_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_ExitService_SEQOF_item(Bytes),
Res1 = {'ExitService_SEQOF',Term1},
{Res1,Bytes1}.


dec_ExitService_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
enc_GenericSignage(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_GenericSignage_SEQOF(Comp) || Comp <- Val]]
end.

enc_GenericSignage_SEQOF(Val) ->
%% attribute item(1) with type CHOICE
Enc1@element = element(2, Val),
enc_GenericSignage_SEQOF_item(Enc1@element).
enc_GenericSignage_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 4 =:= 0 ->
[<<1:1,Enc4@len@sub:4>>|Enc4@bin]
end
end
end.


dec_GenericSignage(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components8(V1@Add2, V1@Buf1, []).


dec_GenericSignage_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_GenericSignage_SEQOF_item(Bytes),
Res1 = {'GenericSignage_SEQOF',Term1},
{Res1,Bytes1}.


dec_GenericSignage_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
enc_SpeedLimit(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_SpeedLimit_SEQOF(Comp) || Comp <- Val]]
end.

enc_SpeedLimit_SEQOF(Val) ->
%% attribute item(1) with type CHOICE
Enc1@element = element(2, Val),
enc_SpeedLimit_SEQOF_item(Enc1@element).
enc_SpeedLimit_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 4 =:= 0 ->
[<<1:1,Enc4@len@sub:4>>|Enc4@bin]
end
end
end.


dec_SpeedLimit(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components9(V1@Add2, V1@Buf1, []).


dec_SpeedLimit_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_SpeedLimit_SEQOF_item(Bytes),
Res1 = {'SpeedLimit_SEQOF',Term1},
{Res1,Bytes1}.


dec_SpeedLimit_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
enc_WorkZone(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_WorkZone_SEQOF(Comp) || Comp <- Val]]
end.

enc_WorkZone_SEQOF(Val) ->
%% attribute item(1) with type CHOICE
Enc1@element = element(2, Val),
enc_WorkZone_SEQOF_item(Enc1@element).
enc_WorkZone_SEQOF_item(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= itis ->
if ChoiceVal bsr 16 =:= 0 ->
<<0:1,ChoiceVal:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= text ->
begin
Enc4@len = length(ChoiceVal),
Enc4@bin = encode_chars(ChoiceVal, 7),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 4 =:= 0 ->
[<<1:1,Enc4@len@sub:4>>|Enc4@bin]
end
end
end.


dec_WorkZone(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components10(V1@Add2, V1@Buf1, []).


dec_WorkZone_SEQOF(Bytes) ->

%% attribute item(1) with type CHOICE
{Term1,Bytes1} = dec_WorkZone_SEQOF_item(Bytes),
Res1 = {'WorkZone_SEQOF',Term1},
{Res1,Bytes1}.


dec_WorkZone_SEQOF_item(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{itis,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end
end,
{{text,Val},NewBytes}
end.
'enc_Node-LL-24B'(Val) ->
[begin
%% attribute lon(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -2048,
if Enc1@element@sub bsr 12 =:= 0 ->
<<Enc1@element@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -2048,
if Enc3@element@sub bsr 12 =:= 0 ->
<<Enc3@element@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


'dec_Node-LL-24B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2048,
{V2@Add2,V2@Buf1}
end,
Res1 = {'Node-LL-24B',Term1,Term2},
{Res1,Bytes2}.

'enc_Node-LL-28B'(Val) ->
[begin
%% attribute lon(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -8192,
if Enc1@element@sub bsr 14 =:= 0 ->
<<Enc1@element@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -8192,
if Enc3@element@sub bsr 14 =:= 0 ->
<<Enc3@element@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


'dec_Node-LL-28B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8192,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:14,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -8192,
{V2@Add2,V2@Buf1}
end,
Res1 = {'Node-LL-28B',Term1,Term2},
{Res1,Bytes2}.

'enc_Node-LL-32B'(Val) ->
[begin
%% attribute lon(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -32768,
if Enc1@element@sub bsr 16 =:= 0 ->
<<Enc1@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -32768,
if Enc3@element@sub bsr 16 =:= 0 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


'dec_Node-LL-32B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32768,
{V2@Add2,V2@Buf1}
end,
Res1 = {'Node-LL-32B',Term1,Term2},
{Res1,Bytes2}.

'enc_Node-LL-36B'(Val) ->
[begin
%% attribute lon(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -131072,
if Enc1@element@sub bsr 18 =:= 0 ->
<<Enc1@element@sub:18>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -131072,
if Enc3@element@sub bsr 18 =:= 0 ->
<<Enc3@element@sub:18>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


'dec_Node-LL-36B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:18,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -131072,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:18,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -131072,
{V2@Add2,V2@Buf1}
end,
Res1 = {'Node-LL-36B',Term1,Term2},
{Res1,Bytes2}.

'enc_Node-LL-44B'(Val) ->
[begin
%% attribute lon(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -2097152,
if Enc1@element@sub bsr 22 =:= 0 ->
<<Enc1@element@sub:22>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -2097152,
if Enc3@element@sub bsr 22 =:= 0 ->
<<Enc3@element@sub:22>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


'dec_Node-LL-44B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:22,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2097152,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:22,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2097152,
{V2@Add2,V2@Buf1}
end,
Res1 = {'Node-LL-44B',Term1,Term2},
{Res1,Bytes2}.

'enc_Node-LL-48B'(Val) ->
[begin
%% attribute lon(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -8388608,
if Enc1@element@sub bsr 24 =:= 0 ->
<<Enc1@element@sub:24>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -8388608,
if Enc3@element@sub bsr 24 =:= 0 ->
<<Enc3@element@sub:24>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


'dec_Node-LL-48B'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:24,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8388608,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:24,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -8388608,
{V2@Add2,V2@Buf1}
end,
Res1 = {'Node-LL-48B',Term1,Term2},
{Res1,Bytes2}.

enc_NodeAttributeLLList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp =:= reserved ->
<<0:1,0:4>>;
Comp =:= stopLine ->
<<0:1,1:4>>;
Comp =:= roundedCapStyleA ->
<<0:1,2:4>>;
Comp =:= roundedCapStyleB ->
<<0:1,3:4>>;
Comp =:= mergePoint ->
<<0:1,4:4>>;
Comp =:= divergePoint ->
<<0:1,5:4>>;
Comp =:= downstreamStopLine ->
<<0:1,6:4>>;
Comp =:= downstreamStartNode ->
<<0:1,7:4>>;
Comp =:= closedToTraffic ->
<<0:1,8:4>>;
Comp =:= safeIsland ->
<<0:1,9:4>>;
Comp =:= curbPresentAtStepOff ->
<<0:1,10:4>>;
Comp =:= hydrantPresent ->
<<0:1,11:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]]
end.



dec_NodeAttributeLLList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components11(V1@Add2, V1@Buf1, []).

enc_NodeAttributeSetLL(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
if Enc7@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute localNode(1) with type NodeAttributeLLList
Enc9@element = element(2, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
enc_NodeAttributeLLList(Enc9@element)
end
end,
begin
%% attribute disabled(2) with type SegmentAttributeLLList
Enc11@element = element(3, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
enc_SegmentAttributeLLList(Enc11@element)
end
end,
begin
%% attribute enabled(3) with type SegmentAttributeLLList
Enc13@element = element(4, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
true ->
enc_SegmentAttributeLLList(Enc13@element)
end
end,
begin
%% attribute data(4) with type LaneDataAttributeList
Enc15@element = element(5, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_LaneDataAttributeList(Enc15@element)
end
end,
begin
%% attribute dWidth(5) with type INTEGER
Enc17@element = element(6, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc17@element@sub = Enc17@element - -512,
if Enc17@element@sub bsr 10 =:= 0 ->
<<Enc17@element@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Enc17@element}}})
end
end
end
end,
begin
%% attribute dElevation(6) with type INTEGER
Enc20@element = element(7, Val),
if Enc20@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc20@element@sub = Enc20@element - -512,
if Enc20@element@sub bsr 10 =:= 0 ->
<<Enc20@element@sub:10>>;
true ->
exit({error,{asn1,{illegal_integer,Enc20@element}}})
end
end
end
end|begin
%% attribute regional(7) with type SEQUENCE OF
Enc23@element = element(8, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
true ->
enc_NodeAttributeSetLL_regional(Enc23@element)
end
end].
enc_NodeAttributeSetLL_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_NodeAttributeSetLL_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_NodeAttributeSetLL_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type1(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_NodeAttributeSetLL(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute localNode(1) with type NodeAttributeLLList
{Term1,Bytes3} = case (Opt bsr 6) band 1 of
1 ->
dec_NodeAttributeLLList(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute disabled(2) with type SegmentAttributeLLList
{Term2,Bytes4} = case (Opt bsr 5) band 1 of
1 ->
dec_SegmentAttributeLLList(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute enabled(3) with type SegmentAttributeLLList
{Term3,Bytes5} = case (Opt bsr 4) band 1 of
1 ->
dec_SegmentAttributeLLList(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute data(4) with type LaneDataAttributeList
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
'Common':dec_LaneDataAttributeList(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute dWidth(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:10,V3@Buf1/bitstring>> = Bytes6,
V3@Add2 = V3@V0 + -512,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute dElevation(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:10,V4@Buf1/bitstring>> = Bytes7,
V4@Add2 = V4@V0 + -512,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute regional(7) with type SEQUENCE OF
{Term7,Bytes9} = case Opt band 1 of
1 ->
dec_NodeAttributeSetLL_regional(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V5@V0,V5@Buf1} = case Bytes9 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = {'NodeAttributeSetLL',Term1,Term2,Term3,Term4,Term5,Term6,Term7},
{Res1,Bytes11}.


dec_NodeAttributeSetLL_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components12(V1@Add2, V1@Buf1, []).


dec_NodeAttributeSetLL_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type3(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_NodeListLL(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= nodes ->
[<<0:1>>|enc_NodeSetLL(ChoiceVal)]
end.


dec_NodeListLL(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
ignore,
{0,Bytes1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_NodeSetLL(Bytes2)
end,
{{nodes,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_NodeLL(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute delta(1) with type NodeOffsetPointLL
Enc3@element = element(2, Val),
enc_NodeOffsetPointLL(Enc3@element)
end|begin
%% attribute attributes(2) with type NodeAttributeSetLL
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
enc_NodeAttributeSetLL(Enc4@element)
end
end].


dec_NodeLL(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute delta(1) with type NodeOffsetPointLL
{Term1,Bytes3} = dec_NodeOffsetPointLL(Bytes2),

%% attribute attributes(2) with type NodeAttributeSetLL
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_NodeAttributeSetLL(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'NodeLL',Term1,Term2},
{Res1,Bytes6}.

enc_NodeOffsetPointLL(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= 'node-LL1' ->
[<<0:3>>|'enc_Node-LL-24B'(ChoiceVal)];
ChoiceTag =:= 'node-LL2' ->
[<<1:3>>|'enc_Node-LL-28B'(ChoiceVal)];
ChoiceTag =:= 'node-LL3' ->
[<<2:3>>|'enc_Node-LL-32B'(ChoiceVal)];
ChoiceTag =:= 'node-LL4' ->
[<<3:3>>|'enc_Node-LL-36B'(ChoiceVal)];
ChoiceTag =:= 'node-LL5' ->
[<<4:3>>|'enc_Node-LL-44B'(ChoiceVal)];
ChoiceTag =:= 'node-LL6' ->
[<<5:3>>|'enc_Node-LL-48B'(ChoiceVal)];
ChoiceTag =:= 'node-LatLon' ->
[<<6:3>>|'Common':'enc_Node-LLmD-64b'(ChoiceVal)];
ChoiceTag =:= regional ->
[<<7:3>>|enc_NodeOffsetPointLL_regional(ChoiceVal)]
end.
enc_NodeOffsetPointLL_regional(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type1(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_NodeOffsetPointLL(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'dec_Node-LL-24B'(Bytes1)
end,
{{'node-LL1',Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'dec_Node-LL-28B'(Bytes1)
end,
{{'node-LL2',Val},NewBytes};
2 ->
{Val,NewBytes} = begin
'dec_Node-LL-32B'(Bytes1)
end,
{{'node-LL3',Val},NewBytes};
3 ->
{Val,NewBytes} = begin
'dec_Node-LL-36B'(Bytes1)
end,
{{'node-LL4',Val},NewBytes};
4 ->
{Val,NewBytes} = begin
'dec_Node-LL-44B'(Bytes1)
end,
{{'node-LL5',Val},NewBytes};
5 ->
{Val,NewBytes} = begin
'dec_Node-LL-48B'(Bytes1)
end,
{{'node-LL6',Val},NewBytes};
6 ->
{Val,NewBytes} = begin
'Common':'dec_Node-LLmD-64b'(Bytes1)
end,
{{'node-LatLon',Val},NewBytes};
7 ->
{Val,NewBytes} = begin
dec_NodeOffsetPointLL_regional(Bytes1)
end,
{{regional,Val},NewBytes}
end.

dec_NodeOffsetPointLL_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type3(Tmpterm1, Term1),
Res1 = {'NodeOffsetPointLL_regional',Term1,Term2},
{Res1,Bytes2}.

enc_NodeSetLL(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 2,
if 0 =< Enc1@len@sub, Enc1@len@sub < 62 ->
[<<Enc1@len@sub:6>>|[enc_NodeLL(Comp) || Comp <- Val]]
end.



dec_NodeSetLL(Bytes) ->
%% Length with constraint {2,63}
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 2,
dec_components13(V1@Add2, V1@Buf1, []).

enc_OffsetSystem(Val) ->
[begin
Enc1@element = element(2, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute scale(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element =:= asn1_NOVALUE ->
[];
Enc2@element bsr 4 =:= 0 ->
<<Enc2@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute offset(2) with type CHOICE
Enc5@element = element(3, Val),
enc_OffsetSystem_offset(Enc5@element)
end].
enc_OffsetSystem_offset(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= xy ->
[<<0:1>>|'Common':enc_NodeListXY(ChoiceVal)];
ChoiceTag =:= ll ->
[<<1:1>>|enc_NodeListLL(ChoiceVal)]
end.


dec_OffsetSystem(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute scale(1) with type INTEGER
{Term1,Bytes2} = case Opt band 1 of
1 ->
begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute offset(2) with type CHOICE
{Term2,Bytes3} = dec_OffsetSystem_offset(Bytes2),
Res1 = {'OffsetSystem',Term1,Term2},
{Res1,Bytes3}.


dec_OffsetSystem_offset(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'Common':dec_NodeListXY(Bytes1)
end,
{{xy,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_NodeListLL(Bytes1)
end,
{{ll,Val},NewBytes}
end.
enc_RegionList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 6 =:= 0 ->
[<<Enc1@len@sub:6>>|[enc_RegionOffsets(Comp) || Comp <- Val]]
end.



dec_RegionList(Bytes) ->
%% Length with constraint {1,64}
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components14(V1@Add2, V1@Buf1, []).

enc_RegionOffsets(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute xOffset(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - -32768,
if Enc2@element@sub bsr 16 =:= 0 ->
<<Enc2@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute yOffset(2) with type INTEGER
Enc4@element = element(3, Val),
Enc4@element@sub = Enc4@element - -32768,
if Enc4@element@sub bsr 16 =:= 0 ->
<<Enc4@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end|begin
%% attribute zOffset(3) with type INTEGER
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc6@element@sub = Enc6@element - -32768,
if Enc6@element@sub bsr 16 =:= 0 ->
<<Enc6@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end
end
end].


dec_RegionOffsets(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute xOffset(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32768,
{V2@Add2,V2@Buf1}
end,

%% attribute yOffset(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -32768,
{V3@Add2,V3@Buf1}
end,

%% attribute zOffset(3) with type INTEGER
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -32768,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = {'RegionOffsets',Term1,Term2,Term3},
{Res1,Bytes4}.

enc_RegionPointSet(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute anchor(1) with type Position3D
Enc4@element = element(2, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_Position3D(Enc4@element)
end
end,
begin
%% attribute scale(2) with type INTEGER
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element bsr 4 =:= 0 ->
<<Enc6@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end|begin
%% attribute nodeList(3) with type RegionList
Enc9@element = element(4, Val),
enc_RegionList(Enc9@element)
end].


dec_RegionPointSet(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute anchor(1) with type Position3D
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
'Common':dec_Position3D(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute scale(2) with type INTEGER
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute nodeList(3) with type RegionList
{Term3,Bytes5} = dec_RegionList(Bytes4),

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V4@V0,V4@Buf1} = case Bytes5 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'RegionPointSet',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_RoadSignID(Val) ->
[begin
Enc1@element = element(4, Val),
Enc2@element = element(5, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute position(1) with type Position3D
Enc3@element = element(2, Val),
'Common':enc_Position3D(Enc3@element)
end,
begin
%% attribute viewAngle(2) with type BIT STRING
Enc4@element = element(3, Val),
Enc5@bs = try bit_string_name2pos_4(Enc4@element) of
Enc5@positions ->
bitstring_from_positions(Enc5@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Enc4@element, 16)
end,
Enc5@bits = bit_size(Enc5@bs),
if Enc5@bits =:= 16 ->
Enc5@bs
end
end,
begin
%% attribute mutcdCode(3) with type ENUMERATED
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element =:= none ->
<<0:1,0:3>>;
Enc6@element =:= regulatory ->
<<0:1,1:3>>;
Enc6@element =:= warning ->
<<0:1,2:3>>;
Enc6@element =:= maintenance ->
<<0:1,3:3>>;
Enc6@element =:= motoristService ->
<<0:1,4:3>>;
Enc6@element =:= guide ->
<<0:1,5:3>>;
Enc6@element =:= rec ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc6@element}}})
end
end|begin
%% attribute crc(4) with type OCTET STRING
Enc9@element = element(5, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc10@len = byte_size(Enc9@element),
if Enc10@len =:= 2 ->
Enc9@element
end
end
end
end].


dec_RoadSignID(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute position(1) with type Position3D
{Term1,Bytes2} = 'Common':dec_Position3D(Bytes1),

%% attribute viewAngle(2) with type BIT STRING
{Term2,Bytes3} = begin
<<V2@V0:16/binary-unit:1,V2@Buf1/bitstring>> = Bytes2,
{V2@V2,V2@Buf3}  = {decode_named_bit_string(V2@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V2@Buf1},
{V2@V2,V2@Buf3}
end,

%% attribute mutcdCode(3) with type ENUMERATED
{Term3,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:3,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> none;
1 -> regulatory;
2 -> warning;
3 -> maintenance;
4 -> motoristService;
5 -> guide;
6 -> rec;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11};
<<1:1,1:1,V3@V10:6,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
V3@Mul12 = V3@V10 * 16384,
{V3@Mul12,V3@Buf11}
end,
<<V3@V13:V3@V6/unit:8,V3@Buf14/bitstring>> = V3@Buf7,
{V3@V13,V3@Buf14}
end,
V3@Int15 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int15,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute crc(4) with type OCTET STRING
{Term4,Bytes5} = case Opt band 1 of
1 ->
begin
<<V4@V0:2/binary-unit:8,V4@Buf1/bitstring>> = Bytes4,
V4@Conv2 = binary:copy(V4@V0),
{V4@Conv2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = {'RoadSignID',Term1,Term2,Term3,Term4},
{Res1,Bytes5}.

enc_SegmentAttributeLLList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp =:= reserved ->
<<0:1,0:6>>;
Comp =:= doNotBlock ->
<<0:1,1:6>>;
Comp =:= whiteLine ->
<<0:1,2:6>>;
Comp =:= mergingLaneLeft ->
<<0:1,3:6>>;
Comp =:= mergingLaneRight ->
<<0:1,4:6>>;
Comp =:= curbOnLeft ->
<<0:1,5:6>>;
Comp =:= curbOnRight ->
<<0:1,6:6>>;
Comp =:= loadingzoneOnLeft ->
<<0:1,7:6>>;
Comp =:= loadingzoneOnRight ->
<<0:1,8:6>>;
Comp =:= turnOutPointOnLeft ->
<<0:1,9:6>>;
Comp =:= turnOutPointOnRight ->
<<0:1,10:6>>;
Comp =:= adjacentParkingOnLeft ->
<<0:1,11:6>>;
Comp =:= adjacentParkingOnRight ->
<<0:1,12:6>>;
Comp =:= adjacentBikeLaneOnLeft ->
<<0:1,13:6>>;
Comp =:= adjacentBikeLaneOnRight ->
<<0:1,14:6>>;
Comp =:= sharedBikeLane ->
<<0:1,15:6>>;
Comp =:= bikeBoxInFront ->
<<0:1,16:6>>;
Comp =:= transitStopOnLeft ->
<<0:1,17:6>>;
Comp =:= transitStopOnRight ->
<<0:1,18:6>>;
Comp =:= transitStopInLane ->
<<0:1,19:6>>;
Comp =:= sharedWithTrackedVehicle ->
<<0:1,20:6>>;
Comp =:= safeIsland ->
<<0:1,21:6>>;
Comp =:= lowCurbsPresent ->
<<0:1,22:6>>;
Comp =:= rumbleStripPresent ->
<<0:1,23:6>>;
Comp =:= audibleSignalingPresent ->
<<0:1,24:6>>;
Comp =:= adaptiveTimingPresent ->
<<0:1,25:6>>;
Comp =:= rfSignalRequestPresent ->
<<0:1,26:6>>;
Comp =:= partialCurbIntrusion ->
<<0:1,27:6>>;
Comp =:= taperToLeft ->
<<0:1,28:6>>;
Comp =:= taperToRight ->
<<0:1,29:6>>;
Comp =:= taperToCenterLine ->
<<0:1,30:6>>;
Comp =:= parallelParking ->
<<0:1,31:6>>;
Comp =:= headInParking ->
<<0:1,32:6>>;
Comp =:= freeParking ->
<<0:1,33:6>>;
Comp =:= timeRestrictionsOnParking ->
<<0:1,34:6>>;
Comp =:= costToPark ->
<<0:1,35:6>>;
Comp =:= midBlockCurbPresent ->
<<0:1,36:6>>;
Comp =:= unEvenPavementPresent ->
<<0:1,37:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]]
end.



dec_SegmentAttributeLLList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components15(V1@Add2, V1@Buf1, []).

enc_ShapePointSet(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
if Enc3@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute anchor(1) with type Position3D
Enc5@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_Position3D(Enc5@element)
end
end,
begin
%% attribute laneWidth(2) with type INTEGER
Enc7@element = element(3, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
Enc7@element bsr 15 =:= 0 ->
<<Enc7@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end,
begin
%% attribute directionality(3) with type ENUMERATED
Enc10@element = element(4, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
Enc10@element =:= unavailable ->
<<0:2>>;
Enc10@element =:= forward ->
<<1:2>>;
Enc10@element =:= reverse ->
<<2:2>>;
Enc10@element =:= both ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc10@element}}})
end
end|begin
%% attribute nodeList(4) with type NodeListXY
Enc13@element = element(5, Val),
'Common':enc_NodeListXY(Enc13@element)
end].


dec_ShapePointSet(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute anchor(1) with type Position3D
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
'Common':dec_Position3D(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute laneWidth(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute directionality(3) with type ENUMERATED
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V4@V0:2,V4@Buf1/bitstring>> = Bytes4,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> forward;
2 -> reverse;
3 -> both
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute nodeList(4) with type NodeListXY
{Term4,Bytes6} = 'Common':dec_NodeListXY(Bytes5),

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V5@V0,V5@Buf1} = case Bytes6 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = {'ShapePointSet',Term1,Term2,Term3,Term4},
{Res1,Bytes8}.

enc_TravelerDataFrameList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 3 =:= 0 ->
[<<Enc1@len@sub:3>>|[enc_TravelerDataFrame(Comp) || Comp <- Val]]
end.



dec_TravelerDataFrameList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components16(V1@Add2, V1@Buf1, []).

enc_TravelerDataFrame(Val) ->
Enc3@bitmap = extension_bitmap(Val, 15, 16),
Extensions = if Enc3@bitmap =:= 0 ->
[];
true ->
<<0:7,1:1>>
end,
[begin
Enc1@element = element(5, Val),
if Extensions =:= [] ->
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc1@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc2@element = element(14, Val),
if Enc2@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute doNotUse1(1) with type INTEGER
Enc5@element = element(2, Val),
if Enc5@element bsr 5 =:= 0 ->
<<Enc5@element:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end,
begin
%% attribute frameType(2) with type ENUMERATED
Enc7@element = element(3, Val),
if Enc7@element =:= unknown ->
<<0:1,0:2>>;
Enc7@element =:= advisory ->
<<0:1,1:2>>;
Enc7@element =:= roadSignage ->
<<0:1,2:2>>;
Enc7@element =:= commercialSignage ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end
end,
begin
%% attribute msgId(3) with type CHOICE
Enc9@element = element(4, Val),
enc_TravelerDataFrame_msgId(Enc9@element)
end,
begin
%% attribute startYear(4) with type INTEGER
Enc10@element = element(5, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
Enc10@element bsr 12 =:= 0 ->
<<Enc10@element:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc10@element}}})
end
end,
begin
%% attribute startTime(5) with type INTEGER
Enc13@element = element(6, Val),
if 0 =< Enc13@element, Enc13@element < 527041 ->
<<Enc13@element:20>>;
true ->
exit({error,{asn1,{illegal_integer,Enc13@element}}})
end
end,
begin
%% attribute durationTime(6) with type INTEGER
Enc15@element = element(7, Val),
if 0 =< Enc15@element, Enc15@element < 32001 ->
<<Enc15@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc15@element}}})
end
end,
begin
%% attribute priority(7) with type INTEGER
Enc17@element = element(8, Val),
if Enc17@element bsr 3 =:= 0 ->
<<Enc17@element:3>>;
true ->
exit({error,{asn1,{illegal_integer,Enc17@element}}})
end
end,
begin
%% attribute doNotUse2(8) with type INTEGER
Enc19@element = element(9, Val),
if Enc19@element bsr 5 =:= 0 ->
<<Enc19@element:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc19@element}}})
end
end,
begin
%% attribute regions(9) with type SEQUENCE OF
Enc21@element = element(10, Val),
enc_TravelerDataFrame_regions(Enc21@element)
end,
begin
%% attribute doNotUse3(10) with type INTEGER
Enc22@element = element(11, Val),
if Enc22@element bsr 5 =:= 0 ->
<<Enc22@element:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc22@element}}})
end
end,
begin
%% attribute doNotUse4(11) with type INTEGER
Enc24@element = element(12, Val),
if Enc24@element bsr 5 =:= 0 ->
<<Enc24@element:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc24@element}}})
end
end,
begin
%% attribute content(12) with type CHOICE
Enc26@element = element(13, Val),
enc_TravelerDataFrame_content(Enc26@element)
end,
begin
%% attribute url(13) with type IA5String
Enc27@element = element(14, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc28@len = length(Enc27@element),
Enc28@bin = encode_chars(Enc27@element, 7),
Enc28@len@sub = Enc28@len - 1,
if 0 =< Enc28@len@sub, Enc28@len@sub < 15 ->
[<<Enc28@len@sub:4>>|Enc28@bin]
end
end
end
end,
Extensions|begin
%% attribute contentNew(14) with type TravelerDataFrameNewPartIIIContent
Enc30@element = element(15, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc31@output = enc_TravelerDataFrameNewPartIIIContent(Enc30@element),
Enc31@bin = complete(Enc31@output),
Enc31@len = byte_size(Enc31@bin),
if Enc31@len < 128 ->
[Enc31@len|Enc31@bin];
Enc31@len < 16384 ->
[<<2:2,Enc31@len:14>>|Enc31@bin];
true ->
encode_fragmented(Enc31@bin, 8)
end
end
end
end].
enc_TravelerDataFrame_msgId(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= furtherInfoID ->
begin
Enc2@len = byte_size(ChoiceVal),
if Enc2@len =:= 2 ->
[<<0:1>>|ChoiceVal]
end
end;
ChoiceTag =:= roadSignID ->
[<<1:1>>|enc_RoadSignID(ChoiceVal)]
end.
enc_TravelerDataFrame_regions(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_GeographicalPath(Comp) || Comp <- Val]]
end.

enc_TravelerDataFrame_content(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= advisory ->
[<<0:3>>|'ITIS':enc_ITIScodesAndText(ChoiceVal)];
ChoiceTag =:= workZone ->
[<<1:3>>|enc_WorkZone(ChoiceVal)];
ChoiceTag =:= genericSign ->
[<<2:3>>|enc_GenericSignage(ChoiceVal)];
ChoiceTag =:= speedLimit ->
[<<3:3>>|enc_SpeedLimit(ChoiceVal)];
ChoiceTag =:= exitService ->
[<<4:3>>|enc_ExitService(ChoiceVal)]
end.


dec_TravelerDataFrame(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute doNotUse1(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute frameType(2) with type ENUMERATED
{Term2,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:2,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> unknown;
1 -> advisory;
2 -> roadSignage;
3 -> commercialSignage
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11};
<<1:1,1:1,V4@V10:6,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
V4@Mul12 = V4@V10 * 16384,
{V4@Mul12,V4@Buf11}
end,
<<V4@V13:V4@V6/unit:8,V4@Buf14/bitstring>> = V4@Buf7,
{V4@V13,V4@Buf14}
end,
V4@Int15 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int15,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end,

%% attribute msgId(3) with type CHOICE
{Term3,Bytes5} = dec_TravelerDataFrame_msgId(Bytes4),

%% attribute startYear(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:12,V5@Buf1/bitstring>> = Bytes5,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute startTime(5) with type INTEGER
{Term5,Bytes7} = begin
<<V6@V0:20,V6@Buf1/bitstring>> = Bytes6,
{V6@V0,V6@Buf1}
end,

%% attribute durationTime(6) with type INTEGER
{Term6,Bytes8} = begin
<<V7@V0:15,V7@Buf1/bitstring>> = Bytes7,
{V7@V0,V7@Buf1}
end,

%% attribute priority(7) with type INTEGER
{Term7,Bytes9} = begin
<<V8@V0:3,V8@Buf1/bitstring>> = Bytes8,
{V8@V0,V8@Buf1}
end,

%% attribute doNotUse2(8) with type INTEGER
{Term8,Bytes10} = begin
<<V9@V0:5,V9@Buf1/bitstring>> = Bytes9,
{V9@V0,V9@Buf1}
end,

%% attribute regions(9) with type SEQUENCE OF
{Term9,Bytes11} = dec_TravelerDataFrame_regions(Bytes10),

%% attribute doNotUse3(10) with type INTEGER
{Term10,Bytes12} = begin
<<V10@V0:5,V10@Buf1/bitstring>> = Bytes11,
{V10@V0,V10@Buf1}
end,

%% attribute doNotUse4(11) with type INTEGER
{Term11,Bytes13} = begin
<<V11@V0:5,V11@Buf1/bitstring>> = Bytes12,
{V11@V0,V11@Buf1}
end,

%% attribute content(12) with type CHOICE
{Term12,Bytes14} = dec_TravelerDataFrame_content(Bytes13),

%% attribute url(13) with type IA5String
{Term13,Bytes15} = case Opt band 1 of
1 ->
begin
<<V12@V0:4,V12@Buf1/bitstring>> = Bytes14,
V12@Add2 = V12@V0 + 1,
<<V12@V3:V12@Add2/binary-unit:7,V12@Buf4/bitstring>> = V12@Buf1,
{V12@V5,V12@Buf6}  = {decode_chars(V12@V3, 7),V12@Buf4},
{V12@V5,V12@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% Extensions
{Extensions,Bytes16} = case Ext of
0 -> {<<>>,Bytes15};
1 ->
{V13@V0,V13@Buf1} = case Bytes15 of
<<0:1,V13@V3:6,V13@Buf4/bitstring>> ->
V13@Add5 = V13@V3 + 1,
{V13@Add5,V13@Buf4};
<<1:1,V13@Buf2/bitstring>> ->
{V13@V3,V13@Buf4} = case V13@Buf2 of
<<0:1,V13@V6:7,V13@Buf7/bitstring>> when V13@V6 =/= 0 ->
{V13@V6,V13@Buf7};
<<1:1,0:1,V13@V7:14,V13@Buf8/bitstring>> when V13@V7 =/= 0 ->
{V13@V7,V13@Buf8};
<<1:1,1:1,V13@V7:6,V13@Buf8/bitstring>> when V13@V7 =/= 0 ->
V13@Mul9 = V13@V7 * 16384,
{V13@Mul9,V13@Buf8}
end,
{V13@V3,V13@Buf4}
end,
<<V13@V10:V13@V0/bitstring-unit:1,V13@Buf11/bitstring>> = V13@Buf1,
{V13@V10,V13@Buf11}
end,

%% attribute contentNew(14) with type TravelerDataFrameNewPartIIIContent
{Term14,Bytes17} = case Extensions of
  <<_:0,1:1,_/bitstring>> ->
begin
{V14@V0,V14@Buf1} = case Bytes16 of
<<0:1,V14@V3:7,V14@V5:V14@V3/binary-unit:8,V14@Buf6/bitstring>> ->
{V14@V5,V14@Buf6};
<<1:1,0:1,V14@V4:14,V14@V6:V14@V4/binary-unit:8,V14@Buf7/bitstring>> ->
{V14@V6,V14@Buf7};
<<1:1,1:1,V14@V4:6,V14@Buf5/bitstring>> ->
{V14@V6,V14@Buf7}  = decode_fragmented(V14@V4, V14@Buf5, 8),
{V14@V6,V14@Buf7}
end,
{TmpValx14,_} = dec_TravelerDataFrameNewPartIIIContent(V14@V0),
{TmpValx14,V14@Buf1}
end;
_  ->
{asn1_NOVALUE,Bytes16}
end,
Bytes18= skipextensions(Bytes17, 2, Extensions),
Res1 = {'TravelerDataFrame',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13,Term14},
{Res1,Bytes18}.


dec_TravelerDataFrame_msgId(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:2/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end
end,
{{furtherInfoID,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_RoadSignID(Bytes1)
end,
{{roadSignID,Val},NewBytes}
end.

dec_TravelerDataFrame_regions(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components17(V1@Add2, V1@Buf1, []).


dec_TravelerDataFrame_content(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'ITIS':dec_ITIScodesAndText(Bytes1)
end,
{{advisory,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_WorkZone(Bytes1)
end,
{{workZone,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_GenericSignage(Bytes1)
end,
{{genericSign,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
dec_SpeedLimit(Bytes1)
end,
{{speedLimit,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
dec_ExitService(Bytes1)
end,
{{exitService,Val},NewBytes}
end.
enc_TravelerDataFrameNewPartIIIContent(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= frictionInfo ->
[<<0:1>>|'Common':enc_FrictionInformation(ChoiceVal)]
end.


dec_TravelerDataFrameNewPartIIIContent(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
ignore,
{0,Bytes1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'Common':dec_FrictionInformation(Bytes2)
end,
{{frictionInfo,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_ValidRegion(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute direction(1) with type BIT STRING
Enc2@element = element(2, Val),
Enc3@bs = try bit_string_name2pos_4(Enc2@element) of
Enc3@positions ->
bitstring_from_positions(Enc3@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Enc2@element, 16)
end,
Enc3@bits = bit_size(Enc3@bs),
if Enc3@bits =:= 16 ->
Enc3@bs
end
end,
begin
%% attribute extent(2) with type ENUMERATED
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
Enc4@element =:= useInstantlyOnly ->
<<0:4>>;
Enc4@element =:= useFor3meters ->
<<1:4>>;
Enc4@element =:= useFor10meters ->
<<2:4>>;
Enc4@element =:= useFor50meters ->
<<3:4>>;
Enc4@element =:= useFor100meters ->
<<4:4>>;
Enc4@element =:= useFor500meters ->
<<5:4>>;
Enc4@element =:= useFor1000meters ->
<<6:4>>;
Enc4@element =:= useFor5000meters ->
<<7:4>>;
Enc4@element =:= useFor10000meters ->
<<8:4>>;
Enc4@element =:= useFor50000meters ->
<<9:4>>;
Enc4@element =:= useFor100000meters ->
<<10:4>>;
Enc4@element =:= useFor500000meters ->
<<11:4>>;
Enc4@element =:= useFor1000000meters ->
<<12:4>>;
Enc4@element =:= useFor5000000meters ->
<<13:4>>;
Enc4@element =:= useFor10000000meters ->
<<14:4>>;
Enc4@element =:= forever ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc4@element}}})
end
end|begin
%% attribute area(3) with type CHOICE
Enc7@element = element(4, Val),
enc_ValidRegion_area(Enc7@element)
end].
enc_ValidRegion_area(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= shapePointSet ->
[<<0:2>>|enc_ShapePointSet(ChoiceVal)];
ChoiceTag =:= circle ->
[<<1:2>>|enc_Circle(ChoiceVal)];
ChoiceTag =:= regionPointSet ->
[<<2:2>>|enc_RegionPointSet(ChoiceVal)]
end.


dec_ValidRegion(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute direction(1) with type BIT STRING
{Term1,Bytes2} = begin
<<V2@V0:16/binary-unit:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V2,V2@Buf3}  = {decode_named_bit_string(V2@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V2@Buf1},
{V2@V2,V2@Buf3}
end,

%% attribute extent(2) with type ENUMERATED
{Term2,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> useInstantlyOnly;
1 -> useFor3meters;
2 -> useFor10meters;
3 -> useFor50meters;
4 -> useFor100meters;
5 -> useFor500meters;
6 -> useFor1000meters;
7 -> useFor5000meters;
8 -> useFor10000meters;
9 -> useFor50000meters;
10 -> useFor100000meters;
11 -> useFor500000meters;
12 -> useFor1000000meters;
13 -> useFor5000000meters;
14 -> useFor10000000meters;
15 -> forever
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute area(3) with type CHOICE
{Term3,Bytes4} = dec_ValidRegion_area(Bytes3),
Res1 = {'ValidRegion',Term1,Term2,Term3},
{Res1,Bytes4}.


dec_ValidRegion_area(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_ShapePointSet(Bytes1)
end,
{{shapePointSet,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_Circle(Bytes1)
end,
{{circle,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_RegionPointSet(Bytes1)
end,
{{regionPointSet,Val},NewBytes}
end.
enc_DirectionOfUse(Val) ->
if Val =:= unavailable ->
<<0:2>>;
Val =:= forward ->
<<1:2>>;
Val =:= reverse ->
<<2:2>>;
Val =:= both ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_DirectionOfUse(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> forward;
2 -> reverse;
3 -> both
end,
{V1@Int2,V1@Buf1}
end.

enc_DistanceUnits(Val) ->
if Val =:= centimeter ->
<<0:3>>;
Val =:= 'cm2-5' ->
<<1:3>>;
Val =:= decimeter ->
<<2:3>>;
Val =:= meter ->
<<3:3>>;
Val =:= kilometer ->
<<4:3>>;
Val =:= foot ->
<<5:3>>;
Val =:= yard ->
<<6:3>>;
Val =:= mile ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_DistanceUnits(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> centimeter;
1 -> 'cm2-5';
2 -> decimeter;
3 -> meter;
4 -> kilometer;
5 -> foot;
6 -> yard;
7 -> mile
end,
{V1@Int2,V1@Buf1}
end.

enc_ITIStextPhrase(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|Enc1@bin]
end.


dec_ITIStextPhrase(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

enc_MinutesDuration(Val) ->
if 0 =< Val, Val < 32001 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MinutesDuration(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_MsgCRC(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 2 ->
Val
end.


dec_MsgCRC(Bytes) ->
begin
<<V1@V0:2/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_MUTCDCode(Val) ->
if Val =:= none ->
<<0:1,0:3>>;
Val =:= regulatory ->
<<0:1,1:3>>;
Val =:= warning ->
<<0:1,2:3>>;
Val =:= maintenance ->
<<0:1,3:3>>;
Val =:= motoristService ->
<<0:1,4:3>>;
Val =:= guide ->
<<0:1,5:3>>;
Val =:= rec ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_MUTCDCode(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> none;
1 -> regulatory;
2 -> warning;
3 -> maintenance;
4 -> motoristService;
5 -> guide;
6 -> rec;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NodeAttributeLL(Val) ->
if Val =:= reserved ->
<<0:1,0:4>>;
Val =:= stopLine ->
<<0:1,1:4>>;
Val =:= roundedCapStyleA ->
<<0:1,2:4>>;
Val =:= roundedCapStyleB ->
<<0:1,3:4>>;
Val =:= mergePoint ->
<<0:1,4:4>>;
Val =:= divergePoint ->
<<0:1,5:4>>;
Val =:= downstreamStopLine ->
<<0:1,6:4>>;
Val =:= downstreamStartNode ->
<<0:1,7:4>>;
Val =:= closedToTraffic ->
<<0:1,8:4>>;
Val =:= safeIsland ->
<<0:1,9:4>>;
Val =:= curbPresentAtStepOff ->
<<0:1,10:4>>;
Val =:= hydrantPresent ->
<<0:1,11:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NodeAttributeLL(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> stopLine;
2 -> roundedCapStyleA;
3 -> roundedCapStyleB;
4 -> mergePoint;
5 -> divergePoint;
6 -> downstreamStopLine;
7 -> downstreamStartNode;
8 -> closedToTraffic;
9 -> safeIsland;
10 -> curbPresentAtStepOff;
11 -> hydrantPresent;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

'enc_OffsetLL-B12'(Val) ->
Val@sub = Val - -2048,
if Val@sub bsr 12 =:= 0 ->
<<Val@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B12'(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B14'(Val) ->
Val@sub = Val - -8192,
if Val@sub bsr 14 =:= 0 ->
<<Val@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B14'(Bytes) ->
begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8192,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B16'(Val) ->
Val@sub = Val - -32768,
if Val@sub bsr 16 =:= 0 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B16'(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B22'(Val) ->
Val@sub = Val - -2097152,
if Val@sub bsr 22 =:= 0 ->
<<Val@sub:22>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B22'(Bytes) ->
begin
<<V1@V0:22,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2097152,
{V1@Add2,V1@Buf1}
end.

'enc_OffsetLL-B24'(Val) ->
Val@sub = Val - -8388608,
if Val@sub bsr 24 =:= 0 ->
<<Val@sub:24>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_OffsetLL-B24'(Bytes) ->
begin
<<V1@V0:24,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -8388608,
{V1@Add2,V1@Buf1}
end.

'enc_Radius-B12'(Val) ->
if Val bsr 12 =:= 0 ->
<<Val:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_Radius-B12'(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SegmentAttributeLL(Val) ->
if Val =:= reserved ->
<<0:1,0:6>>;
Val =:= doNotBlock ->
<<0:1,1:6>>;
Val =:= whiteLine ->
<<0:1,2:6>>;
Val =:= mergingLaneLeft ->
<<0:1,3:6>>;
Val =:= mergingLaneRight ->
<<0:1,4:6>>;
Val =:= curbOnLeft ->
<<0:1,5:6>>;
Val =:= curbOnRight ->
<<0:1,6:6>>;
Val =:= loadingzoneOnLeft ->
<<0:1,7:6>>;
Val =:= loadingzoneOnRight ->
<<0:1,8:6>>;
Val =:= turnOutPointOnLeft ->
<<0:1,9:6>>;
Val =:= turnOutPointOnRight ->
<<0:1,10:6>>;
Val =:= adjacentParkingOnLeft ->
<<0:1,11:6>>;
Val =:= adjacentParkingOnRight ->
<<0:1,12:6>>;
Val =:= adjacentBikeLaneOnLeft ->
<<0:1,13:6>>;
Val =:= adjacentBikeLaneOnRight ->
<<0:1,14:6>>;
Val =:= sharedBikeLane ->
<<0:1,15:6>>;
Val =:= bikeBoxInFront ->
<<0:1,16:6>>;
Val =:= transitStopOnLeft ->
<<0:1,17:6>>;
Val =:= transitStopOnRight ->
<<0:1,18:6>>;
Val =:= transitStopInLane ->
<<0:1,19:6>>;
Val =:= sharedWithTrackedVehicle ->
<<0:1,20:6>>;
Val =:= safeIsland ->
<<0:1,21:6>>;
Val =:= lowCurbsPresent ->
<<0:1,22:6>>;
Val =:= rumbleStripPresent ->
<<0:1,23:6>>;
Val =:= audibleSignalingPresent ->
<<0:1,24:6>>;
Val =:= adaptiveTimingPresent ->
<<0:1,25:6>>;
Val =:= rfSignalRequestPresent ->
<<0:1,26:6>>;
Val =:= partialCurbIntrusion ->
<<0:1,27:6>>;
Val =:= taperToLeft ->
<<0:1,28:6>>;
Val =:= taperToRight ->
<<0:1,29:6>>;
Val =:= taperToCenterLine ->
<<0:1,30:6>>;
Val =:= parallelParking ->
<<0:1,31:6>>;
Val =:= headInParking ->
<<0:1,32:6>>;
Val =:= freeParking ->
<<0:1,33:6>>;
Val =:= timeRestrictionsOnParking ->
<<0:1,34:6>>;
Val =:= costToPark ->
<<0:1,35:6>>;
Val =:= midBlockCurbPresent ->
<<0:1,36:6>>;
Val =:= unEvenPavementPresent ->
<<0:1,37:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SegmentAttributeLL(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> doNotBlock;
2 -> whiteLine;
3 -> mergingLaneLeft;
4 -> mergingLaneRight;
5 -> curbOnLeft;
6 -> curbOnRight;
7 -> loadingzoneOnLeft;
8 -> loadingzoneOnRight;
9 -> turnOutPointOnLeft;
10 -> turnOutPointOnRight;
11 -> adjacentParkingOnLeft;
12 -> adjacentParkingOnRight;
13 -> adjacentBikeLaneOnLeft;
14 -> adjacentBikeLaneOnRight;
15 -> sharedBikeLane;
16 -> bikeBoxInFront;
17 -> transitStopOnLeft;
18 -> transitStopOnRight;
19 -> transitStopInLane;
20 -> sharedWithTrackedVehicle;
21 -> safeIsland;
22 -> lowCurbsPresent;
23 -> rumbleStripPresent;
24 -> audibleSignalingPresent;
25 -> adaptiveTimingPresent;
26 -> rfSignalRequestPresent;
27 -> partialCurbIntrusion;
28 -> taperToLeft;
29 -> taperToRight;
30 -> taperToCenterLine;
31 -> parallelParking;
32 -> headInParking;
33 -> freeParking;
34 -> timeRestrictionsOnParking;
35 -> costToPark;
36 -> midBlockCurbPresent;
37 -> unEvenPavementPresent;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_SignPriority(Val) ->
if Val bsr 3 =:= 0 ->
<<Val:3>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SignPriority(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TravelerInfoType(Val) ->
if Val =:= unknown ->
<<0:1,0:2>>;
Val =:= advisory ->
<<0:1,1:2>>;
Val =:= roadSignage ->
<<0:1,2:2>>;
Val =:= commercialSignage ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_TravelerInfoType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> advisory;
2 -> roadSignage;
3 -> commercialSignage
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_UniqueMSGID(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 9 ->
Val
end.


dec_UniqueMSGID(Bytes) ->
begin
<<V1@V0:9/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

'enc_URL-Base'(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 45 ->
[<<Enc1@len@sub:6>>|Enc1@bin]
end.


'dec_URL-Base'(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

'enc_URL-Short'(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 15 ->
[<<Enc1@len@sub:4>>|Enc1@bin]
end.


'dec_URL-Short'(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

enc_Zoom(Val) ->
if Val bsr 4 =:= 0 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Zoom(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

typeinfo('TravelerInformation') ->
  {sequence,'TravelerInformation',6,[{<<109,115,103,67,110,116>>,{'INTEGER',{0,127}},mandatory},{<<116,105,109,101,83,116,97,109,112>>,{'INTEGER',{0,527040}},'OPTIONAL'},{<<112,97,99,107,101,116,73,68>>,octet_string,'OPTIONAL'},{<<117,114,108,66>>,string,'OPTIONAL'},{<<100,97,116,97,70,114,97,109,101,115>>,{typeinfo,{'TravelerInformation','TravelerDataFrameList'}},mandatory},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'TravelerInformation_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'TravelerInformation',internal_object_set_argument_5}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('Circle') ->
  {sequence,'Circle',3,[{<<99,101,110,116,101,114>>,{typeinfo,{'Common','Position3D'}},mandatory},{<<114,97,100,105,117,115>>,{'INTEGER',{0,4095}},mandatory},{<<117,110,105,116,115>>,{'ENUMERATED',#{mile => 7,kilometer => 4,centimeter => 0,'cm2-5' => 1,decimeter => 2,meter => 3,foot => 5,yard => 6}},mandatory}]};
typeinfo('GeographicalPath') ->
  {sequence,'GeographicalPath',9,[{<<110,97,109,101>>,string,'OPTIONAL'},{<<105,100>>,{typeinfo,{'Common','RoadSegmentReferenceID'}},'OPTIONAL'},{<<97,110,99,104,111,114>>,{typeinfo,{'Common','Position3D'}},'OPTIONAL'},{<<108,97,110,101,87,105,100,116,104>>,{'INTEGER',{0,32767}},'OPTIONAL'},{<<100,105,114,101,99,116,105,111,110,97,108,105,116,121>>,{'ENUMERATED',#{reverse => 2,both => 3,unavailable => 0,forward => 1}},'OPTIONAL'},{<<99,108,111,115,101,100,80,97,116,104>>,'BOOLEAN','OPTIONAL'},{<<100,105,114,101,99,116,105,111,110>>,{{bit_string_nnl,[{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]},16},'OPTIONAL'},{<<100,101,115,99,114,105,112,116,105,111,110>>,{choice,#{<<103,101,111,109,101,116,114,121>> => {typeinfo,{'TravelerInformation','GeometricProjection'}},<<111,108,100,82,101,103,105,111,110>> => {typeinfo,{'TravelerInformation','ValidRegion'}},<<112,97,116,104>> => {typeinfo,{'TravelerInformation','OffsetSystem'}}}},'OPTIONAL'},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'GeographicalPath_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'TravelerInformation',internal_object_set_argument_4}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('GeometricProjection') ->
  {sequence,'GeometricProjection',5,[{<<100,105,114,101,99,116,105,111,110>>,{{bit_string_nnl,[{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]},16},mandatory},{<<101,120,116,101,110,116>>,{'ENUMERATED',#{useInstantlyOnly => 0,useFor3meters => 1,useFor10meters => 2,useFor50meters => 3,useFor100meters => 4,useFor500meters => 5,useFor1000meters => 6,useFor5000meters => 7,useFor10000meters => 8,useFor50000meters => 9,useFor100000meters => 10,useFor500000meters => 11,useFor1000000meters => 12,useFor5000000meters => 13,useFor10000000meters => 14,forever => 15}},'OPTIONAL'},{<<108,97,110,101,87,105,100,116,104>>,{'INTEGER',{0,32767}},'OPTIONAL'},{<<99,105,114,99,108,101>>,{typeinfo,{'TravelerInformation','Circle'}},mandatory},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'GeometricProjection_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'TravelerInformation',internal_object_set_argument_3}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('ExitService') ->
  {sof,{sequence,'ExitService_SEQOF',1,[{<<105,116,101,109>>,{choice,#{<<105,116,105,115>> => {'INTEGER',{0,65535}},<<116,101,120,116>> => string}},mandatory}]}};
typeinfo('GenericSignage') ->
  {sof,{sequence,'GenericSignage_SEQOF',1,[{<<105,116,101,109>>,{choice,#{<<105,116,105,115>> => {'INTEGER',{0,65535}},<<116,101,120,116>> => string}},mandatory}]}};
typeinfo('SpeedLimit') ->
  {sof,{sequence,'SpeedLimit_SEQOF',1,[{<<105,116,101,109>>,{choice,#{<<105,116,105,115>> => {'INTEGER',{0,65535}},<<116,101,120,116>> => string}},mandatory}]}};
typeinfo('WorkZone') ->
  {sof,{sequence,'WorkZone_SEQOF',1,[{<<105,116,101,109>>,{choice,#{<<105,116,105,115>> => {'INTEGER',{0,65535}},<<116,101,120,116>> => string}},mandatory}]}};
typeinfo('Node-LL-24B') ->
  {sequence,'Node-LL-24B',2,[{<<108,111,110>>,{'INTEGER',{-2048,2047}},mandatory},{<<108,97,116>>,{'INTEGER',{-2048,2047}},mandatory}]};
typeinfo('Node-LL-28B') ->
  {sequence,'Node-LL-28B',2,[{<<108,111,110>>,{'INTEGER',{-8192,8191}},mandatory},{<<108,97,116>>,{'INTEGER',{-8192,8191}},mandatory}]};
typeinfo('Node-LL-32B') ->
  {sequence,'Node-LL-32B',2,[{<<108,111,110>>,{'INTEGER',{-32768,32767}},mandatory},{<<108,97,116>>,{'INTEGER',{-32768,32767}},mandatory}]};
typeinfo('Node-LL-36B') ->
  {sequence,'Node-LL-36B',2,[{<<108,111,110>>,{'INTEGER',{-131072,131071}},mandatory},{<<108,97,116>>,{'INTEGER',{-131072,131071}},mandatory}]};
typeinfo('Node-LL-44B') ->
  {sequence,'Node-LL-44B',2,[{<<108,111,110>>,{'INTEGER',{-2097152,2097151}},mandatory},{<<108,97,116>>,{'INTEGER',{-2097152,2097151}},mandatory}]};
typeinfo('Node-LL-48B') ->
  {sequence,'Node-LL-48B',2,[{<<108,111,110>>,{'INTEGER',{-8388608,8388607}},mandatory},{<<108,97,116>>,{'INTEGER',{-8388608,8388607}},mandatory}]};
typeinfo('NodeAttributeLLList') ->
  {sof,{'ENUMERATED_EXT',#{reserved => 0,stopLine => 1,roundedCapStyleA => 2,roundedCapStyleB => 3,mergePoint => 4,divergePoint => 5,downstreamStopLine => 6,downstreamStartNode => 7,closedToTraffic => 8,safeIsland => 9,curbPresentAtStepOff => 10,hydrantPresent => 11}}};
typeinfo('NodeAttributeSetLL') ->
  {sequence,'NodeAttributeSetLL',7,[{<<108,111,99,97,108,78,111,100,101>>,{typeinfo,{'TravelerInformation','NodeAttributeLLList'}},'OPTIONAL'},{<<100,105,115,97,98,108,101,100>>,{typeinfo,{'TravelerInformation','SegmentAttributeLLList'}},'OPTIONAL'},{<<101,110,97,98,108,101,100>>,{typeinfo,{'TravelerInformation','SegmentAttributeLLList'}},'OPTIONAL'},{<<100,97,116,97>>,{typeinfo,{'Common','LaneDataAttributeList'}},'OPTIONAL'},{<<100,87,105,100,116,104>>,{'INTEGER',{-512,511}},'OPTIONAL'},{<<100,69,108,101,118,97,116,105,111,110>>,{'INTEGER',{-512,511}},'OPTIONAL'},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'NodeAttributeSetLL_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'TravelerInformation',internal_object_set_argument_2}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('NodeListLL') ->
  {choice,#{<<110,111,100,101,115>> => {typeinfo,{'TravelerInformation','NodeSetLL'}}}};
typeinfo('NodeLL') ->
  {sequence,'NodeLL',2,[{<<100,101,108,116,97>>,{typeinfo,{'TravelerInformation','NodeOffsetPointLL'}},mandatory},{<<97,116,116,114,105,98,117,116,101,115>>,{typeinfo,{'TravelerInformation','NodeAttributeSetLL'}},'OPTIONAL'}]};
typeinfo('NodeOffsetPointLL') ->
  {choice,#{<<110,111,100,101,45,76,76,49>> => {typeinfo,{'TravelerInformation','Node-LL-24B'}},<<110,111,100,101,45,76,76,50>> => {typeinfo,{'TravelerInformation','Node-LL-28B'}},<<110,111,100,101,45,76,76,51>> => {typeinfo,{'TravelerInformation','Node-LL-32B'}},<<110,111,100,101,45,76,76,52>> => {typeinfo,{'TravelerInformation','Node-LL-36B'}},<<110,111,100,101,45,76,76,53>> => {typeinfo,{'TravelerInformation','Node-LL-44B'}},<<110,111,100,101,45,76,76,54>> => {typeinfo,{'TravelerInformation','Node-LL-48B'}},<<110,111,100,101,45,76,97,116,76,111,110>> => {typeinfo,{'Common','Node-LLmD-64b'}},<<114,101,103,105,111,110,97,108>> => {sequence,'NodeOffsetPointLL_regional',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'TravelerInformation',internal_object_set_argument_1}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}}};
typeinfo('NodeSetLL') ->
  {sof,{typeinfo,{'TravelerInformation','NodeLL'}}};
typeinfo('OffsetSystem') ->
  {sequence,'OffsetSystem',2,[{<<115,99,97,108,101>>,{'INTEGER',{0,15}},'OPTIONAL'},{<<111,102,102,115,101,116>>,{choice,#{<<108,108>> => {typeinfo,{'TravelerInformation','NodeListLL'}},<<120,121>> => {typeinfo,{'Common','NodeListXY'}}}},mandatory}]};
typeinfo('RegionList') ->
  {sof,{typeinfo,{'TravelerInformation','RegionOffsets'}}};
typeinfo('RegionOffsets') ->
  {sequence,'RegionOffsets',3,[{<<120,79,102,102,115,101,116>>,{'INTEGER',{-32768,32767}},mandatory},{<<121,79,102,102,115,101,116>>,{'INTEGER',{-32768,32767}},mandatory},{<<122,79,102,102,115,101,116>>,{'INTEGER',{-32768,32767}},'OPTIONAL'}]};
typeinfo('RegionPointSet') ->
  {sequence,'RegionPointSet',3,[{<<97,110,99,104,111,114>>,{typeinfo,{'Common','Position3D'}},'OPTIONAL'},{<<115,99,97,108,101>>,{'INTEGER',{0,15}},'OPTIONAL'},{<<110,111,100,101,76,105,115,116>>,{typeinfo,{'TravelerInformation','RegionList'}},mandatory}]};
typeinfo('RoadSignID') ->
  {sequence,'RoadSignID',4,[{<<112,111,115,105,116,105,111,110>>,{typeinfo,{'Common','Position3D'}},mandatory},{<<118,105,101,119,65,110,103,108,101>>,{{bit_string_nnl,[{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]},16},mandatory},{<<109,117,116,99,100,67,111,100,101>>,{'ENUMERATED_EXT',#{none => 0,warning => 2,regulatory => 1,maintenance => 3,motoristService => 4,guide => 5,rec => 6}},'OPTIONAL'},{<<99,114,99>>,octet_string,'OPTIONAL'}]};
typeinfo('SegmentAttributeLLList') ->
  {sof,{'ENUMERATED_EXT',#{sharedBikeLane => 15,audibleSignalingPresent => 24,transitStopOnLeft => 17,safeIsland => 21,unEvenPavementPresent => 37,bikeBoxInFront => 16,taperToCenterLine => 30,transitStopOnRight => 18,sharedWithTrackedVehicle => 20,partialCurbIntrusion => 27,adjacentParkingOnLeft => 11,mergingLaneRight => 4,turnOutPointOnRight => 10,curbOnLeft => 5,turnOutPointOnLeft => 9,loadingzoneOnLeft => 7,doNotBlock => 1,taperToRight => 29,loadingzoneOnRight => 8,transitStopInLane => 19,timeRestrictionsOnParking => 34,adjacentBikeLaneOnLeft => 13,freeParking => 33,parallelParking => 31,rfSignalRequestPresent => 26,adaptiveTimingPresent => 25,whiteLine => 2,taperToLeft => 28,reserved => 0,rumbleStripPresent => 23,adjacentParkingOnRight => 12,mergingLaneLeft => 3,headInParking => 32,costToPark => 35,adjacentBikeLaneOnRight => 14,curbOnRight => 6,midBlockCurbPresent => 36,lowCurbsPresent => 22}}};
typeinfo('ShapePointSet') ->
  {sequence,'ShapePointSet',4,[{<<97,110,99,104,111,114>>,{typeinfo,{'Common','Position3D'}},'OPTIONAL'},{<<108,97,110,101,87,105,100,116,104>>,{'INTEGER',{0,32767}},'OPTIONAL'},{<<100,105,114,101,99,116,105,111,110,97,108,105,116,121>>,{'ENUMERATED',#{reverse => 2,both => 3,unavailable => 0,forward => 1}},'OPTIONAL'},{<<110,111,100,101,76,105,115,116>>,{typeinfo,{'Common','NodeListXY'}},mandatory}]};
typeinfo('TravelerDataFrameList') ->
  {sof,{typeinfo,{'TravelerInformation','TravelerDataFrame'}}};
typeinfo('TravelerDataFrame') ->
  {sequence,'TravelerDataFrame',14,[{<<100,111,78,111,116,85,115,101,49>>,{'INTEGER',{0,31}},mandatory},{<<102,114,97,109,101,84,121,112,101>>,{'ENUMERATED_EXT',#{unknown => 0,advisory => 1,roadSignage => 2,commercialSignage => 3}},mandatory},{<<109,115,103,73,100>>,{choice,#{<<102,117,114,116,104,101,114,73,110,102,111,73,68>> => octet_string,<<114,111,97,100,83,105,103,110,73,68>> => {typeinfo,{'TravelerInformation','RoadSignID'}}}},mandatory},{<<115,116,97,114,116,89,101,97,114>>,{'INTEGER',{0,4095}},'OPTIONAL'},{<<115,116,97,114,116,84,105,109,101>>,{'INTEGER',{0,527040}},mandatory},{<<100,117,114,97,116,105,111,110,84,105,109,101>>,{'INTEGER',{0,32000}},mandatory},{<<112,114,105,111,114,105,116,121>>,{'INTEGER',{0,7}},mandatory},{<<100,111,78,111,116,85,115,101,50>>,{'INTEGER',{0,31}},mandatory},{<<114,101,103,105,111,110,115>>,{sof,{typeinfo,{'TravelerInformation','GeographicalPath'}}},mandatory},{<<100,111,78,111,116,85,115,101,51>>,{'INTEGER',{0,31}},mandatory},{<<100,111,78,111,116,85,115,101,52>>,{'INTEGER',{0,31}},mandatory},{<<99,111,110,116,101,110,116>>,{choice,#{<<97,100,118,105,115,111,114,121>> => {typeinfo,{'ITIS','ITIScodesAndText'}},<<101,120,105,116,83,101,114,118,105,99,101>> => {typeinfo,{'TravelerInformation','ExitService'}},<<103,101,110,101,114,105,99,83,105,103,110>> => {typeinfo,{'TravelerInformation','GenericSignage'}},<<115,112,101,101,100,76,105,109,105,116>> => {typeinfo,{'TravelerInformation','SpeedLimit'}},<<119,111,114,107,90,111,110,101>> => {typeinfo,{'TravelerInformation','WorkZone'}}}},mandatory},{<<117,114,108>>,string,'OPTIONAL'},{<<99,111,110,116,101,110,116,78,101,119>>,{typeinfo,{'TravelerInformation','TravelerDataFrameNewPartIIIContent'}},mandatory}]};
typeinfo('TravelerDataFrameNewPartIIIContent') ->
  {choice,#{<<102,114,105,99,116,105,111,110,73,110,102,111>> => {typeinfo,{'Common','FrictionInformation'}}}};
typeinfo('ValidRegion') ->
  {sequence,'ValidRegion',3,[{<<100,105,114,101,99,116,105,111,110>>,{{bit_string_nnl,[{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]},16},mandatory},{<<101,120,116,101,110,116>>,{'ENUMERATED',#{useInstantlyOnly => 0,useFor3meters => 1,useFor10meters => 2,useFor50meters => 3,useFor100meters => 4,useFor500meters => 5,useFor1000meters => 6,useFor5000meters => 7,useFor10000meters => 8,useFor50000meters => 9,useFor100000meters => 10,useFor500000meters => 11,useFor1000000meters => 12,useFor5000000meters => 13,useFor10000000meters => 14,forever => 15}},'OPTIONAL'},{<<97,114,101,97>>,{choice,#{<<99,105,114,99,108,101>> => {typeinfo,{'TravelerInformation','Circle'}},<<114,101,103,105,111,110,80,111,105,110,116,83,101,116>> => {typeinfo,{'TravelerInformation','RegionPointSet'}},<<115,104,97,112,101,80,111,105,110,116,83,101,116>> => {typeinfo,{'TravelerInformation','ShapePointSet'}}}},mandatory}]};
typeinfo('DirectionOfUse') ->
  {'ENUMERATED',#{reverse => 2,both => 3,unavailable => 0,forward => 1}};
typeinfo('DistanceUnits') ->
  {'ENUMERATED',#{mile => 7,kilometer => 4,centimeter => 0,'cm2-5' => 1,decimeter => 2,meter => 3,foot => 5,yard => 6}};
typeinfo('ITIStextPhrase') ->
  string;
typeinfo('MinutesDuration') ->
  {'INTEGER',{0,32000}};
typeinfo('MsgCRC') ->
  octet_string;
typeinfo('MUTCDCode') ->
  {'ENUMERATED_EXT',#{none => 0,warning => 2,regulatory => 1,maintenance => 3,motoristService => 4,guide => 5,rec => 6}};
typeinfo('NodeAttributeLL') ->
  {'ENUMERATED_EXT',#{reserved => 0,stopLine => 1,roundedCapStyleA => 2,roundedCapStyleB => 3,mergePoint => 4,divergePoint => 5,downstreamStopLine => 6,downstreamStartNode => 7,closedToTraffic => 8,safeIsland => 9,curbPresentAtStepOff => 10,hydrantPresent => 11}};
typeinfo('OffsetLL-B12') ->
  {'INTEGER',{-2048,2047}};
typeinfo('OffsetLL-B14') ->
  {'INTEGER',{-8192,8191}};
typeinfo('OffsetLL-B16') ->
  {'INTEGER',{-32768,32767}};
typeinfo('OffsetLL-B22') ->
  {'INTEGER',{-2097152,2097151}};
typeinfo('OffsetLL-B24') ->
  {'INTEGER',{-8388608,8388607}};
typeinfo('Radius-B12') ->
  {'INTEGER',{0,4095}};
typeinfo('SegmentAttributeLL') ->
  {'ENUMERATED_EXT',#{sharedBikeLane => 15,audibleSignalingPresent => 24,transitStopOnLeft => 17,safeIsland => 21,unEvenPavementPresent => 37,bikeBoxInFront => 16,taperToCenterLine => 30,transitStopOnRight => 18,sharedWithTrackedVehicle => 20,partialCurbIntrusion => 27,adjacentParkingOnLeft => 11,mergingLaneRight => 4,turnOutPointOnRight => 10,curbOnLeft => 5,turnOutPointOnLeft => 9,loadingzoneOnLeft => 7,doNotBlock => 1,taperToRight => 29,loadingzoneOnRight => 8,transitStopInLane => 19,timeRestrictionsOnParking => 34,adjacentBikeLaneOnLeft => 13,freeParking => 33,parallelParking => 31,rfSignalRequestPresent => 26,adaptiveTimingPresent => 25,whiteLine => 2,taperToLeft => 28,reserved => 0,rumbleStripPresent => 23,adjacentParkingOnRight => 12,mergingLaneLeft => 3,headInParking => 32,costToPark => 35,adjacentBikeLaneOnRight => 14,curbOnRight => 6,midBlockCurbPresent => 36,lowCurbsPresent => 22}};
typeinfo('SignPriority') ->
  {'INTEGER',{0,7}};
typeinfo('TravelerInfoType') ->
  {'ENUMERATED_EXT',#{unknown => 0,advisory => 1,roadSignage => 2,commercialSignage => 3}};
typeinfo('UniqueMSGID') ->
  octet_string;
typeinfo('URL-Base') ->
  string;
typeinfo('URL-Short') ->
  string;
typeinfo('Zoom') ->
  {'INTEGER',{0,15}};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

bit_string_name2pos_4(['from000-0to022-5degrees' | T]) ->
    [0 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from022-5to045-0degrees' | T]) ->
    [1 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from045-0to067-5degrees' | T]) ->
    [2 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from067-5to090-0degrees' | T]) ->
    [3 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from090-0to112-5degrees' | T]) ->
    [4 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from112-5to135-0degrees' | T]) ->
    [5 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from135-0to157-5degrees' | T]) ->
    [6 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from157-5to180-0degrees' | T]) ->
    [7 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from180-0to202-5degrees' | T]) ->
    [8 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from202-5to225-0degrees' | T]) ->
    [9 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from225-0to247-5degrees' | T]) ->
    [10 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from247-5to270-0degrees' | T]) ->
    [11 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from270-0to292-5degrees' | T]) ->
    [12 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from292-5to315-0degrees' | T]) ->
    [13 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from315-0to337-5degrees' | T]) ->
    [14 | bit_string_name2pos_4(T)];
bit_string_name2pos_4(['from337-5to360-0degrees' | T]) ->
    [15 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_4(T)];
bit_string_name2pos_4([]) ->
    [];
bit_string_name2pos_4(_) ->
    throw(invalid).

dec_components10(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components10(Num, Bytes, Acc) ->
{Term,Remain} = dec_WorkZone_SEQOF(Bytes),
dec_components10(Num-1, Remain, [Term|Acc]).

dec_components11(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components11(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> reserved;
1 -> stopLine;
2 -> roundedCapStyleA;
3 -> roundedCapStyleB;
4 -> mergePoint;
5 -> divergePoint;
6 -> downstreamStopLine;
7 -> downstreamStartNode;
8 -> closedToTraffic;
9 -> safeIsland;
10 -> curbPresentAtStepOff;
11 -> hydrantPresent;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end,
dec_components11(Num-1, Remain, [Term|Acc]).

dec_components12(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components12(Num, Bytes, Acc) ->
{Term,Remain} = dec_NodeAttributeSetLL_regional_RegionalExtension(Bytes),
dec_components12(Num-1, Remain, [Term|Acc]).

dec_components13(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components13(Num, Bytes, Acc) ->
{Term,Remain} = dec_NodeLL(Bytes),
dec_components13(Num-1, Remain, [Term|Acc]).

dec_components14(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components14(Num, Bytes, Acc) ->
{Term,Remain} = dec_RegionOffsets(Bytes),
dec_components14(Num-1, Remain, [Term|Acc]).

dec_components15(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components15(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V2@V0,V2@Buf1} = case Bytes of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> reserved;
1 -> doNotBlock;
2 -> whiteLine;
3 -> mergingLaneLeft;
4 -> mergingLaneRight;
5 -> curbOnLeft;
6 -> curbOnRight;
7 -> loadingzoneOnLeft;
8 -> loadingzoneOnRight;
9 -> turnOutPointOnLeft;
10 -> turnOutPointOnRight;
11 -> adjacentParkingOnLeft;
12 -> adjacentParkingOnRight;
13 -> adjacentBikeLaneOnLeft;
14 -> adjacentBikeLaneOnRight;
15 -> sharedBikeLane;
16 -> bikeBoxInFront;
17 -> transitStopOnLeft;
18 -> transitStopOnRight;
19 -> transitStopInLane;
20 -> sharedWithTrackedVehicle;
21 -> safeIsland;
22 -> lowCurbsPresent;
23 -> rumbleStripPresent;
24 -> audibleSignalingPresent;
25 -> adaptiveTimingPresent;
26 -> rfSignalRequestPresent;
27 -> partialCurbIntrusion;
28 -> taperToLeft;
29 -> taperToRight;
30 -> taperToCenterLine;
31 -> parallelParking;
32 -> headInParking;
33 -> freeParking;
34 -> timeRestrictionsOnParking;
35 -> costToPark;
36 -> midBlockCurbPresent;
37 -> unEvenPavementPresent;
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11};
<<1:1,1:1,V2@V10:6,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
V2@Mul12 = V2@V10 * 16384,
{V2@Mul12,V2@Buf11}
end,
<<V2@V13:V2@V6/unit:8,V2@Buf14/bitstring>> = V2@Buf7,
{V2@V13,V2@Buf14}
end,
V2@Int15 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int15,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end,
dec_components15(Num-1, Remain, [Term|Acc]).

dec_components16(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components16(Num, Bytes, Acc) ->
{Term,Remain} = dec_TravelerDataFrame(Bytes),
dec_components16(Num-1, Remain, [Term|Acc]).

dec_components17(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components17(Num, Bytes, Acc) ->
{Term,Remain} = dec_GeographicalPath(Bytes),
dec_components17(Num-1, Remain, [Term|Acc]).

dec_components2(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components2(Num, Bytes, Acc) ->
{Term,Remain} = dec_TravelerInformation_regional_RegionalExtension(Bytes),
dec_components2(Num-1, Remain, [Term|Acc]).

dec_components5(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components5(Num, Bytes, Acc) ->
{Term,Remain} = dec_GeographicalPath_regional_RegionalExtension(Bytes),
dec_components5(Num-1, Remain, [Term|Acc]).

dec_components6(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components6(Num, Bytes, Acc) ->
{Term,Remain} = dec_GeometricProjection_regional_RegionalExtension(Bytes),
dec_components6(Num-1, Remain, [Term|Acc]).

dec_components7(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components7(Num, Bytes, Acc) ->
{Term,Remain} = dec_ExitService_SEQOF(Bytes),
dec_components7(Num-1, Remain, [Term|Acc]).

dec_components8(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components8(Num, Bytes, Acc) ->
{Term,Remain} = dec_GenericSignage_SEQOF(Bytes),
dec_components8(Num-1, Remain, [Term|Acc]).

dec_components9(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components9(Num, Bytes, Acc) ->
{Term,Remain} = dec_SpeedLimit_SEQOF(Bytes),
dec_components9(Num-1, Remain, [Term|Acc]).

dec_os_Type3(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


enc_os_Type1(Val, Id) ->
open_type_to_binary(Val).

adjust_trailing_zeroes(Bs0, Lb) ->
    case bit_size(Bs0) of
        Sz when Sz < Lb ->
            <<Bs0:Sz/bits,0:(Lb - Sz)>>;
        Lb ->
            Bs0;
        _ ->
            <<_:Lb/bits,Tail/bits>> = Bs0,
            Sz = Lb + bit_size(bs_drop_trailing_zeroes(Tail)),
            <<Bs:Sz/bits,_/bits>> = Bs0,
            Bs
    end.

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

bitstring_from_positions(L0, Lb) ->
    L1 = lists:sort(L0),
    L = diff(L1, -1, Lb - 1),
    << 
      <<B:(N + 0)>> ||
          {B, N} <- L
    >>.

bs_drop_trailing_zeroes(Bs) ->
    bs_drop_trailing_zeroes(Bs, bit_size(Bs)).

bs_drop_trailing_zeroes(Bs, 0) ->
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) when Sz0 < 8 ->
    <<Byte:Sz0>> = Bs0,
    Sz = Sz0 - ntz(Byte),
    <<Bs:Sz/bits,_/bits>> = Bs0,
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) ->
    Sz1 = Sz0 - 8,
    <<Bs1:Sz1/bits,Byte:8>> = Bs0,
    case ntz(Byte) of
        8 ->
            bs_drop_trailing_zeroes(Bs1, Sz1);
        Ntz ->
            Sz = Sz0 - Ntz,
            <<Bs:Sz/bits,_:Ntz/bits>> = Bs0,
            Bs
    end.

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_chars(Val, N) ->
    [ 
     C ||
         <<C:N>> <= Val
    ].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

decode_named_bit_string(Val, NNL) ->
    Bits =
        [ 
         B ||
             <<B:1>> <= Val
        ],
    decode_named_bit_string_1(0, Bits, NNL, []).

decode_named_bit_string_1(Pos, [0 | Bt], Names, Acc) ->
    decode_named_bit_string_1(Pos + 1, Bt, Names, Acc);
decode_named_bit_string_1(Pos, [1 | Bt], Names, Acc) ->
    case lists:keyfind(Pos, 2, Names) of
        {Name, _} ->
            decode_named_bit_string_1(Pos + 1, Bt, Names, [Name | Acc]);
        false ->
            decode_named_bit_string_1(Pos + 1,
                                      Bt, Names,
                                      [{bit, Pos} | Acc])
    end;
decode_named_bit_string_1(_Pos, [], _Names, Acc) ->
    lists:reverse(Acc).

diff([H | T], Prev, Last) ->
    [{1, H - Prev} | diff(T, H, Last)];
diff([], Prev, Last) when Last >= Prev ->
    [{0, Last - Prev}];
diff([], _, _) ->
    [].

encode_chars(Val, NumBits) ->
    << 
      <<C:NumBits>> ||
          C <- Val
    >>.

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

extension_bitmap(Val, Pos, Limit) ->
    extension_bitmap(Val, Pos, Limit, 0).

extension_bitmap(_Val, Pos, Limit, Acc) when Pos >= Limit ->
    Acc;
extension_bitmap(Val, Pos, Limit, Acc) ->
    Bit =
        case element(Pos, Val) of
            asn1_NOVALUE ->
                0;
            asn1_DEFAULT ->
                0;
            _ ->
                1
        end,
    extension_bitmap(Val, Pos + 1, Limit, Acc bsl 1 bor Bit).

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

ntz(Byte) ->
    T = {8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2,
         0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0,
         1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1,
         0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
         2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3,
         0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
         1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1,
         0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
         3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
         0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0,
         1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1,
         0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
         2, 0, 1, 0},
    element(Byte + 1, T).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

open_type_to_binary({asn1_OPENTYPE, Bin}) when is_binary(Bin) ->
    Bin.

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
