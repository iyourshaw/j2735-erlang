%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in RoadWeatherMessage.

-module('RoadWeatherMessage').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("RoadWeatherMessage.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'RoadWeatherMessage'},
            {options,[{i,"./ebin"},uper,jer,verbose,{i,"./asn"},{outdir,"./ebin"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_RoadWeatherMessage/1,
enc_RoadWeatherUpload/1,
enc_VehicleReport/1,
enc_RoadWeatherDownload/1,
enc_WDMSFleetData/1,
enc_NtcipPavementTreatment/1,
enc_NTCIPEssPavementTreatmentLatitude/1,
enc_NTCIPEssPavementTreatmentLongitude/1,
enc_NTCIPEssPavementTreatmentLocation/1,
enc_NTCIPEssPaveTreatProductType/1,
enc_NTCIPEssPaveTreatProductForm/1,
enc_NTCIPEssPercentProductMix/1,
enc_NTCIPEssPaveTreatmentAmount/1,
enc_NTCIPEssPaveTreatmentWidth/1,
enc_SnapShot/1,
enc_NtcipEssData/1,
enc_NtcipAirTemperature/1,
enc_NTCIPEssAirTemperature/1,
enc_NTCIPEssTemperatureSensorHeight/1,
enc_NtcipAtmosphericPressure/1,
enc_NTCIPEssPressureSensorAtmosphericPressure/1,
enc_NtcipWind/1,
enc_NTCIPWindSensorAvgSpeed/1,
enc_NTCIPWindSensorAvgDirection/1,
enc_NTCIPWindSensorSpotSpeed/1,
enc_NTCIPWindSensorSpotDirection/1,
enc_NTCIPWindSensorGustSpeed/1,
enc_NTCIPWindSensorGustDirection/1,
enc_NtcipRelativeHumidity/1,
enc_NTCIPHumiditySensorRelativeHumidity/1,
enc_NtcipDewPoint/1,
enc_NTCIPEssDewpointTemp/1,
enc_NtcipPavement/1,
enc_NTCIPEssSurfaceTemperature/1,
enc_NTCIPPavementSensorSurfaceCondition/1,
enc_NTCIPEssSurfaceIceOrWaterDepth/1,
enc_NtcipVisibility/1,
enc_NTCIPEssVisibility/1,
enc_NtcipVisibilitySituation/1,
enc_NTCIPEssVisibilitySituation/1,
enc_NtcipCloudSituation/1,
enc_NTCIPEssCloudSituationV4/1,
enc_NtcipPrecipitation/1,
enc_NTCIPPrecipitationSensorPrecipSituation/1,
enc_NtcipSolarRadiation/1,
enc_NTCIPEssTotalRadiationV4/1,
enc_NTCIPEssTotalRadiationPeriod/1,
enc_TemperatureMeasurementStdDev/1,
enc_AtmosPressureMeasurementStdDev/1,
enc_DewPointTempMeasurementStdDev/1,
enc_SurfaceTempMeasurementStdDev/1,
enc_DataSourceInfo/1
]).

-export([
dec_RoadWeatherMessage/1,
dec_RoadWeatherUpload/1,
dec_VehicleReport/1,
dec_RoadWeatherDownload/1,
dec_WDMSFleetData/1,
dec_NtcipPavementTreatment/1,
dec_NTCIPEssPavementTreatmentLatitude/1,
dec_NTCIPEssPavementTreatmentLongitude/1,
dec_NTCIPEssPavementTreatmentLocation/1,
dec_NTCIPEssPaveTreatProductType/1,
dec_NTCIPEssPaveTreatProductForm/1,
dec_NTCIPEssPercentProductMix/1,
dec_NTCIPEssPaveTreatmentAmount/1,
dec_NTCIPEssPaveTreatmentWidth/1,
dec_SnapShot/1,
dec_NtcipEssData/1,
dec_NtcipAirTemperature/1,
dec_NTCIPEssAirTemperature/1,
dec_NTCIPEssTemperatureSensorHeight/1,
dec_NtcipAtmosphericPressure/1,
dec_NTCIPEssPressureSensorAtmosphericPressure/1,
dec_NtcipWind/1,
dec_NTCIPWindSensorAvgSpeed/1,
dec_NTCIPWindSensorAvgDirection/1,
dec_NTCIPWindSensorSpotSpeed/1,
dec_NTCIPWindSensorSpotDirection/1,
dec_NTCIPWindSensorGustSpeed/1,
dec_NTCIPWindSensorGustDirection/1,
dec_NtcipRelativeHumidity/1,
dec_NTCIPHumiditySensorRelativeHumidity/1,
dec_NtcipDewPoint/1,
dec_NTCIPEssDewpointTemp/1,
dec_NtcipPavement/1,
dec_NTCIPEssSurfaceTemperature/1,
dec_NTCIPPavementSensorSurfaceCondition/1,
dec_NTCIPEssSurfaceIceOrWaterDepth/1,
dec_NtcipVisibility/1,
dec_NTCIPEssVisibility/1,
dec_NtcipVisibilitySituation/1,
dec_NTCIPEssVisibilitySituation/1,
dec_NtcipCloudSituation/1,
dec_NTCIPEssCloudSituationV4/1,
dec_NtcipPrecipitation/1,
dec_NTCIPPrecipitationSensorPrecipSituation/1,
dec_NtcipSolarRadiation/1,
dec_NTCIPEssTotalRadiationV4/1,
dec_NTCIPEssTotalRadiationPeriod/1,
dec_TemperatureMeasurementStdDev/1,
dec_AtmosPressureMeasurementStdDev/1,
dec_DewPointTempMeasurementStdDev/1,
dec_SurfaceTempMeasurementStdDev/1,
dec_DataSourceInfo/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('RoadWeatherMessage', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('RoadWeatherMessage', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('RoadWeatherMessage', Data) -> enc_RoadWeatherMessage(Data);
encode_disp('RoadWeatherUpload', Data) -> enc_RoadWeatherUpload(Data);
encode_disp('VehicleReport', Data) -> enc_VehicleReport(Data);
encode_disp('RoadWeatherDownload', Data) -> enc_RoadWeatherDownload(Data);
encode_disp('WDMSFleetData', Data) -> enc_WDMSFleetData(Data);
encode_disp('NtcipPavementTreatment', Data) -> enc_NtcipPavementTreatment(Data);
encode_disp('NTCIPEssPavementTreatmentLatitude', Data) -> enc_NTCIPEssPavementTreatmentLatitude(Data);
encode_disp('NTCIPEssPavementTreatmentLongitude', Data) -> enc_NTCIPEssPavementTreatmentLongitude(Data);
encode_disp('NTCIPEssPavementTreatmentLocation', Data) -> enc_NTCIPEssPavementTreatmentLocation(Data);
encode_disp('NTCIPEssPaveTreatProductType', Data) -> enc_NTCIPEssPaveTreatProductType(Data);
encode_disp('NTCIPEssPaveTreatProductForm', Data) -> enc_NTCIPEssPaveTreatProductForm(Data);
encode_disp('NTCIPEssPercentProductMix', Data) -> enc_NTCIPEssPercentProductMix(Data);
encode_disp('NTCIPEssPaveTreatmentAmount', Data) -> enc_NTCIPEssPaveTreatmentAmount(Data);
encode_disp('NTCIPEssPaveTreatmentWidth', Data) -> enc_NTCIPEssPaveTreatmentWidth(Data);
encode_disp('SnapShot', Data) -> enc_SnapShot(Data);
encode_disp('NtcipEssData', Data) -> enc_NtcipEssData(Data);
encode_disp('NtcipAirTemperature', Data) -> enc_NtcipAirTemperature(Data);
encode_disp('NTCIPEssAirTemperature', Data) -> enc_NTCIPEssAirTemperature(Data);
encode_disp('NTCIPEssTemperatureSensorHeight', Data) -> enc_NTCIPEssTemperatureSensorHeight(Data);
encode_disp('NtcipAtmosphericPressure', Data) -> enc_NtcipAtmosphericPressure(Data);
encode_disp('NTCIPEssPressureSensorAtmosphericPressure', Data) -> enc_NTCIPEssPressureSensorAtmosphericPressure(Data);
encode_disp('NtcipWind', Data) -> enc_NtcipWind(Data);
encode_disp('NTCIPWindSensorAvgSpeed', Data) -> enc_NTCIPWindSensorAvgSpeed(Data);
encode_disp('NTCIPWindSensorAvgDirection', Data) -> enc_NTCIPWindSensorAvgDirection(Data);
encode_disp('NTCIPWindSensorSpotSpeed', Data) -> enc_NTCIPWindSensorSpotSpeed(Data);
encode_disp('NTCIPWindSensorSpotDirection', Data) -> enc_NTCIPWindSensorSpotDirection(Data);
encode_disp('NTCIPWindSensorGustSpeed', Data) -> enc_NTCIPWindSensorGustSpeed(Data);
encode_disp('NTCIPWindSensorGustDirection', Data) -> enc_NTCIPWindSensorGustDirection(Data);
encode_disp('NtcipRelativeHumidity', Data) -> enc_NtcipRelativeHumidity(Data);
encode_disp('NTCIPHumiditySensorRelativeHumidity', Data) -> enc_NTCIPHumiditySensorRelativeHumidity(Data);
encode_disp('NtcipDewPoint', Data) -> enc_NtcipDewPoint(Data);
encode_disp('NTCIPEssDewpointTemp', Data) -> enc_NTCIPEssDewpointTemp(Data);
encode_disp('NtcipPavement', Data) -> enc_NtcipPavement(Data);
encode_disp('NTCIPEssSurfaceTemperature', Data) -> enc_NTCIPEssSurfaceTemperature(Data);
encode_disp('NTCIPPavementSensorSurfaceCondition', Data) -> enc_NTCIPPavementSensorSurfaceCondition(Data);
encode_disp('NTCIPEssSurfaceIceOrWaterDepth', Data) -> enc_NTCIPEssSurfaceIceOrWaterDepth(Data);
encode_disp('NtcipVisibility', Data) -> enc_NtcipVisibility(Data);
encode_disp('NTCIPEssVisibility', Data) -> enc_NTCIPEssVisibility(Data);
encode_disp('NtcipVisibilitySituation', Data) -> enc_NtcipVisibilitySituation(Data);
encode_disp('NTCIPEssVisibilitySituation', Data) -> enc_NTCIPEssVisibilitySituation(Data);
encode_disp('NtcipCloudSituation', Data) -> enc_NtcipCloudSituation(Data);
encode_disp('NTCIPEssCloudSituationV4', Data) -> enc_NTCIPEssCloudSituationV4(Data);
encode_disp('NtcipPrecipitation', Data) -> enc_NtcipPrecipitation(Data);
encode_disp('NTCIPPrecipitationSensorPrecipSituation', Data) -> enc_NTCIPPrecipitationSensorPrecipSituation(Data);
encode_disp('NtcipSolarRadiation', Data) -> enc_NtcipSolarRadiation(Data);
encode_disp('NTCIPEssTotalRadiationV4', Data) -> enc_NTCIPEssTotalRadiationV4(Data);
encode_disp('NTCIPEssTotalRadiationPeriod', Data) -> enc_NTCIPEssTotalRadiationPeriod(Data);
encode_disp('TemperatureMeasurementStdDev', Data) -> enc_TemperatureMeasurementStdDev(Data);
encode_disp('AtmosPressureMeasurementStdDev', Data) -> enc_AtmosPressureMeasurementStdDev(Data);
encode_disp('DewPointTempMeasurementStdDev', Data) -> enc_DewPointTempMeasurementStdDev(Data);
encode_disp('SurfaceTempMeasurementStdDev', Data) -> enc_SurfaceTempMeasurementStdDev(Data);
encode_disp('DataSourceInfo', Data) -> enc_DataSourceInfo(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('RoadWeatherMessage', Data) -> dec_RoadWeatherMessage(Data);
decode_disp('RoadWeatherUpload', Data) -> dec_RoadWeatherUpload(Data);
decode_disp('VehicleReport', Data) -> dec_VehicleReport(Data);
decode_disp('RoadWeatherDownload', Data) -> dec_RoadWeatherDownload(Data);
decode_disp('WDMSFleetData', Data) -> dec_WDMSFleetData(Data);
decode_disp('NtcipPavementTreatment', Data) -> dec_NtcipPavementTreatment(Data);
decode_disp('NTCIPEssPavementTreatmentLatitude', Data) -> dec_NTCIPEssPavementTreatmentLatitude(Data);
decode_disp('NTCIPEssPavementTreatmentLongitude', Data) -> dec_NTCIPEssPavementTreatmentLongitude(Data);
decode_disp('NTCIPEssPavementTreatmentLocation', Data) -> dec_NTCIPEssPavementTreatmentLocation(Data);
decode_disp('NTCIPEssPaveTreatProductType', Data) -> dec_NTCIPEssPaveTreatProductType(Data);
decode_disp('NTCIPEssPaveTreatProductForm', Data) -> dec_NTCIPEssPaveTreatProductForm(Data);
decode_disp('NTCIPEssPercentProductMix', Data) -> dec_NTCIPEssPercentProductMix(Data);
decode_disp('NTCIPEssPaveTreatmentAmount', Data) -> dec_NTCIPEssPaveTreatmentAmount(Data);
decode_disp('NTCIPEssPaveTreatmentWidth', Data) -> dec_NTCIPEssPaveTreatmentWidth(Data);
decode_disp('SnapShot', Data) -> dec_SnapShot(Data);
decode_disp('NtcipEssData', Data) -> dec_NtcipEssData(Data);
decode_disp('NtcipAirTemperature', Data) -> dec_NtcipAirTemperature(Data);
decode_disp('NTCIPEssAirTemperature', Data) -> dec_NTCIPEssAirTemperature(Data);
decode_disp('NTCIPEssTemperatureSensorHeight', Data) -> dec_NTCIPEssTemperatureSensorHeight(Data);
decode_disp('NtcipAtmosphericPressure', Data) -> dec_NtcipAtmosphericPressure(Data);
decode_disp('NTCIPEssPressureSensorAtmosphericPressure', Data) -> dec_NTCIPEssPressureSensorAtmosphericPressure(Data);
decode_disp('NtcipWind', Data) -> dec_NtcipWind(Data);
decode_disp('NTCIPWindSensorAvgSpeed', Data) -> dec_NTCIPWindSensorAvgSpeed(Data);
decode_disp('NTCIPWindSensorAvgDirection', Data) -> dec_NTCIPWindSensorAvgDirection(Data);
decode_disp('NTCIPWindSensorSpotSpeed', Data) -> dec_NTCIPWindSensorSpotSpeed(Data);
decode_disp('NTCIPWindSensorSpotDirection', Data) -> dec_NTCIPWindSensorSpotDirection(Data);
decode_disp('NTCIPWindSensorGustSpeed', Data) -> dec_NTCIPWindSensorGustSpeed(Data);
decode_disp('NTCIPWindSensorGustDirection', Data) -> dec_NTCIPWindSensorGustDirection(Data);
decode_disp('NtcipRelativeHumidity', Data) -> dec_NtcipRelativeHumidity(Data);
decode_disp('NTCIPHumiditySensorRelativeHumidity', Data) -> dec_NTCIPHumiditySensorRelativeHumidity(Data);
decode_disp('NtcipDewPoint', Data) -> dec_NtcipDewPoint(Data);
decode_disp('NTCIPEssDewpointTemp', Data) -> dec_NTCIPEssDewpointTemp(Data);
decode_disp('NtcipPavement', Data) -> dec_NtcipPavement(Data);
decode_disp('NTCIPEssSurfaceTemperature', Data) -> dec_NTCIPEssSurfaceTemperature(Data);
decode_disp('NTCIPPavementSensorSurfaceCondition', Data) -> dec_NTCIPPavementSensorSurfaceCondition(Data);
decode_disp('NTCIPEssSurfaceIceOrWaterDepth', Data) -> dec_NTCIPEssSurfaceIceOrWaterDepth(Data);
decode_disp('NtcipVisibility', Data) -> dec_NtcipVisibility(Data);
decode_disp('NTCIPEssVisibility', Data) -> dec_NTCIPEssVisibility(Data);
decode_disp('NtcipVisibilitySituation', Data) -> dec_NtcipVisibilitySituation(Data);
decode_disp('NTCIPEssVisibilitySituation', Data) -> dec_NTCIPEssVisibilitySituation(Data);
decode_disp('NtcipCloudSituation', Data) -> dec_NtcipCloudSituation(Data);
decode_disp('NTCIPEssCloudSituationV4', Data) -> dec_NTCIPEssCloudSituationV4(Data);
decode_disp('NtcipPrecipitation', Data) -> dec_NtcipPrecipitation(Data);
decode_disp('NTCIPPrecipitationSensorPrecipSituation', Data) -> dec_NTCIPPrecipitationSensorPrecipSituation(Data);
decode_disp('NtcipSolarRadiation', Data) -> dec_NtcipSolarRadiation(Data);
decode_disp('NTCIPEssTotalRadiationV4', Data) -> dec_NTCIPEssTotalRadiationV4(Data);
decode_disp('NTCIPEssTotalRadiationPeriod', Data) -> dec_NTCIPEssTotalRadiationPeriod(Data);
decode_disp('TemperatureMeasurementStdDev', Data) -> dec_TemperatureMeasurementStdDev(Data);
decode_disp('AtmosPressureMeasurementStdDev', Data) -> dec_AtmosPressureMeasurementStdDev(Data);
decode_disp('DewPointTempMeasurementStdDev', Data) -> dec_DewPointTempMeasurementStdDev(Data);
decode_disp('SurfaceTempMeasurementStdDev', Data) -> dec_SurfaceTempMeasurementStdDev(Data);
decode_disp('DataSourceInfo', Data) -> dec_DataSourceInfo(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_RoadWeatherMessage(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= upload ->
[<<0:1,0:1>>|enc_RoadWeatherUpload(ChoiceVal)];
ChoiceTag =:= download ->
[<<0:1,1:1>>|enc_RoadWeatherDownload(ChoiceVal)]
end.


dec_RoadWeatherMessage(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_RoadWeatherUpload(Bytes2)
end,
{{upload,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_RoadWeatherDownload(Bytes2)
end,
{{download,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_RoadWeatherUpload(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= vehicleReport ->
[<<0:1,0:1>>|enc_RoadWeatherUpload_vehicleReport(ChoiceVal)];
ChoiceTag =:= citizenReport ->
[<<0:1,1:1>>|enc_SnapShot(ChoiceVal)]
end.
enc_RoadWeatherUpload_vehicleReport(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_VehicleReport(Comp) || Comp <- Val]]
end.



dec_RoadWeatherUpload(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_RoadWeatherUpload_vehicleReport(Bytes2)
end,
{{vehicleReport,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_SnapShot(Bytes2)
end,
{{citizenReport,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.

dec_RoadWeatherUpload_vehicleReport(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components1(V1@Add2, V1@Buf1, []).

enc_VehicleReport(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute snapShot(1) with type SnapShot
Enc3@element = element(2, Val),
enc_SnapShot(Enc3@element)
end|begin
%% attribute wdmsFleetData(2) with type WDMSFleetData
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
enc_WDMSFleetData(Enc4@element)
end
end].


dec_VehicleReport(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute snapShot(1) with type SnapShot
{Term1,Bytes3} = dec_SnapShot(Bytes2),

%% attribute wdmsFleetData(2) with type WDMSFleetData
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_WDMSFleetData(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'VehicleReport',Term1,Term2},
{Res1,Bytes6}.

enc_RoadWeatherDownload(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute travelerData(1) with type TravelerDataFrameList
Enc3@element = element(2, Val),
'TravelerInformation':enc_TravelerDataFrameList(Enc3@element)
end|begin
%% attribute wdmsFleetData(2) with type WDMSFleetData
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
enc_WDMSFleetData(Enc4@element)
end
end].


dec_RoadWeatherDownload(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute travelerData(1) with type TravelerDataFrameList
{Term1,Bytes3} = 'TravelerInformation':dec_TravelerDataFrameList(Bytes2),

%% attribute wdmsFleetData(2) with type WDMSFleetData
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_WDMSFleetData(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'RoadWeatherDownload',Term1,Term2},
{Res1,Bytes6}.

enc_WDMSFleetData(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute pavementTreat(1) with type NtcipPavementTreatment
Enc4@element = element(2, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipPavementTreatment(Enc4@element)
end
end|begin
%% attribute routingAdvice(2) with type IA5String
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc7@len = length(Enc6@element),
Enc7@bin = encode_chars(Enc6@element, 7),
Enc7@len@sub = Enc7@len - 1,
if 0 =< Enc7@len@sub, Enc7@len@sub < 500 ->
[<<Enc7@len@sub:9>>|Enc7@bin]
end
end
end
end].


dec_WDMSFleetData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute pavementTreat(1) with type NtcipPavementTreatment
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_NtcipPavementTreatment(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute routingAdvice(2) with type IA5String
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V3@V0:9,V3@Buf1/bitstring>> = Bytes3,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V4@V0,V4@Buf1} = case Bytes4 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'WDMSFleetData',Term1,Term2},
{Res1,Bytes6}.

enc_NtcipPavementTreatment(Val) ->
[begin
Enc1@element = element(5, Val),
Enc2@element = element(6, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(7, Val),
Enc4@element = element(8, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(9, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute latitude(1) with type INTEGER
Enc7@element = element(2, Val),
Enc7@element@sub = Enc7@element - -90000000,
if 0 =< Enc7@element@sub, Enc7@element@sub < 180000002 ->
<<Enc7@element@sub:28>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end,
begin
%% attribute longitude(2) with type INTEGER
Enc9@element = element(3, Val),
Enc9@element@sub = Enc9@element - -180000000,
if 0 =< Enc9@element@sub, Enc9@element@sub < 360000002 ->
<<Enc9@element@sub:29>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end,
begin
%% attribute location(3) with type IA5String
Enc11@element = element(4, Val),
Enc12@len = length(Enc11@element),
Enc12@bin = encode_chars(Enc11@element, 7),
Enc12@len@sub = Enc12@len - 1,
if 0 =< Enc12@len@sub, Enc12@len@sub < 255 ->
[Enc12@len@sub|Enc12@bin]
end
end,
begin
%% attribute productType(4) with type ENUMERATED
Enc13@element = element(5, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
Enc13@element =:= other ->
<<0:1,0:4>>;
Enc13@element =:= sand ->
<<0:1,1:4>>;
Enc13@element =:= dirt ->
<<0:1,2:4>>;
Enc13@element =:= gravel ->
<<0:1,3:4>>;
Enc13@element =:= cinders ->
<<0:1,4:4>>;
Enc13@element =:= water ->
<<0:1,5:4>>;
Enc13@element =:= enhancedSalts ->
<<0:1,6:4>>;
Enc13@element =:= naCl ->
<<0:1,7:4>>;
Enc13@element =:= caCl ->
<<0:1,8:4>>;
Enc13@element =:= mgCl ->
<<0:1,9:4>>;
Enc13@element =:= cMA ->
<<0:1,10:4>>;
Enc13@element =:= kAC ->
<<0:1,11:4>>;
Enc13@element =:= naFormate ->
<<0:1,12:4>>;
Enc13@element =:= naA ->
<<0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc13@element}}})
end
end,
begin
%% attribute form(5) with type ENUMERATED
Enc16@element = element(6, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
Enc16@element =:= other ->
<<0:1,0:2>>;
Enc16@element =:= dry ->
<<0:1,1:2>>;
Enc16@element =:= prewet ->
<<0:1,2:2>>;
Enc16@element =:= liquid ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc16@element}}})
end
end,
begin
%% attribute percentage(6) with type INTEGER
Enc19@element = element(7, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
0 =< Enc19@element, Enc19@element < 101 ->
<<Enc19@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc19@element}}})
end
end,
begin
%% attribute amount(7) with type INTEGER
Enc22@element = element(8, Val),
if Enc22@element =:= asn1_NOVALUE ->
[];
Enc22@element bsr 8 =:= 0 ->
Enc22@element;
true ->
exit({error,{asn1,{illegal_integer,Enc22@element}}})
end
end|begin
%% attribute width(8) with type INTEGER
Enc25@element = element(9, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
Enc25@element bsr 8 =:= 0 ->
[Enc25@element];
true ->
exit({error,{asn1,{illegal_integer,Enc25@element}}})
end
end].


dec_NtcipPavementTreatment(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute latitude(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:28,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -90000000,
{V3@Add2,V3@Buf1}
end,

%% attribute longitude(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:29,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -180000000,
{V4@Add2,V4@Buf1}
end,

%% attribute location(3) with type IA5String
{Term3,Bytes5} = begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
<<V5@V3:V5@Add2/binary-unit:7,V5@Buf4/bitstring>> = V5@Buf1,
{V5@V5,V5@Buf6}  = {decode_chars(V5@V3, 7),V5@Buf4},
{V5@V5,V5@Buf6}
end,

%% attribute productType(4) with type ENUMERATED
{Term4,Bytes6} = case (Opt bsr 4) band 1 of
1 ->
begin
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:4,V6@Buf4/bitstring>> ->
V6@Int5 = case V6@V3 of
0 -> other;
1 -> sand;
2 -> dirt;
3 -> gravel;
4 -> cinders;
5 -> water;
6 -> enhancedSalts;
7 -> naCl;
8 -> caCl;
9 -> mgCl;
10 -> cMA;
11 -> kAC;
12 -> naFormate;
13 -> naA;
_ -> exit({error,{asn1,{decode_enumerated,V6@V3}}})
end,
{V6@Int5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:6,V6@Buf7/bitstring>> ->
{V6@V6,V6@Buf7};
<<1:1,V6@Buf5/bitstring>> ->
{V6@V6,V6@Buf7} = case V6@Buf5 of
<<0:1,V6@V9:7,V6@Buf10/bitstring>> when V6@V9 =/= 0 ->
{V6@V9,V6@Buf10};
<<1:1,0:1,V6@V10:14,V6@Buf11/bitstring>> when V6@V10 =/= 0 ->
{V6@V10,V6@Buf11};
<<1:1,1:1,V6@V10:6,V6@Buf11/bitstring>> when V6@V10 =/= 0 ->
V6@Mul12 = V6@V10 * 16384,
{V6@Mul12,V6@Buf11}
end,
<<V6@V13:V6@V6/unit:8,V6@Buf14/bitstring>> = V6@Buf7,
{V6@V13,V6@Buf14}
end,
V6@Int15 = case V6@V3 of
_ -> {asn1_enum,V6@V3}
end,
{V6@Int15,V6@Buf4}
end,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute form(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 3) band 1 of
1 ->
begin
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:2,V7@Buf4/bitstring>> ->
V7@Int5 = case V7@V3 of
0 -> other;
1 -> dry;
2 -> prewet;
3 -> liquid
end,
{V7@Int5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:6,V7@Buf7/bitstring>> ->
{V7@V6,V7@Buf7};
<<1:1,V7@Buf5/bitstring>> ->
{V7@V6,V7@Buf7} = case V7@Buf5 of
<<0:1,V7@V9:7,V7@Buf10/bitstring>> when V7@V9 =/= 0 ->
{V7@V9,V7@Buf10};
<<1:1,0:1,V7@V10:14,V7@Buf11/bitstring>> when V7@V10 =/= 0 ->
{V7@V10,V7@Buf11};
<<1:1,1:1,V7@V10:6,V7@Buf11/bitstring>> when V7@V10 =/= 0 ->
V7@Mul12 = V7@V10 * 16384,
{V7@Mul12,V7@Buf11}
end,
<<V7@V13:V7@V6/unit:8,V7@Buf14/bitstring>> = V7@Buf7,
{V7@V13,V7@Buf14}
end,
V7@Int15 = case V7@V3 of
_ -> {asn1_enum,V7@V3}
end,
{V7@Int15,V7@Buf4}
end,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute percentage(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V8@V0:7,V8@Buf1/bitstring>> = Bytes7,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute amount(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V9@V0:8,V9@Buf1/bitstring>> = Bytes8,
{V9@V0,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute width(8) with type INTEGER
{Term8,Bytes10} = case Opt band 1 of
1 ->
begin
<<V10@V0:8,V10@Buf1/bitstring>> = Bytes9,
{V10@V0,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% Extensions
{Extensions,Bytes11} = case Ext of
0 -> {<<>>,Bytes10};
1 ->
{V11@V0,V11@Buf1} = case Bytes10 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8};
<<1:1,1:1,V11@V7:6,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
V11@Mul9 = V11@V7 * 16384,
{V11@Mul9,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V10:V11@V0/bitstring-unit:1,V11@Buf11/bitstring>> = V11@Buf1,
{V11@V10,V11@Buf11}
end,
Bytes12= skipextensions(Bytes11, 1, Extensions),
Res1 = {'NtcipPavementTreatment',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8},
{Res1,Bytes12}.

enc_NTCIPEssPavementTreatmentLatitude(Val) ->
Val@sub = Val - -90000000,
if 0 =< Val@sub, Val@sub < 180000002 ->
<<Val@sub:28>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssPavementTreatmentLatitude(Bytes) ->
begin
<<V1@V0:28,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -90000000,
{V1@Add2,V1@Buf1}
end.

enc_NTCIPEssPavementTreatmentLongitude(Val) ->
Val@sub = Val - -180000000,
if 0 =< Val@sub, Val@sub < 360000002 ->
<<Val@sub:29>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssPavementTreatmentLongitude(Bytes) ->
begin
<<V1@V0:29,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -180000000,
{V1@Add2,V1@Buf1}
end.

enc_NTCIPEssPavementTreatmentLocation(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 255 ->
[Enc1@len@sub|Enc1@bin]
end.


dec_NTCIPEssPavementTreatmentLocation(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

enc_NTCIPEssPaveTreatProductType(Val) ->
if Val =:= other ->
<<0:1,0:4>>;
Val =:= sand ->
<<0:1,1:4>>;
Val =:= dirt ->
<<0:1,2:4>>;
Val =:= gravel ->
<<0:1,3:4>>;
Val =:= cinders ->
<<0:1,4:4>>;
Val =:= water ->
<<0:1,5:4>>;
Val =:= enhancedSalts ->
<<0:1,6:4>>;
Val =:= naCl ->
<<0:1,7:4>>;
Val =:= caCl ->
<<0:1,8:4>>;
Val =:= mgCl ->
<<0:1,9:4>>;
Val =:= cMA ->
<<0:1,10:4>>;
Val =:= kAC ->
<<0:1,11:4>>;
Val =:= naFormate ->
<<0:1,12:4>>;
Val =:= naA ->
<<0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NTCIPEssPaveTreatProductType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> other;
1 -> sand;
2 -> dirt;
3 -> gravel;
4 -> cinders;
5 -> water;
6 -> enhancedSalts;
7 -> naCl;
8 -> caCl;
9 -> mgCl;
10 -> cMA;
11 -> kAC;
12 -> naFormate;
13 -> naA;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NTCIPEssPaveTreatProductForm(Val) ->
if Val =:= other ->
<<0:1,0:2>>;
Val =:= dry ->
<<0:1,1:2>>;
Val =:= prewet ->
<<0:1,2:2>>;
Val =:= liquid ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NTCIPEssPaveTreatProductForm(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> other;
1 -> dry;
2 -> prewet;
3 -> liquid
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NTCIPEssPercentProductMix(Val) ->
if 0 =< Val, Val < 101 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssPercentProductMix(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NTCIPEssPaveTreatmentAmount(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssPaveTreatmentAmount(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NTCIPEssPaveTreatmentWidth(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssPaveTreatmentWidth(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SnapShot(Val) ->
Enc3@bitmap = extension_bitmap(Val, 5, 6),
Extensions = if Enc3@bitmap =:= 0 ->
[];
true ->
<<0:7,1:1>>
end,
[begin
Enc1@element = element(3, Val),
if Extensions =:= [] ->
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc1@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc2@element = element(4, Val),
if Enc2@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute thePosition(1) with type FullPositionVector
Enc5@element = element(2, Val),
'Common':enc_FullPositionVector(Enc5@element)
end,
begin
%% attribute safetyExt(2) with type VehicleSafetyExtensions
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_VehicleSafetyExtensions(Enc6@element)
end
end,
begin
%% attribute dataSet(3) with type VehicleStatus
Enc8@element = element(4, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
true ->
'ProbeVehicleData':enc_VehicleStatus(Enc8@element)
end
end,
Extensions|begin
%% attribute weatherData(4) with type NtcipEssData
Enc10@element = element(5, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc11@output = enc_NtcipEssData(Enc10@element),
Enc11@bin = complete(Enc11@output),
Enc11@len = byte_size(Enc11@bin),
if Enc11@len < 128 ->
[Enc11@len|Enc11@bin];
Enc11@len < 16384 ->
[<<2:2,Enc11@len:14>>|Enc11@bin];
true ->
encode_fragmented(Enc11@bin, 8)
end
end
end
end].


dec_SnapShot(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute thePosition(1) with type FullPositionVector
{Term1,Bytes3} = 'Common':dec_FullPositionVector(Bytes2),

%% attribute safetyExt(2) with type VehicleSafetyExtensions
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
'Common':dec_VehicleSafetyExtensions(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute dataSet(3) with type VehicleStatus
{Term3,Bytes5} = case Opt band 1 of
1 ->
'ProbeVehicleData':dec_VehicleStatus(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V3@V0,V3@Buf1} = case Bytes5 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,

%% attribute weatherData(4) with type NtcipEssData
{Term4,Bytes7} = case Extensions of
  <<_:0,1:1,_/bitstring>> ->
begin
{V4@V0,V4@Buf1} = case Bytes6 of
<<0:1,V4@V3:7,V4@V5:V4@V3/binary-unit:8,V4@Buf6/bitstring>> ->
{V4@V5,V4@Buf6};
<<1:1,0:1,V4@V4:14,V4@V6:V4@V4/binary-unit:8,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,1:1,V4@V4:6,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7}  = decode_fragmented(V4@V4, V4@Buf5, 8),
{V4@V6,V4@Buf7}
end,
{TmpValx4,_} = dec_NtcipEssData(V4@V0),
{TmpValx4,V4@Buf1}
end;
_  ->
{asn1_NOVALUE,Bytes6}
end,
Bytes8= skipextensions(Bytes7, 2, Extensions),
Res1 = {'SnapShot',Term1,Term2,Term3,Term4},
{Res1,Bytes8}.

enc_NtcipEssData(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc11@element = element(12, Val),
if Enc11@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute airTemp(1) with type NtcipAirTemperature
Enc13@element = element(2, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipAirTemperature(Enc13@element)
end
end,
begin
%% attribute atmosphere(2) with type NtcipAtmosphericPressure
Enc15@element = element(3, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipAtmosphericPressure(Enc15@element)
end
end,
begin
%% attribute wind(3) with type NtcipWind
Enc17@element = element(4, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipWind(Enc17@element)
end
end,
begin
%% attribute humidity(4) with type NtcipRelativeHumidity
Enc19@element = element(5, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipRelativeHumidity(Enc19@element)
end
end,
begin
%% attribute dewpoint(5) with type NtcipDewPoint
Enc21@element = element(6, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipDewPoint(Enc21@element)
end
end,
begin
%% attribute pavement(6) with type NtcipPavement
Enc23@element = element(7, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipPavement(Enc23@element)
end
end,
begin
%% attribute visibility(7) with type NtcipVisibility
Enc25@element = element(8, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipVisibility(Enc25@element)
end
end,
begin
%% attribute visSituation(8) with type NtcipVisibilitySituation
Enc27@element = element(9, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipVisibilitySituation(Enc27@element)
end
end,
begin
%% attribute cloudSitiation(9) with type NtcipCloudSituation
Enc29@element = element(10, Val),
if Enc29@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipCloudSituation(Enc29@element)
end
end,
begin
%% attribute precipitation(10) with type NtcipPrecipitation
Enc31@element = element(11, Val),
if Enc31@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipPrecipitation(Enc31@element)
end
end|begin
%% attribute solarRadiation(11) with type NtcipSolarRadiation
Enc33@element = element(12, Val),
if Enc33@element =:= asn1_NOVALUE ->
[];
true ->
enc_NtcipSolarRadiation(Enc33@element)
end
end].


dec_NtcipEssData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:11,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute airTemp(1) with type NtcipAirTemperature
{Term1,Bytes3} = case (Opt bsr 10) band 1 of
1 ->
dec_NtcipAirTemperature(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute atmosphere(2) with type NtcipAtmosphericPressure
{Term2,Bytes4} = case (Opt bsr 9) band 1 of
1 ->
dec_NtcipAtmosphericPressure(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute wind(3) with type NtcipWind
{Term3,Bytes5} = case (Opt bsr 8) band 1 of
1 ->
dec_NtcipWind(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute humidity(4) with type NtcipRelativeHumidity
{Term4,Bytes6} = case (Opt bsr 7) band 1 of
1 ->
dec_NtcipRelativeHumidity(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute dewpoint(5) with type NtcipDewPoint
{Term5,Bytes7} = case (Opt bsr 6) band 1 of
1 ->
dec_NtcipDewPoint(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute pavement(6) with type NtcipPavement
{Term6,Bytes8} = case (Opt bsr 5) band 1 of
1 ->
dec_NtcipPavement(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute visibility(7) with type NtcipVisibility
{Term7,Bytes9} = case (Opt bsr 4) band 1 of
1 ->
dec_NtcipVisibility(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute visSituation(8) with type NtcipVisibilitySituation
{Term8,Bytes10} = case (Opt bsr 3) band 1 of
1 ->
dec_NtcipVisibilitySituation(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute cloudSitiation(9) with type NtcipCloudSituation
{Term9,Bytes11} = case (Opt bsr 2) band 1 of
1 ->
dec_NtcipCloudSituation(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute precipitation(10) with type NtcipPrecipitation
{Term10,Bytes12} = case (Opt bsr 1) band 1 of
1 ->
dec_NtcipPrecipitation(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute solarRadiation(11) with type NtcipSolarRadiation
{Term11,Bytes13} = case Opt band 1 of
1 ->
dec_NtcipSolarRadiation(Bytes12);
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% Extensions
{Extensions,Bytes14} = case Ext of
0 -> {<<>>,Bytes13};
1 ->
{V3@V0,V3@Buf1} = case Bytes13 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes15= skipextensions(Bytes14, 1, Extensions),
Res1 = {'NtcipEssData',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11},
{Res1,Bytes15}.

enc_NtcipAirTemperature(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute temperature(1) with type INTEGER
Enc4@element = element(2, Val),
Enc4@element@sub = Enc4@element - -1000,
if 0 =< Enc4@element@sub, Enc4@element@sub < 2002 ->
<<Enc4@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end,
begin
%% attribute measurementStdDev(2) with type INTEGER
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc6@element@sub = Enc6@element - 1,
if Enc6@element@sub bsr 4 =:= 0 ->
<<Enc6@element@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end
end
end|begin
%% attribute tempSensorHeight(3) with type INTEGER
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc9@element@sub = Enc9@element - -1000,
if 0 =< Enc9@element@sub, Enc9@element@sub < 2002 ->
<<Enc9@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end
end
end].


dec_NtcipAirTemperature(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute temperature(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:11,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -1000,
{V3@Add2,V3@Buf1}
end,

%% attribute measurementStdDev(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute tempSensorHeight(3) with type INTEGER
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:11,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -1000,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'NtcipAirTemperature',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_NTCIPEssAirTemperature(Val) ->
Val@sub = Val - -1000,
if 0 =< Val@sub, Val@sub < 2002 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssAirTemperature(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1000,
{V1@Add2,V1@Buf1}
end.

enc_NTCIPEssTemperatureSensorHeight(Val) ->
Val@sub = Val - -1000,
if 0 =< Val@sub, Val@sub < 2002 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssTemperatureSensorHeight(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1000,
{V1@Add2,V1@Buf1}
end.

enc_NtcipAtmosphericPressure(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute pressure(1) with type INTEGER
Enc3@element = element(2, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute measurementStdDev(2) with type INTEGER
Enc5@element = element(3, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc5@element@sub = Enc5@element - 1,
if Enc5@element@sub bsr 4 =:= 0 ->
<<Enc5@element@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end
end
end].


dec_NtcipAtmosphericPressure(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute pressure(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute measurementStdDev(2) with type INTEGER
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'NtcipAtmosphericPressure',Term1,Term2},
{Res1,Bytes6}.

enc_NTCIPEssPressureSensorAtmosphericPressure(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssPressureSensorAtmosphericPressure(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NtcipWind(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute avgSpeed(1) with type INTEGER
Enc8@element = element(2, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
Enc8@element bsr 16 =:= 0 ->
<<Enc8@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc8@element}}})
end
end,
begin
%% attribute avgDirection(2) with type INTEGER
Enc11@element = element(3, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
0 =< Enc11@element, Enc11@element < 362 ->
<<Enc11@element:9>>;
true ->
exit({error,{asn1,{illegal_integer,Enc11@element}}})
end
end,
begin
%% attribute currentSpeed(3) with type INTEGER
Enc14@element = element(4, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
Enc14@element bsr 16 =:= 0 ->
<<Enc14@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc14@element}}})
end
end,
begin
%% attribute curDirection(4) with type INTEGER
Enc17@element = element(5, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
0 =< Enc17@element, Enc17@element < 362 ->
<<Enc17@element:9>>;
true ->
exit({error,{asn1,{illegal_integer,Enc17@element}}})
end
end,
begin
%% attribute gustSpeed(5) with type INTEGER
Enc20@element = element(6, Val),
if Enc20@element =:= asn1_NOVALUE ->
[];
Enc20@element bsr 16 =:= 0 ->
<<Enc20@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc20@element}}})
end
end|begin
%% attribute gustDirection(6) with type INTEGER
Enc23@element = element(7, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
0 =< Enc23@element, Enc23@element < 362 ->
<<Enc23@element:9>>;
true ->
exit({error,{asn1,{illegal_integer,Enc23@element}}})
end
end].


dec_NtcipWind(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute avgSpeed(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute avgDirection(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:9,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute currentSpeed(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute curDirection(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:9,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute gustSpeed(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V7@V0:16,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute gustDirection(6) with type INTEGER
{Term6,Bytes8} = case Opt band 1 of
1 ->
begin
<<V8@V0:9,V8@Buf1/bitstring>> = Bytes7,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V9@V0,V9@Buf1} = case Bytes8 of
<<0:1,V9@V3:6,V9@Buf4/bitstring>> ->
V9@Add5 = V9@V3 + 1,
{V9@Add5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:7,V9@Buf7/bitstring>> when V9@V6 =/= 0 ->
{V9@V6,V9@Buf7};
<<1:1,0:1,V9@V7:14,V9@Buf8/bitstring>> when V9@V7 =/= 0 ->
{V9@V7,V9@Buf8};
<<1:1,1:1,V9@V7:6,V9@Buf8/bitstring>> when V9@V7 =/= 0 ->
V9@Mul9 = V9@V7 * 16384,
{V9@Mul9,V9@Buf8}
end,
{V9@V3,V9@Buf4}
end,
<<V9@V10:V9@V0/bitstring-unit:1,V9@Buf11/bitstring>> = V9@Buf1,
{V9@V10,V9@Buf11}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = {'NtcipWind',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes10}.

enc_NTCIPWindSensorAvgSpeed(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPWindSensorAvgSpeed(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NTCIPWindSensorAvgDirection(Val) ->
if 0 =< Val, Val < 362 ->
<<Val:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPWindSensorAvgDirection(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NTCIPWindSensorSpotSpeed(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPWindSensorSpotSpeed(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NTCIPWindSensorSpotDirection(Val) ->
if 0 =< Val, Val < 362 ->
<<Val:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPWindSensorSpotDirection(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NTCIPWindSensorGustSpeed(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPWindSensorGustSpeed(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NTCIPWindSensorGustDirection(Val) ->
if 0 =< Val, Val < 362 ->
<<Val:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPWindSensorGustDirection(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NtcipRelativeHumidity(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute relHumidity(1) with type INTEGER
Enc3@element = element(2, Val),
if 0 =< Enc3@element, Enc3@element < 102 ->
<<Enc3@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute source(2) with type ENUMERATED
Enc5@element = element(3, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
Enc5@element =:= measured ->
<<0:1,0:1>>;
Enc5@element =:= derived ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end].


dec_NtcipRelativeHumidity(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute relHumidity(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute source(2) with type ENUMERATED
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:1,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> measured;
1 -> derived
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11};
<<1:1,1:1,V4@V10:6,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
V4@Mul12 = V4@V10 * 16384,
{V4@Mul12,V4@Buf11}
end,
<<V4@V13:V4@V6/unit:8,V4@Buf14/bitstring>> = V4@Buf7,
{V4@V13,V4@Buf14}
end,
V4@Int15 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int15,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'NtcipRelativeHumidity',Term1,Term2},
{Res1,Bytes6}.

enc_NTCIPHumiditySensorRelativeHumidity(Val) ->
if 0 =< Val, Val < 102 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPHumiditySensorRelativeHumidity(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NtcipDewPoint(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute dewTemp(1) with type INTEGER
Enc4@element = element(2, Val),
Enc4@element@sub = Enc4@element - -1000,
if 0 =< Enc4@element@sub, Enc4@element@sub < 2002 ->
<<Enc4@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end,
begin
%% attribute source(2) with type ENUMERATED
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element =:= measured ->
<<0:1,0:1>>;
Enc6@element =:= derived ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc6@element}}})
end
end|begin
%% attribute measurementStdDev(3) with type INTEGER
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc9@element@sub = Enc9@element - 1,
if Enc9@element@sub bsr 4 =:= 0 ->
<<Enc9@element@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end
end
end].


dec_NtcipDewPoint(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute dewTemp(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:11,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -1000,
{V3@Add2,V3@Buf1}
end,

%% attribute source(2) with type ENUMERATED
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:1,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> measured;
1 -> derived
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11};
<<1:1,1:1,V4@V10:6,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
V4@Mul12 = V4@V10 * 16384,
{V4@Mul12,V4@Buf11}
end,
<<V4@V13:V4@V6/unit:8,V4@Buf14/bitstring>> = V4@Buf7,
{V4@V13,V4@Buf14}
end,
V4@Int15 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int15,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute measurementStdDev(3) with type INTEGER
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'NtcipDewPoint',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_NTCIPEssDewpointTemp(Val) ->
Val@sub = Val - -1000,
if 0 =< Val@sub, Val@sub < 2002 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssDewpointTemp(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1000,
{V1@Add2,V1@Buf1}
end.

enc_NtcipPavement(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute surfaceTemp(1) with type INTEGER
Enc7@element = element(2, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc7@element@sub = Enc7@element - -1000,
if 0 =< Enc7@element@sub, Enc7@element@sub < 2002 ->
<<Enc7@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end
end
end,
begin
%% attribute tempStdDev(2) with type INTEGER
Enc10@element = element(3, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc10@element@sub = Enc10@element - 1,
if Enc10@element@sub bsr 4 =:= 0 ->
<<Enc10@element@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc10@element}}})
end
end
end
end,
begin
%% attribute condition(3) with type ENUMERATED
Enc13@element = element(4, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
Enc13@element =:= other ->
<<0:1,0:4>>;
Enc13@element =:= error ->
<<0:1,1:4>>;
Enc13@element =:= dry ->
<<0:1,2:4>>;
Enc13@element =:= moist ->
<<0:1,3:4>>;
Enc13@element =:= chemicallyMoist ->
<<0:1,4:4>>;
Enc13@element =:= wet ->
<<0:1,5:4>>;
Enc13@element =:= chemicallyWet ->
<<0:1,6:4>>;
Enc13@element =:= standingWater ->
<<0:1,7:4>>;
Enc13@element =:= frost ->
<<0:1,8:4>>;
Enc13@element =:= slush ->
<<0:1,9:4>>;
Enc13@element =:= snow ->
<<0:1,10:4>>;
Enc13@element =:= ice ->
<<0:1,11:4>>;
Enc13@element =:= noReport ->
<<0:1,12:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc13@element}}})
end
end,
begin
%% attribute moistureDepth(4) with type INTEGER
Enc16@element = element(5, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
Enc16@element bsr 16 =:= 0 ->
<<Enc16@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc16@element}}})
end
end|begin
%% attribute roadRoughness(5) with type RoadRoughness
Enc19@element = element(6, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_RoadRoughness(Enc19@element)
end
end].


dec_NtcipPavement(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute surfaceTemp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:11,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -1000,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute tempStdDev(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute condition(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:4,V5@Buf4/bitstring>> ->
V5@Int5 = case V5@V3 of
0 -> other;
1 -> error;
2 -> dry;
3 -> moist;
4 -> chemicallyMoist;
5 -> wet;
6 -> chemicallyWet;
7 -> standingWater;
8 -> frost;
9 -> slush;
10 -> snow;
11 -> ice;
12 -> noReport;
_ -> exit({error,{asn1,{decode_enumerated,V5@V3}}})
end,
{V5@Int5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:6,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<1:1,V5@Buf5/bitstring>> ->
{V5@V6,V5@Buf7} = case V5@Buf5 of
<<0:1,V5@V9:7,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10};
<<1:1,0:1,V5@V10:14,V5@Buf11/bitstring>> when V5@V10 =/= 0 ->
{V5@V10,V5@Buf11};
<<1:1,1:1,V5@V10:6,V5@Buf11/bitstring>> when V5@V10 =/= 0 ->
V5@Mul12 = V5@V10 * 16384,
{V5@Mul12,V5@Buf11}
end,
<<V5@V13:V5@V6/unit:8,V5@Buf14/bitstring>> = V5@Buf7,
{V5@V13,V5@Buf14}
end,
V5@Int15 = case V5@V3 of
_ -> {asn1_enum,V5@V3}
end,
{V5@Int15,V5@Buf4}
end,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute moistureDepth(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:16,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute roadRoughness(5) with type RoadRoughness
{Term5,Bytes7} = case Opt band 1 of
1 ->
'Common':dec_RoadRoughness(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V7@V0,V7@Buf1} = case Bytes7 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'NtcipPavement',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes9}.

enc_NTCIPEssSurfaceTemperature(Val) ->
Val@sub = Val - -1000,
if 0 =< Val@sub, Val@sub < 2002 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssSurfaceTemperature(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1000,
{V1@Add2,V1@Buf1}
end.

enc_NTCIPPavementSensorSurfaceCondition(Val) ->
if Val =:= other ->
<<0:1,0:4>>;
Val =:= error ->
<<0:1,1:4>>;
Val =:= dry ->
<<0:1,2:4>>;
Val =:= moist ->
<<0:1,3:4>>;
Val =:= chemicallyMoist ->
<<0:1,4:4>>;
Val =:= wet ->
<<0:1,5:4>>;
Val =:= chemicallyWet ->
<<0:1,6:4>>;
Val =:= standingWater ->
<<0:1,7:4>>;
Val =:= frost ->
<<0:1,8:4>>;
Val =:= slush ->
<<0:1,9:4>>;
Val =:= snow ->
<<0:1,10:4>>;
Val =:= ice ->
<<0:1,11:4>>;
Val =:= noReport ->
<<0:1,12:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NTCIPPavementSensorSurfaceCondition(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> other;
1 -> error;
2 -> dry;
3 -> moist;
4 -> chemicallyMoist;
5 -> wet;
6 -> chemicallyWet;
7 -> standingWater;
8 -> frost;
9 -> slush;
10 -> snow;
11 -> ice;
12 -> noReport;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NTCIPEssSurfaceIceOrWaterDepth(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssSurfaceIceOrWaterDepth(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NtcipVisibility(Val) ->
%% attribute visibility(1) with type INTEGER
Enc2@element = element(2, Val),
if 0 =< Enc2@element, Enc2@element < 1000002 ->
<<0:1,Enc2@element:20>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end.


dec_NtcipVisibility(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute visibility(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:20,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = {'NtcipVisibility',Term1},
{Res1,Bytes4}.

enc_NTCIPEssVisibility(Val) ->
if 0 =< Val, Val < 1000002 ->
<<Val:20>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssVisibility(Bytes) ->
begin
<<V1@V0:20,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NtcipVisibilitySituation(Val) ->
%% attribute situation(1) with type ENUMERATED
Enc2@element = element(2, Val),
if Enc2@element =:= other ->
<<0:1,0:1,0:4>>;
Enc2@element =:= unknown ->
<<0:1,0:1,1:4>>;
Enc2@element =:= clear ->
<<0:1,0:1,2:4>>;
Enc2@element =:= fogNotPatchy ->
<<0:1,0:1,3:4>>;
Enc2@element =:= patchyFog ->
<<0:1,0:1,4:4>>;
Enc2@element =:= blowingSnow ->
<<0:1,0:1,5:4>>;
Enc2@element =:= smoke ->
<<0:1,0:1,6:4>>;
Enc2@element =:= seaSpray ->
<<0:1,0:1,7:4>>;
Enc2@element =:= vehicleSpray ->
<<0:1,0:1,8:4>>;
Enc2@element =:= blowingDustOrSand ->
<<0:1,0:1,9:4>>;
Enc2@element =:= sunGlare ->
<<0:1,0:1,10:4>>;
Enc2@element =:= swarmsOfInsects ->
<<0:1,0:1,11:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc2@element}}})
end.


dec_NtcipVisibilitySituation(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute situation(1) with type ENUMERATED
{Term1,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:4,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> other;
1 -> unknown;
2 -> clear;
3 -> fogNotPatchy;
4 -> patchyFog;
5 -> blowingSnow;
6 -> smoke;
7 -> seaSpray;
8 -> vehicleSpray;
9 -> blowingDustOrSand;
10 -> sunGlare;
11 -> swarmsOfInsects;
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11};
<<1:1,1:1,V2@V10:6,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
V2@Mul12 = V2@V10 * 16384,
{V2@Mul12,V2@Buf11}
end,
<<V2@V13:V2@V6/unit:8,V2@Buf14/bitstring>> = V2@Buf7,
{V2@V13,V2@Buf14}
end,
V2@Int15 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int15,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end,

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = {'NtcipVisibilitySituation',Term1},
{Res1,Bytes4}.

enc_NTCIPEssVisibilitySituation(Val) ->
if Val =:= other ->
<<0:1,0:4>>;
Val =:= unknown ->
<<0:1,1:4>>;
Val =:= clear ->
<<0:1,2:4>>;
Val =:= fogNotPatchy ->
<<0:1,3:4>>;
Val =:= patchyFog ->
<<0:1,4:4>>;
Val =:= blowingSnow ->
<<0:1,5:4>>;
Val =:= smoke ->
<<0:1,6:4>>;
Val =:= seaSpray ->
<<0:1,7:4>>;
Val =:= vehicleSpray ->
<<0:1,8:4>>;
Val =:= blowingDustOrSand ->
<<0:1,9:4>>;
Val =:= sunGlare ->
<<0:1,10:4>>;
Val =:= swarmsOfInsects ->
<<0:1,11:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NTCIPEssVisibilitySituation(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> other;
1 -> unknown;
2 -> clear;
3 -> fogNotPatchy;
4 -> patchyFog;
5 -> blowingSnow;
6 -> smoke;
7 -> seaSpray;
8 -> vehicleSpray;
9 -> blowingDustOrSand;
10 -> sunGlare;
11 -> swarmsOfInsects;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NtcipCloudSituation(Val) ->
%% attribute situation(1) with type INTEGER
Enc2@element = element(2, Val),
if 0 =< Enc2@element, Enc2@element < 9 ->
<<0:1,Enc2@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end.


dec_NtcipCloudSituation(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute situation(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = {'NtcipCloudSituation',Term1},
{Res1,Bytes4}.

enc_NTCIPEssCloudSituationV4(Val) ->
if 0 =< Val, Val < 9 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssCloudSituationV4(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_NtcipPrecipitation(Val) ->
%% attribute precipitation(1) with type ENUMERATED
Enc2@element = element(2, Val),
if Enc2@element =:= other ->
<<0:1,0:1,0:4>>;
Enc2@element =:= unknown ->
<<0:1,0:1,1:4>>;
Enc2@element =:= noPrecipitation ->
<<0:1,0:1,2:4>>;
Enc2@element =:= unidentifiedSlight ->
<<0:1,0:1,3:4>>;
Enc2@element =:= unidentifiedModerate ->
<<0:1,0:1,4:4>>;
Enc2@element =:= unidentifiedHeavy ->
<<0:1,0:1,5:4>>;
Enc2@element =:= snowSlight ->
<<0:1,0:1,6:4>>;
Enc2@element =:= snowModerate ->
<<0:1,0:1,7:4>>;
Enc2@element =:= snowHeavy ->
<<0:1,0:1,8:4>>;
Enc2@element =:= rainSlight ->
<<0:1,0:1,9:4>>;
Enc2@element =:= rainModerate ->
<<0:1,0:1,10:4>>;
Enc2@element =:= rainHeavy ->
<<0:1,0:1,11:4>>;
Enc2@element =:= frozenPrecipitationSlight ->
<<0:1,0:1,12:4>>;
Enc2@element =:= frozenPrecipitationModerate ->
<<0:1,0:1,13:4>>;
Enc2@element =:= frozenPrecipitationHeavy ->
<<0:1,0:1,14:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc2@element}}})
end.


dec_NtcipPrecipitation(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute precipitation(1) with type ENUMERATED
{Term1,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:4,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> other;
1 -> unknown;
2 -> noPrecipitation;
3 -> unidentifiedSlight;
4 -> unidentifiedModerate;
5 -> unidentifiedHeavy;
6 -> snowSlight;
7 -> snowModerate;
8 -> snowHeavy;
9 -> rainSlight;
10 -> rainModerate;
11 -> rainHeavy;
12 -> frozenPrecipitationSlight;
13 -> frozenPrecipitationModerate;
14 -> frozenPrecipitationHeavy;
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11};
<<1:1,1:1,V2@V10:6,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
V2@Mul12 = V2@V10 * 16384,
{V2@Mul12,V2@Buf11}
end,
<<V2@V13:V2@V6/unit:8,V2@Buf14/bitstring>> = V2@Buf7,
{V2@V13,V2@Buf14}
end,
V2@Int15 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int15,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end,

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = {'NtcipPrecipitation',Term1},
{Res1,Bytes4}.

enc_NTCIPPrecipitationSensorPrecipSituation(Val) ->
if Val =:= other ->
<<0:1,0:4>>;
Val =:= unknown ->
<<0:1,1:4>>;
Val =:= noPrecipitation ->
<<0:1,2:4>>;
Val =:= unidentifiedSlight ->
<<0:1,3:4>>;
Val =:= unidentifiedModerate ->
<<0:1,4:4>>;
Val =:= unidentifiedHeavy ->
<<0:1,5:4>>;
Val =:= snowSlight ->
<<0:1,6:4>>;
Val =:= snowModerate ->
<<0:1,7:4>>;
Val =:= snowHeavy ->
<<0:1,8:4>>;
Val =:= rainSlight ->
<<0:1,9:4>>;
Val =:= rainModerate ->
<<0:1,10:4>>;
Val =:= rainHeavy ->
<<0:1,11:4>>;
Val =:= frozenPrecipitationSlight ->
<<0:1,12:4>>;
Val =:= frozenPrecipitationModerate ->
<<0:1,13:4>>;
Val =:= frozenPrecipitationHeavy ->
<<0:1,14:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_NTCIPPrecipitationSensorPrecipSituation(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> other;
1 -> unknown;
2 -> noPrecipitation;
3 -> unidentifiedSlight;
4 -> unidentifiedModerate;
5 -> unidentifiedHeavy;
6 -> snowSlight;
7 -> snowModerate;
8 -> snowHeavy;
9 -> rainSlight;
10 -> rainModerate;
11 -> rainHeavy;
12 -> frozenPrecipitationSlight;
13 -> frozenPrecipitationModerate;
14 -> frozenPrecipitationHeavy;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_NtcipSolarRadiation(Val) ->
[begin
%% attribute solarRadiation(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - -2048,
if 0 =< Enc2@element@sub, Enc2@element@sub < 4098 ->
<<0:1,Enc2@element@sub:13>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute measurementPeriod(2) with type INTEGER
Enc4@element = element(3, Val),
if 0 =< Enc4@element, Enc4@element < 86401 ->
<<Enc4@element:17>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_NtcipSolarRadiation(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute solarRadiation(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:13,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2048,
{V2@Add2,V2@Buf1}
end,

%% attribute measurementPeriod(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:17,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'NtcipSolarRadiation',Term1,Term2},
{Res1,Bytes5}.

enc_NTCIPEssTotalRadiationV4(Val) ->
Val@sub = Val - -2048,
if 0 =< Val@sub, Val@sub < 4098 ->
<<Val@sub:13>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssTotalRadiationV4(Bytes) ->
begin
<<V1@V0:13,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2048,
{V1@Add2,V1@Buf1}
end.

enc_NTCIPEssTotalRadiationPeriod(Val) ->
if 0 =< Val, Val < 86401 ->
<<Val:17>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_NTCIPEssTotalRadiationPeriod(Bytes) ->
begin
<<V1@V0:17,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TemperatureMeasurementStdDev(Val) ->
Val@sub = Val - 1,
if Val@sub bsr 4 =:= 0 ->
<<Val@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TemperatureMeasurementStdDev(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_AtmosPressureMeasurementStdDev(Val) ->
Val@sub = Val - 1,
if Val@sub bsr 4 =:= 0 ->
<<Val@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_AtmosPressureMeasurementStdDev(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_DewPointTempMeasurementStdDev(Val) ->
Val@sub = Val - 1,
if Val@sub bsr 4 =:= 0 ->
<<Val@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DewPointTempMeasurementStdDev(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_SurfaceTempMeasurementStdDev(Val) ->
Val@sub = Val - 1,
if Val@sub bsr 4 =:= 0 ->
<<Val@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SurfaceTempMeasurementStdDev(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_DataSourceInfo(Val) ->
if Val =:= measured ->
<<0:1,0:1>>;
Val =:= derived ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_DataSourceInfo(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:1,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> measured;
1 -> derived
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

typeinfo('RoadWeatherMessage') ->
  {choice,#{<<100,111,119,110,108,111,97,100>> => {typeinfo,{'RoadWeatherMessage','RoadWeatherDownload'}},<<117,112,108,111,97,100>> => {typeinfo,{'RoadWeatherMessage','RoadWeatherUpload'}}}};
typeinfo('RoadWeatherUpload') ->
  {choice,#{<<99,105,116,105,122,101,110,82,101,112,111,114,116>> => {typeinfo,{'RoadWeatherMessage','SnapShot'}},<<118,101,104,105,99,108,101,82,101,112,111,114,116>> => {sof,{typeinfo,{'RoadWeatherMessage','VehicleReport'}}}}};
typeinfo('VehicleReport') ->
  {sequence,'VehicleReport',2,[{<<115,110,97,112,83,104,111,116>>,{typeinfo,{'RoadWeatherMessage','SnapShot'}},mandatory},{<<119,100,109,115,70,108,101,101,116,68,97,116,97>>,{typeinfo,{'RoadWeatherMessage','WDMSFleetData'}},'OPTIONAL'}]};
typeinfo('RoadWeatherDownload') ->
  {sequence,'RoadWeatherDownload',2,[{<<116,114,97,118,101,108,101,114,68,97,116,97>>,{typeinfo,{'TravelerInformation','TravelerDataFrameList'}},mandatory},{<<119,100,109,115,70,108,101,101,116,68,97,116,97>>,{typeinfo,{'RoadWeatherMessage','WDMSFleetData'}},'OPTIONAL'}]};
typeinfo('WDMSFleetData') ->
  {sequence,'WDMSFleetData',2,[{<<112,97,118,101,109,101,110,116,84,114,101,97,116>>,{typeinfo,{'RoadWeatherMessage','NtcipPavementTreatment'}},'OPTIONAL'},{<<114,111,117,116,105,110,103,65,100,118,105,99,101>>,string,'OPTIONAL'}]};
typeinfo('NtcipPavementTreatment') ->
  {sequence,'NtcipPavementTreatment',8,[{<<108,97,116,105,116,117,100,101>>,{'INTEGER',{-90000000,90000001}},mandatory},{<<108,111,110,103,105,116,117,100,101>>,{'INTEGER',{-180000000,180000001}},mandatory},{<<108,111,99,97,116,105,111,110>>,string,mandatory},{<<112,114,111,100,117,99,116,84,121,112,101>>,{'ENUMERATED_EXT',#{other => 1,gravel => 4,cinders => 5,sand => 2,dirt => 3,water => 6,enhancedSalts => 7,naCl => 8,caCl => 9,mgCl => 10,cMA => 11,kAC => 12,naFormate => 13,naA => 14}},'OPTIONAL'},{<<102,111,114,109>>,{'ENUMERATED_EXT',#{other => 1,dry => 2,prewet => 3,liquid => 4}},'OPTIONAL'},{<<112,101,114,99,101,110,116,97,103,101>>,{'INTEGER',{0,100}},'OPTIONAL'},{<<97,109,111,117,110,116>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<119,105,100,116,104>>,{'INTEGER',{0,255}},'OPTIONAL'}]};
typeinfo('NTCIPEssPavementTreatmentLatitude') ->
  {'INTEGER',{-90000000,90000001}};
typeinfo('NTCIPEssPavementTreatmentLongitude') ->
  {'INTEGER',{-180000000,180000001}};
typeinfo('NTCIPEssPavementTreatmentLocation') ->
  string;
typeinfo('NTCIPEssPaveTreatProductType') ->
  {'ENUMERATED_EXT',#{other => 1,gravel => 4,cinders => 5,sand => 2,dirt => 3,water => 6,enhancedSalts => 7,naCl => 8,caCl => 9,mgCl => 10,cMA => 11,kAC => 12,naFormate => 13,naA => 14}};
typeinfo('NTCIPEssPaveTreatProductForm') ->
  {'ENUMERATED_EXT',#{other => 1,dry => 2,prewet => 3,liquid => 4}};
typeinfo('NTCIPEssPercentProductMix') ->
  {'INTEGER',{0,100}};
typeinfo('NTCIPEssPaveTreatmentAmount') ->
  {'INTEGER',{0,255}};
typeinfo('NTCIPEssPaveTreatmentWidth') ->
  {'INTEGER',{0,255}};
typeinfo('SnapShot') ->
  {sequence,'SnapShot',4,[{<<116,104,101,80,111,115,105,116,105,111,110>>,{typeinfo,{'Common','FullPositionVector'}},mandatory},{<<115,97,102,101,116,121,69,120,116>>,{typeinfo,{'Common','VehicleSafetyExtensions'}},'OPTIONAL'},{<<100,97,116,97,83,101,116>>,{typeinfo,{'ProbeVehicleData','VehicleStatus'}},'OPTIONAL'},{<<119,101,97,116,104,101,114,68,97,116,97>>,{typeinfo,{'RoadWeatherMessage','NtcipEssData'}},'OPTIONAL'}]};
typeinfo('NtcipEssData') ->
  {sequence,'NtcipEssData',11,[{<<97,105,114,84,101,109,112>>,{typeinfo,{'RoadWeatherMessage','NtcipAirTemperature'}},'OPTIONAL'},{<<97,116,109,111,115,112,104,101,114,101>>,{typeinfo,{'RoadWeatherMessage','NtcipAtmosphericPressure'}},'OPTIONAL'},{<<119,105,110,100>>,{typeinfo,{'RoadWeatherMessage','NtcipWind'}},'OPTIONAL'},{<<104,117,109,105,100,105,116,121>>,{typeinfo,{'RoadWeatherMessage','NtcipRelativeHumidity'}},'OPTIONAL'},{<<100,101,119,112,111,105,110,116>>,{typeinfo,{'RoadWeatherMessage','NtcipDewPoint'}},'OPTIONAL'},{<<112,97,118,101,109,101,110,116>>,{typeinfo,{'RoadWeatherMessage','NtcipPavement'}},'OPTIONAL'},{<<118,105,115,105,98,105,108,105,116,121>>,{typeinfo,{'RoadWeatherMessage','NtcipVisibility'}},'OPTIONAL'},{<<118,105,115,83,105,116,117,97,116,105,111,110>>,{typeinfo,{'RoadWeatherMessage','NtcipVisibilitySituation'}},'OPTIONAL'},{<<99,108,111,117,100,83,105,116,105,97,116,105,111,110>>,{typeinfo,{'RoadWeatherMessage','NtcipCloudSituation'}},'OPTIONAL'},{<<112,114,101,99,105,112,105,116,97,116,105,111,110>>,{typeinfo,{'RoadWeatherMessage','NtcipPrecipitation'}},'OPTIONAL'},{<<115,111,108,97,114,82,97,100,105,97,116,105,111,110>>,{typeinfo,{'RoadWeatherMessage','NtcipSolarRadiation'}},'OPTIONAL'}]};
typeinfo('NtcipAirTemperature') ->
  {sequence,'NtcipAirTemperature',3,[{<<116,101,109,112,101,114,97,116,117,114,101>>,{'INTEGER',{-1000,1001}},mandatory},{<<109,101,97,115,117,114,101,109,101,110,116,83,116,100,68,101,118>>,{'INTEGER',{1,16}},'OPTIONAL'},{<<116,101,109,112,83,101,110,115,111,114,72,101,105,103,104,116>>,{'INTEGER',{-1000,1001}},'OPTIONAL'}]};
typeinfo('NTCIPEssAirTemperature') ->
  {'INTEGER',{-1000,1001}};
typeinfo('NTCIPEssTemperatureSensorHeight') ->
  {'INTEGER',{-1000,1001}};
typeinfo('NtcipAtmosphericPressure') ->
  {sequence,'NtcipAtmosphericPressure',2,[{<<112,114,101,115,115,117,114,101>>,{'INTEGER',{0,65535}},mandatory},{<<109,101,97,115,117,114,101,109,101,110,116,83,116,100,68,101,118>>,{'INTEGER',{1,16}},'OPTIONAL'}]};
typeinfo('NTCIPEssPressureSensorAtmosphericPressure') ->
  {'INTEGER',{0,65535}};
typeinfo('NtcipWind') ->
  {sequence,'NtcipWind',6,[{<<97,118,103,83,112,101,101,100>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<97,118,103,68,105,114,101,99,116,105,111,110>>,{'INTEGER',{0,361}},'OPTIONAL'},{<<99,117,114,114,101,110,116,83,112,101,101,100>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<99,117,114,68,105,114,101,99,116,105,111,110>>,{'INTEGER',{0,361}},'OPTIONAL'},{<<103,117,115,116,83,112,101,101,100>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<103,117,115,116,68,105,114,101,99,116,105,111,110>>,{'INTEGER',{0,361}},'OPTIONAL'}]};
typeinfo('NTCIPWindSensorAvgSpeed') ->
  {'INTEGER',{0,65535}};
typeinfo('NTCIPWindSensorAvgDirection') ->
  {'INTEGER',{0,361}};
typeinfo('NTCIPWindSensorSpotSpeed') ->
  {'INTEGER',{0,65535}};
typeinfo('NTCIPWindSensorSpotDirection') ->
  {'INTEGER',{0,361}};
typeinfo('NTCIPWindSensorGustSpeed') ->
  {'INTEGER',{0,65535}};
typeinfo('NTCIPWindSensorGustDirection') ->
  {'INTEGER',{0,361}};
typeinfo('NtcipRelativeHumidity') ->
  {sequence,'NtcipRelativeHumidity',2,[{<<114,101,108,72,117,109,105,100,105,116,121>>,{'INTEGER',{0,101}},mandatory},{<<115,111,117,114,99,101>>,{'ENUMERATED_EXT',#{measured => 0,derived => 1}},'OPTIONAL'}]};
typeinfo('NTCIPHumiditySensorRelativeHumidity') ->
  {'INTEGER',{0,101}};
typeinfo('NtcipDewPoint') ->
  {sequence,'NtcipDewPoint',3,[{<<100,101,119,84,101,109,112>>,{'INTEGER',{-1000,1001}},mandatory},{<<115,111,117,114,99,101>>,{'ENUMERATED_EXT',#{measured => 0,derived => 1}},'OPTIONAL'},{<<109,101,97,115,117,114,101,109,101,110,116,83,116,100,68,101,118>>,{'INTEGER',{1,16}},'OPTIONAL'}]};
typeinfo('NTCIPEssDewpointTemp') ->
  {'INTEGER',{-1000,1001}};
typeinfo('NtcipPavement') ->
  {sequence,'NtcipPavement',5,[{<<115,117,114,102,97,99,101,84,101,109,112>>,{'INTEGER',{-1000,1001}},'OPTIONAL'},{<<116,101,109,112,83,116,100,68,101,118>>,{'INTEGER',{1,16}},'OPTIONAL'},{<<99,111,110,100,105,116,105,111,110>>,{'ENUMERATED_EXT',#{error => 2,other => 1,ice => 12,snow => 11,dry => 3,wet => 6,frost => 9,slush => 10,moist => 4,chemicallyMoist => 5,chemicallyWet => 7,standingWater => 8,noReport => 13}},'OPTIONAL'},{<<109,111,105,115,116,117,114,101,68,101,112,116,104>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<114,111,97,100,82,111,117,103,104,110,101,115,115>>,{typeinfo,{'Common','RoadRoughness'}},'OPTIONAL'}]};
typeinfo('NTCIPEssSurfaceTemperature') ->
  {'INTEGER',{-1000,1001}};
typeinfo('NTCIPPavementSensorSurfaceCondition') ->
  {'ENUMERATED_EXT',#{error => 2,other => 1,ice => 12,snow => 11,dry => 3,wet => 6,frost => 9,slush => 10,moist => 4,chemicallyMoist => 5,chemicallyWet => 7,standingWater => 8,noReport => 13}};
typeinfo('NTCIPEssSurfaceIceOrWaterDepth') ->
  {'INTEGER',{0,65535}};
typeinfo('NtcipVisibility') ->
  {sequence,'NtcipVisibility',1,[{<<118,105,115,105,98,105,108,105,116,121>>,{'INTEGER',{0,1000001}},mandatory}]};
typeinfo('NTCIPEssVisibility') ->
  {'INTEGER',{0,1000001}};
typeinfo('NtcipVisibilitySituation') ->
  {sequence,'NtcipVisibilitySituation',1,[{<<115,105,116,117,97,116,105,111,110>>,{'ENUMERATED_EXT',#{clear => 3,other => 1,unknown => 2,fogNotPatchy => 4,patchyFog => 5,blowingSnow => 6,smoke => 7,seaSpray => 8,vehicleSpray => 9,blowingDustOrSand => 10,sunGlare => 11,swarmsOfInsects => 12}},mandatory}]};
typeinfo('NTCIPEssVisibilitySituation') ->
  {'ENUMERATED_EXT',#{clear => 3,other => 1,unknown => 2,fogNotPatchy => 4,patchyFog => 5,blowingSnow => 6,smoke => 7,seaSpray => 8,vehicleSpray => 9,blowingDustOrSand => 10,sunGlare => 11,swarmsOfInsects => 12}};
typeinfo('NtcipCloudSituation') ->
  {sequence,'NtcipCloudSituation',1,[{<<115,105,116,117,97,116,105,111,110>>,{'INTEGER',{0,8}},mandatory}]};
typeinfo('NTCIPEssCloudSituationV4') ->
  {'INTEGER',{0,8}};
typeinfo('NtcipPrecipitation') ->
  {sequence,'NtcipPrecipitation',1,[{<<112,114,101,99,105,112,105,116,97,116,105,111,110>>,{'ENUMERATED_EXT',#{other => 1,unknown => 2,noPrecipitation => 3,unidentifiedSlight => 4,unidentifiedModerate => 5,unidentifiedHeavy => 6,snowSlight => 7,snowModerate => 8,snowHeavy => 9,rainSlight => 10,rainModerate => 11,rainHeavy => 12,frozenPrecipitationSlight => 13,frozenPrecipitationModerate => 14,frozenPrecipitationHeavy => 15}},mandatory}]};
typeinfo('NTCIPPrecipitationSensorPrecipSituation') ->
  {'ENUMERATED_EXT',#{other => 1,unknown => 2,noPrecipitation => 3,unidentifiedSlight => 4,unidentifiedModerate => 5,unidentifiedHeavy => 6,snowSlight => 7,snowModerate => 8,snowHeavy => 9,rainSlight => 10,rainModerate => 11,rainHeavy => 12,frozenPrecipitationSlight => 13,frozenPrecipitationModerate => 14,frozenPrecipitationHeavy => 15}};
typeinfo('NtcipSolarRadiation') ->
  {sequence,'NtcipSolarRadiation',2,[{<<115,111,108,97,114,82,97,100,105,97,116,105,111,110>>,{'INTEGER',{-2048,2049}},mandatory},{<<109,101,97,115,117,114,101,109,101,110,116,80,101,114,105,111,100>>,{'INTEGER',{0,86400}},mandatory}]};
typeinfo('NTCIPEssTotalRadiationV4') ->
  {'INTEGER',{-2048,2049}};
typeinfo('NTCIPEssTotalRadiationPeriod') ->
  {'INTEGER',{0,86400}};
typeinfo('TemperatureMeasurementStdDev') ->
  {'INTEGER',{1,16}};
typeinfo('AtmosPressureMeasurementStdDev') ->
  {'INTEGER',{1,16}};
typeinfo('DewPointTempMeasurementStdDev') ->
  {'INTEGER',{1,16}};
typeinfo('SurfaceTempMeasurementStdDev') ->
  {'INTEGER',{1,16}};
typeinfo('DataSourceInfo') ->
  {'ENUMERATED_EXT',#{measured => 0,derived => 1}};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

dec_components1(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components1(Num, Bytes, Acc) ->
{Term,Remain} = dec_VehicleReport(Bytes),
dec_components1(Num-1, Remain, [Term|Acc]).

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_chars(Val, N) ->
    [ 
     C ||
         <<C:N>> <= Val
    ].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

encode_chars(Val, NumBits) ->
    << 
      <<C:NumBits>> ||
          C <- Val
    >>.

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

extension_bitmap(Val, Pos, Limit) ->
    extension_bitmap(Val, Pos, Limit, 0).

extension_bitmap(_Val, Pos, Limit, Acc) when Pos >= Limit ->
    Acc;
extension_bitmap(Val, Pos, Limit, Acc) ->
    Bit =
        case element(Pos, Val) of
            asn1_NOVALUE ->
                0;
            asn1_DEFAULT ->
                0;
            _ ->
                1
        end,
    extension_bitmap(Val, Pos + 1, Limit, Acc bsl 1 bor Bit).

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
