%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in TollAdvertisementMessage.

-module('TollAdvertisementMessage').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("TollAdvertisementMessage.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'TollAdvertisementMessage'},
            {options,[{i,"./ebin"},uper,jer,verbose,{i,"./asn"},{outdir,"./ebin"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_TollAdvertisementMessage/1,
enc_TollAdvertisementInfo/1,
enc_TumInstructions/1,
enc_AckPolicy/1,
enc_TollChargesTable/1,
enc_LaneChargesTable/1,
enc_ClosedNetworkChargesTable/1,
enc_EntryChargesTable/1,
enc_ExitChargesTable/1,
enc_ExitInfo/1,
enc_TimeChargesTable/1,
enc_ChargesTable/1,
enc_VehTypeChargesTable/1,
enc_VehTypeCharges/1,
enc_VehicleTypes/1,
enc_SpecialCharges/1,
enc_OperatorDefined/1,
enc_WeightChargesTable/1,
enc_WeightCharges/1,
enc_TotalWeightCharges/1,
enc_PerAxleWeightCharges/1,
enc_AxlesChargesTable/1,
enc_AxlesCharges/1,
enc_TollPointMap/1,
enc_TollChargerInfo/1,
enc_TollPointID/1
]).

-export([
dec_TollAdvertisementMessage/1,
dec_TollAdvertisementInfo/1,
dec_TumInstructions/1,
dec_AckPolicy/1,
dec_TollChargesTable/1,
dec_LaneChargesTable/1,
dec_ClosedNetworkChargesTable/1,
dec_EntryChargesTable/1,
dec_ExitChargesTable/1,
dec_ExitInfo/1,
dec_TimeChargesTable/1,
dec_ChargesTable/1,
dec_VehTypeChargesTable/1,
dec_VehTypeCharges/1,
dec_VehicleTypes/1,
dec_SpecialCharges/1,
dec_OperatorDefined/1,
dec_WeightChargesTable/1,
dec_WeightCharges/1,
dec_TotalWeightCharges/1,
dec_PerAxleWeightCharges/1,
dec_AxlesChargesTable/1,
dec_AxlesCharges/1,
dec_TollPointMap/1,
dec_TollChargerInfo/1,
dec_TollPointID/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('TollAdvertisementMessage', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('TollAdvertisementMessage', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('TollAdvertisementMessage', Data) -> enc_TollAdvertisementMessage(Data);
encode_disp('TollAdvertisementInfo', Data) -> enc_TollAdvertisementInfo(Data);
encode_disp('TumInstructions', Data) -> enc_TumInstructions(Data);
encode_disp('AckPolicy', Data) -> enc_AckPolicy(Data);
encode_disp('TollChargesTable', Data) -> enc_TollChargesTable(Data);
encode_disp('LaneChargesTable', Data) -> enc_LaneChargesTable(Data);
encode_disp('ClosedNetworkChargesTable', Data) -> enc_ClosedNetworkChargesTable(Data);
encode_disp('EntryChargesTable', Data) -> enc_EntryChargesTable(Data);
encode_disp('ExitChargesTable', Data) -> enc_ExitChargesTable(Data);
encode_disp('ExitInfo', Data) -> enc_ExitInfo(Data);
encode_disp('TimeChargesTable', Data) -> enc_TimeChargesTable(Data);
encode_disp('ChargesTable', Data) -> enc_ChargesTable(Data);
encode_disp('VehTypeChargesTable', Data) -> enc_VehTypeChargesTable(Data);
encode_disp('VehTypeCharges', Data) -> enc_VehTypeCharges(Data);
encode_disp('VehicleTypes', Data) -> enc_VehicleTypes(Data);
encode_disp('SpecialCharges', Data) -> enc_SpecialCharges(Data);
encode_disp('OperatorDefined', Data) -> enc_OperatorDefined(Data);
encode_disp('WeightChargesTable', Data) -> enc_WeightChargesTable(Data);
encode_disp('WeightCharges', Data) -> enc_WeightCharges(Data);
encode_disp('TotalWeightCharges', Data) -> enc_TotalWeightCharges(Data);
encode_disp('PerAxleWeightCharges', Data) -> enc_PerAxleWeightCharges(Data);
encode_disp('AxlesChargesTable', Data) -> enc_AxlesChargesTable(Data);
encode_disp('AxlesCharges', Data) -> enc_AxlesCharges(Data);
encode_disp('TollPointMap', Data) -> enc_TollPointMap(Data);
encode_disp('TollChargerInfo', Data) -> enc_TollChargerInfo(Data);
encode_disp('TollPointID', Data) -> enc_TollPointID(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('TollAdvertisementMessage', Data) -> dec_TollAdvertisementMessage(Data);
decode_disp('TollAdvertisementInfo', Data) -> dec_TollAdvertisementInfo(Data);
decode_disp('TumInstructions', Data) -> dec_TumInstructions(Data);
decode_disp('AckPolicy', Data) -> dec_AckPolicy(Data);
decode_disp('TollChargesTable', Data) -> dec_TollChargesTable(Data);
decode_disp('LaneChargesTable', Data) -> dec_LaneChargesTable(Data);
decode_disp('ClosedNetworkChargesTable', Data) -> dec_ClosedNetworkChargesTable(Data);
decode_disp('EntryChargesTable', Data) -> dec_EntryChargesTable(Data);
decode_disp('ExitChargesTable', Data) -> dec_ExitChargesTable(Data);
decode_disp('ExitInfo', Data) -> dec_ExitInfo(Data);
decode_disp('TimeChargesTable', Data) -> dec_TimeChargesTable(Data);
decode_disp('ChargesTable', Data) -> dec_ChargesTable(Data);
decode_disp('VehTypeChargesTable', Data) -> dec_VehTypeChargesTable(Data);
decode_disp('VehTypeCharges', Data) -> dec_VehTypeCharges(Data);
decode_disp('VehicleTypes', Data) -> dec_VehicleTypes(Data);
decode_disp('SpecialCharges', Data) -> dec_SpecialCharges(Data);
decode_disp('OperatorDefined', Data) -> dec_OperatorDefined(Data);
decode_disp('WeightChargesTable', Data) -> dec_WeightChargesTable(Data);
decode_disp('WeightCharges', Data) -> dec_WeightCharges(Data);
decode_disp('TotalWeightCharges', Data) -> dec_TotalWeightCharges(Data);
decode_disp('PerAxleWeightCharges', Data) -> dec_PerAxleWeightCharges(Data);
decode_disp('AxlesChargesTable', Data) -> dec_AxlesChargesTable(Data);
decode_disp('AxlesCharges', Data) -> dec_AxlesCharges(Data);
decode_disp('TollPointMap', Data) -> dec_TollPointMap(Data);
decode_disp('TollChargerInfo', Data) -> dec_TollChargerInfo(Data);
decode_disp('TollPointID', Data) -> dec_TollPointID(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_TollAdvertisementMessage(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute tollChargesTable(1) with type TollChargesTable
Enc3@element = element(2, Val),
enc_TollChargesTable(Enc3@element)
end|begin
%% attribute tollAdvInfo(2) with type TollAdvertisementInfo
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
enc_TollAdvertisementInfo(Enc4@element)
end
end].


dec_TollAdvertisementMessage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tollChargesTable(1) with type TollChargesTable
{Term1,Bytes3} = dec_TollChargesTable(Bytes2),

%% attribute tollAdvInfo(2) with type TollAdvertisementInfo
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_TollAdvertisementInfo(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'TollAdvertisementMessage',Term1,Term2},
{Res1,Bytes6}.

enc_TollAdvertisementInfo(Val) ->
[begin
Enc1@element = element(7, Val),
Enc2@element = element(11, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute tamSequenceNum(1) with type INTEGER
Enc4@element = element(2, Val),
if Enc4@element bsr 7 =:= 0 ->
<<Enc4@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end,
begin
%% attribute totalTams(2) with type INTEGER
Enc6@element = element(3, Val),
Enc6@element@sub = Enc6@element - 1,
if 0 =< Enc6@element@sub, Enc6@element@sub < 10 ->
<<0:1,Enc6@element@sub:4>>;
true ->
[<<1:1>>|encode_unconstrained_number(Enc6@element)]
end
end,
begin
%% attribute tamNum(3) with type INTEGER
Enc8@element = element(4, Val),
Enc8@element@sub = Enc8@element - 1,
if 0 =< Enc8@element@sub, Enc8@element@sub < 10 ->
<<0:1,Enc8@element@sub:4>>;
true ->
[<<1:1>>|encode_unconstrained_number(Enc8@element)]
end
end,
begin
%% attribute tollChargerInfo(4) with type TollChargerInfo
Enc10@element = element(5, Val),
enc_TollChargerInfo(Enc10@element)
end,
begin
%% attribute timestamp(5) with type DDateTime
Enc11@element = element(6, Val),
'Common':enc_DDateTime(Enc11@element)
end,
begin
%% attribute tumInstructions(6) with type TumInstructions
Enc12@element = element(7, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
enc_TumInstructions(Enc12@element)
end
end,
begin
%% attribute tollPointMap(7) with type TollPointMap
Enc14@element = element(8, Val),
enc_TollPointMap(Enc14@element)
end,
begin
%% attribute tumPublicKey(8) with type OCTET STRING
Enc15@element = element(9, Val),
Enc16@len = byte_size(Enc15@element),
if Enc16@len =:= 32 ->
Enc15@element
end
end,
begin
%% attribute ackPolicy(9) with type AckPolicy
Enc17@element = element(10, Val),
enc_AckPolicy(Enc17@element)
end|begin
%% attribute lastTollPtDataReq(10) with type BOOLEAN
Enc18@element = element(11, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
Enc18@element =:= false ->
<<0:1>>;
Enc18@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc18@element}}})
end
end].


dec_TollAdvertisementInfo(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tamSequenceNum(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute totalTams(2) with type INTEGER
{Term2,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:4,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
<<V4@V10:V4@V3/signed-unit:8,V4@Buf11/bitstring>> = V4@Buf4,
{V4@V10,V4@Buf11}
end,
{V4@V0,V4@Buf1}
end,

%% attribute tamNum(3) with type INTEGER
{Term3,Bytes5} = begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:4,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
<<V5@V10:V5@V3/signed-unit:8,V5@Buf11/bitstring>> = V5@Buf4,
{V5@V10,V5@Buf11}
end,
{V5@V0,V5@Buf1}
end,

%% attribute tollChargerInfo(4) with type TollChargerInfo
{Term4,Bytes6} = dec_TollChargerInfo(Bytes5),

%% attribute timestamp(5) with type DDateTime
{Term5,Bytes7} = 'Common':dec_DDateTime(Bytes6),

%% attribute tumInstructions(6) with type TumInstructions
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
dec_TumInstructions(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute tollPointMap(7) with type TollPointMap
{Term7,Bytes9} = dec_TollPointMap(Bytes8),

%% attribute tumPublicKey(8) with type OCTET STRING
{Term8,Bytes10} = begin
<<V6@V0:32/binary-unit:8,V6@Buf1/bitstring>> = Bytes9,
V6@Conv2 = binary:copy(V6@V0),
{V6@Conv2,V6@Buf1}
end,

%% attribute ackPolicy(9) with type AckPolicy
{Term9,Bytes11} = dec_AckPolicy(Bytes10),

%% attribute lastTollPtDataReq(10) with type BOOLEAN
{Term10,Bytes12} = case Opt band 1 of
1 ->
begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes11,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V8@V0,V8@Buf1} = case Bytes12 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8};
<<1:1,1:1,V8@V7:6,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
V8@Mul9 = V8@V7 * 16384,
{V8@Mul9,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V10:V8@V0/bitstring-unit:1,V8@Buf11/bitstring>> = V8@Buf1,
{V8@V10,V8@Buf11}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = {'TollAdvertisementInfo',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10},
{Res1,Bytes14}.

enc_TumInstructions(Val) ->
[begin
%% attribute maxNumOfLocTimeStamps(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - 1,
if 0 =< Enc2@element@sub, Enc2@element@sub < 5 ->
<<0:1,0:1,Enc2@element@sub:3>>;
true ->
[<<0:1,1:1>>|encode_unconstrained_number(Enc2@element)]
end
end|begin
%% attribute locTimeStampRate(2) with type INTEGER
Enc4@element = element(3, Val),
Enc4@element@sub = Enc4@element - 1,
if 0 =< Enc4@element@sub, Enc4@element@sub < 10 ->
<<0:1,Enc4@element@sub:4>>;
true ->
[<<1:1>>|encode_unconstrained_number(Enc4@element)]
end
end].


dec_TumInstructions(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute maxNumOfLocTimeStamps(1) with type INTEGER
{Term1,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:3,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
<<V2@V10:V2@V3/signed-unit:8,V2@Buf11/bitstring>> = V2@Buf4,
{V2@V10,V2@Buf11}
end,
{V2@V0,V2@Buf1}
end,

%% attribute locTimeStampRate(2) with type INTEGER
{Term2,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:4,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
<<V3@V10:V3@V3/signed-unit:8,V3@Buf11/bitstring>> = V3@Buf4,
{V3@V10,V3@Buf11}
end,
{V3@V0,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'TumInstructions',Term1,Term2},
{Res1,Bytes5}.

enc_AckPolicy(Val) ->
[begin
%% attribute timeout(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - 100,
if 0 =< Enc2@element@sub, Enc2@element@sub < 9901 ->
<<0:1,Enc2@element@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute numOfRetries(2) with type INTEGER
Enc4@element = element(3, Val),
Enc4@element@sub = Enc4@element - 1,
if 0 =< Enc4@element@sub, Enc4@element@sub < 5 ->
<<0:1,Enc4@element@sub:3>>;
true ->
[<<1:1>>|encode_unconstrained_number(Enc4@element)]
end
end].


dec_AckPolicy(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute timeout(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:14,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 100,
{V2@Add2,V2@Buf1}
end,

%% attribute numOfRetries(2) with type INTEGER
{Term2,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:3,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
<<V3@V10:V3@V3/signed-unit:8,V3@Buf11/bitstring>> = V3@Buf4,
{V3@V10,V3@Buf11}
end,
{V3@V0,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'AckPolicy',Term1,Term2},
{Res1,Bytes5}.

enc_TollChargesTable(Val) ->
[<<0:1>>|begin
%% attribute tollTypeCharge(1) with type CHOICE
Enc2@element = element(2, Val),
enc_TollChargesTable_tollTypeCharge(Enc2@element)
end].
enc_TollChargesTable_tollTypeCharge(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= pointCharges ->
[<<0:1,0:2>>|enc_ChargesTable(ChoiceVal)];
ChoiceTag =:= perLaneCharges ->
[<<0:1,1:2>>|enc_TollChargesTable_tollTypeCharge_perLaneCharges(ChoiceVal)];
ChoiceTag =:= closedNetworkCharges ->
[<<0:1,2:2>>|enc_TollChargesTable_tollTypeCharge_closedNetworkCharges(ChoiceVal)];
ChoiceTag =:= timeBasedCharges ->
[<<0:1,3:2>>|enc_TimeChargesTable(ChoiceVal)]
end.
enc_TollChargesTable_tollTypeCharge_perLaneCharges(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if Enc1@len@sub bsr 6 =:= 0 ->
<<0:1,Enc1@len@sub:6>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_LaneChargesTable(Comp) || Comp <- Val]].

enc_TollChargesTable_tollTypeCharge_closedNetworkCharges(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if Enc1@len@sub bsr 6 =:= 0 ->
<<0:1,Enc1@len@sub:6>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_ClosedNetworkChargesTable(Comp) || Comp <- Val]].



dec_TollChargesTable(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tollTypeCharge(1) with type CHOICE
{Term1,Bytes2} = dec_TollChargesTable_tollTypeCharge(Bytes1),

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = {'TollChargesTable',Term1},
{Res1,Bytes4}.


dec_TollChargesTable_tollTypeCharge(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_ChargesTable(Bytes2)
end,
{{pointCharges,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_TollChargesTable_tollTypeCharge_perLaneCharges(Bytes2)
end,
{{perLaneCharges,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_TollChargesTable_tollTypeCharge_closedNetworkCharges(Bytes2)
end,
{{closedNetworkCharges,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
dec_TimeChargesTable(Bytes2)
end,
{{timeBasedCharges,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.

dec_TollChargesTable_tollTypeCharge_perLaneCharges(Bytes) ->
%% Length with constraint {{1,64},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components1(V1@V0, V1@Buf1, []).


dec_TollChargesTable_tollTypeCharge_closedNetworkCharges(Bytes) ->
%% Length with constraint {{1,64},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components2(V1@V0, V1@Buf1, []).

enc_LaneChargesTable(Val) ->
[begin
%% attribute laneId(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 8 =:= 0 ->
[<<0:1,Enc2@element:8>>];
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute chargesTable(2) with type ChargesTable
Enc4@element = element(3, Val),
enc_ChargesTable(Enc4@element)
end].


dec_LaneChargesTable(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute laneId(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute chargesTable(2) with type ChargesTable
{Term2,Bytes3} = dec_ChargesTable(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'LaneChargesTable',Term1,Term2},
{Res1,Bytes5}.

enc_ClosedNetworkChargesTable(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= entryChargesTable ->
[<<0:1,0:1>>|enc_EntryChargesTable(ChoiceVal)];
ChoiceTag =:= exitChargesTable ->
[<<0:1,1:1>>|enc_ExitChargesTable(ChoiceVal)]
end.


dec_ClosedNetworkChargesTable(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_EntryChargesTable(Bytes2)
end,
{{entryChargesTable,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_ExitChargesTable(Bytes2)
end,
{{exitChargesTable,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_EntryChargesTable(Val) ->
[<<0:1>>,
begin
%% attribute exitInfo(1) with type ExitInfo
Enc2@element = element(2, Val),
enc_ExitInfo(Enc2@element)
end|begin
%% attribute chargesTable(2) with type ChargesTable
Enc3@element = element(3, Val),
enc_ChargesTable(Enc3@element)
end].


dec_EntryChargesTable(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute exitInfo(1) with type ExitInfo
{Term1,Bytes2} = dec_ExitInfo(Bytes1),

%% attribute chargesTable(2) with type ChargesTable
{Term2,Bytes3} = dec_ChargesTable(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V2@V0,V2@Buf1} = case Bytes3 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'EntryChargesTable',Term1,Term2},
{Res1,Bytes5}.

enc_ExitChargesTable(Val) ->
[begin
Enc1@element = element(2, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute entryInfo(1) with type INTEGER
Enc3@element = element(2, Val),
if Enc3@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc3@element@sub = Enc3@element - 1,
if Enc3@element@sub bsr 11 =:= 0 ->
<<Enc3@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end
end
end|begin
%% attribute chargesTable(2) with type ChargesTable
Enc6@element = element(3, Val),
enc_ChargesTable(Enc6@element)
end].


dec_ExitChargesTable(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute entryInfo(1) with type INTEGER
{Term1,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:11,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute chargesTable(2) with type ChargesTable
{Term2,Bytes4} = dec_ChargesTable(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V4@V0,V4@Buf1} = case Bytes4 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'ExitChargesTable',Term1,Term2},
{Res1,Bytes6}.

enc_ExitInfo(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute exitNumber(1) with type INTEGER
Enc4@element = element(2, Val),
Enc4@element@sub = Enc4@element - 1,
if 0 =< Enc4@element@sub, Enc4@element@sub < 999 ->
<<0:1,Enc4@element@sub:10>>;
true ->
[<<1:1>>|encode_unconstrained_number(Enc4@element)]
end
end,
begin
%% attribute exitLetter(2) with type INTEGER
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc6@element@sub = Enc6@element - 65,
if 0 =< Enc6@element@sub, Enc6@element@sub < 26 ->
<<Enc6@element@sub:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end
end
end|begin
%% attribute tollPointID(3) with type INTEGER
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc9@element@sub = Enc9@element - 1,
if Enc9@element@sub bsr 11 =:= 0 ->
<<Enc9@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end
end
end].


dec_ExitInfo(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute exitNumber(1) with type INTEGER
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:10,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
<<V3@V10:V3@V3/signed-unit:8,V3@Buf11/bitstring>> = V3@Buf4,
{V3@V10,V3@Buf11}
end,
{V3@V0,V3@Buf1}
end,

%% attribute exitLetter(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:5,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 65,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute tollPointID(3) with type INTEGER
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:11,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'ExitInfo',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_TimeChargesTable(Val) ->
[begin
%% attribute maxTime(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - 1,
if 0 =< Enc2@element@sub, Enc2@element@sub < 1440 ->
<<0:1,Enc2@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute chargesTable(2) with type ChargesTable
Enc4@element = element(3, Val),
enc_ChargesTable(Enc4@element)
end].


dec_TimeChargesTable(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute maxTime(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:11,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,

%% attribute chargesTable(2) with type ChargesTable
{Term2,Bytes3} = dec_ChargesTable(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'TimeChargesTable',Term1,Term2},
{Res1,Bytes5}.

enc_ChargesTable(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= vehTypeBased ->
[<<0:1,0:2>>|enc_VehTypeChargesTable(ChoiceVal)];
ChoiceTag =:= numAxlesBased ->
[<<0:1,1:2>>|enc_AxlesChargesTable(ChoiceVal)];
ChoiceTag =:= weightBased ->
[<<0:1,2:2>>|enc_WeightChargesTable(ChoiceVal)]
end.


dec_ChargesTable(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_VehTypeChargesTable(Bytes2)
end,
{{vehTypeBased,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_AxlesChargesTable(Bytes2)
end,
{{numAxlesBased,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_WeightChargesTable(Bytes2)
end,
{{weightBased,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_VehTypeChargesTable(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if 0 =< Enc1@len@sub, Enc1@len@sub < 13 ->
<<0:1,Enc1@len@sub:4>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_VehTypeCharges(Comp) || Comp <- Val]].



dec_VehTypeChargesTable(Bytes) ->
%% Length with constraint {{1,13},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components3(V1@V0, V1@Buf1, []).

enc_VehTypeCharges(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute vehType(1) with type ENUMERATED
Enc3@element = element(2, Val),
if Enc3@element =:= motorcycles ->
<<0:1,0:4>>;
Enc3@element =:= passengerCars ->
<<0:1,1:4>>;
Enc3@element =:= fourTireSingleUnit ->
<<0:1,2:4>>;
Enc3@element =:= buses ->
<<0:1,3:4>>;
Enc3@element =:= twoAxleSixTireSingleUnit ->
<<0:1,4:4>>;
Enc3@element =:= threeAxleSingleUnit ->
<<0:1,5:4>>;
Enc3@element =:= fourOrMoreAxleSingleUnit ->
<<0:1,6:4>>;
Enc3@element =:= fourOrLessAxleSingleTrailer ->
<<0:1,7:4>>;
Enc3@element =:= fiveAxleTractorSemitrailer ->
<<0:1,8:4>>;
Enc3@element =:= sixOrMoreAxleSingleTrailer ->
<<0:1,9:4>>;
Enc3@element =:= fiveOrLessAxleMultiTrailer ->
<<0:1,10:4>>;
Enc3@element =:= sixAxleMultiTrailer ->
<<0:1,11:4>>;
Enc3@element =:= sevenOrMoreAxleMultiTrailer ->
<<0:1,12:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc3@element}}})
end
end,
begin
%% attribute charges(2) with type PaymentFee
Enc5@element = element(3, Val),
'EfcDataDictionary':enc_PaymentFee(Enc5@element)
end|begin
%% attribute specialCharges(3) with type SpecialCharges
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
enc_SpecialCharges(Enc6@element)
end
end].


dec_VehTypeCharges(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute vehType(1) with type ENUMERATED
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:4,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> motorcycles;
1 -> passengerCars;
2 -> fourTireSingleUnit;
3 -> buses;
4 -> twoAxleSixTireSingleUnit;
5 -> threeAxleSingleUnit;
6 -> fourOrMoreAxleSingleUnit;
7 -> fourOrLessAxleSingleTrailer;
8 -> fiveAxleTractorSemitrailer;
9 -> sixOrMoreAxleSingleTrailer;
10 -> fiveOrLessAxleMultiTrailer;
11 -> sixAxleMultiTrailer;
12 -> sevenOrMoreAxleMultiTrailer;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11};
<<1:1,1:1,V3@V10:6,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
V3@Mul12 = V3@V10 * 16384,
{V3@Mul12,V3@Buf11}
end,
<<V3@V13:V3@V6/unit:8,V3@Buf14/bitstring>> = V3@Buf7,
{V3@V13,V3@Buf14}
end,
V3@Int15 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int15,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,

%% attribute charges(2) with type PaymentFee
{Term2,Bytes4} = 'EfcDataDictionary':dec_PaymentFee(Bytes3),

%% attribute specialCharges(3) with type SpecialCharges
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_SpecialCharges(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V4@V0,V4@Buf1} = case Bytes5 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'VehTypeCharges',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_VehicleTypes(Val) ->
if Val =:= motorcycles ->
<<0:1,0:4>>;
Val =:= passengerCars ->
<<0:1,1:4>>;
Val =:= fourTireSingleUnit ->
<<0:1,2:4>>;
Val =:= buses ->
<<0:1,3:4>>;
Val =:= twoAxleSixTireSingleUnit ->
<<0:1,4:4>>;
Val =:= threeAxleSingleUnit ->
<<0:1,5:4>>;
Val =:= fourOrMoreAxleSingleUnit ->
<<0:1,6:4>>;
Val =:= fourOrLessAxleSingleTrailer ->
<<0:1,7:4>>;
Val =:= fiveAxleTractorSemitrailer ->
<<0:1,8:4>>;
Val =:= sixOrMoreAxleSingleTrailer ->
<<0:1,9:4>>;
Val =:= fiveOrLessAxleMultiTrailer ->
<<0:1,10:4>>;
Val =:= sixAxleMultiTrailer ->
<<0:1,11:4>>;
Val =:= sevenOrMoreAxleMultiTrailer ->
<<0:1,12:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_VehicleTypes(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> motorcycles;
1 -> passengerCars;
2 -> fourTireSingleUnit;
3 -> buses;
4 -> twoAxleSixTireSingleUnit;
5 -> threeAxleSingleUnit;
6 -> fourOrMoreAxleSingleUnit;
7 -> fourOrLessAxleSingleTrailer;
8 -> fiveAxleTractorSemitrailer;
9 -> sixOrMoreAxleSingleTrailer;
10 -> fiveOrLessAxleMultiTrailer;
11 -> sixAxleMultiTrailer;
12 -> sevenOrMoreAxleMultiTrailer;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_SpecialCharges(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
if Enc7@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute hov2Charge(1) with type PaymentFee
Enc9@element = element(2, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc9@element)
end
end,
begin
%% attribute hov3Charge(2) with type PaymentFee
Enc11@element = element(3, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc11@element)
end
end,
begin
%% attribute hov4Charge(3) with type PaymentFee
Enc13@element = element(4, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc13@element)
end
end,
begin
%% attribute hov5PlusCharge(4) with type PaymentFee
Enc15@element = element(5, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc15@element)
end
end,
begin
%% attribute cleanAirCharge(5) with type PaymentFee
Enc17@element = element(6, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc17@element)
end
end,
begin
%% attribute operatorDefined(6) with type OperatorDefined
Enc19@element = element(7, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
enc_OperatorDefined(Enc19@element)
end
end|begin
%% attribute engineCharacteristics(7) with type INTEGER
Enc21@element = element(8, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
Enc21@element =:= noEntry ->
[0];
Enc21@element =:= noEngine ->
[1];
Enc21@element =:= petrolUnleaded ->
[2];
Enc21@element =:= petrolLeaded ->
[3];
Enc21@element =:= diesel ->
[4];
Enc21@element =:= lpg ->
[5];
Enc21@element =:= battery ->
[6];
Enc21@element =:= solar ->
[7];
Enc21@element =:= hybrid ->
[8];
Enc21@element =:= hydrogen ->
[9];
Enc21@element =:= multiFuel ->
[10];
Enc21@element =:= bivalentPetrolLpg ->
[11];
Enc21@element =:= bivalentPetrolCng ->
[12];
Enc21@element =:= combinedPetrolElectric ->
[13];
Enc21@element =:= cng ->
[14];
Enc21@element =:= lng ->
[15];
Enc21@element =:= combinedDieselElectric ->
[16];
Enc21@element =:= combinedHydrogenElectric ->
[17];
Enc21@element =:= bivalentHydrogenPetrol ->
[18];
Enc21@element =:= bivalentHydrogenPetrolElectricEngine ->
[19];
Enc21@element =:= fuelCellHydrogen ->
[20];
Enc21@element =:= fuelCellPetrol ->
[21];
Enc21@element =:= fuelCellMethanol ->
[22];
Enc21@element =:= fuelCellEthanol ->
[23];
Enc21@element =:= fuelCellDiesel ->
[24];
Enc21@element =:= combinedMultiFuelElectricEngine ->
[25];
Enc21@element =:= combinedCngElectricEngine ->
[26];
Enc21@element =:= combinedLngElectricEngine ->
[27];
Enc21@element =:= petrolEthanol ->
[28];
Enc21@element =:= combinedLpgElectricEngine ->
[29];
Enc21@element =:= hybridPetrolExternalBattery ->
[30];
Enc21@element =:= hybridDieselExternalBattery ->
[31];
Enc21@element =:= hybridLpgExternalBattery ->
[32];
Enc21@element =:= hybridHydrogenExternalBattery ->
[33];
Enc21@element =:= hybridMultiFuelExternalBattery ->
[34];
Enc21@element =:= hybridCngExternalBattery ->
[35];
Enc21@element =:= hybridLngExternalBattery ->
[36];
Enc21@element =:= hybridBivalentHydrogenPetrolExternalBattery ->
[37];
Enc21@element =:= hydrogenCng ->
[38];
Enc21@element =:= hydrogenLng ->
[39];
Enc21@element =:= hybridHydrogenCngExternalBattery ->
[40];
Enc21@element =:= hybridHydrogenLngExternalBattery ->
[41];
Enc21@element =:= ethanol ->
[42];
Enc21@element =:= hybridFuelCellHydrogen ->
[43];
Enc21@element =:= hybridFuelCellHydrogenExternalBattery ->
[44];
Enc21@element =:= dualFuelLngDiesel ->
[45];
Enc21@element =:= electricExternal ->
[46];
Enc21@element =:= biogas ->
[47];
Enc21@element =:= bioDiesel ->
[48];
Enc21@element =:= bioPetrol ->
[49];
Enc21@element =:= bivalentPetrolBiogas ->
[50];
Enc21@element =:= combinedBiogasElectricEngine ->
[51];
Enc21@element =:= dualFuelCngDiesel ->
[52];
Enc21@element =:= other ->
[255];
Enc21@element bsr 8 =:= 0 ->
[Enc21@element];
true ->
exit({error,{asn1,{illegal_integer,Enc21@element}}})
end
end].


dec_SpecialCharges(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute hov2Charge(1) with type PaymentFee
{Term1,Bytes3} = case (Opt bsr 6) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute hov3Charge(2) with type PaymentFee
{Term2,Bytes4} = case (Opt bsr 5) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute hov4Charge(3) with type PaymentFee
{Term3,Bytes5} = case (Opt bsr 4) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute hov5PlusCharge(4) with type PaymentFee
{Term4,Bytes6} = case (Opt bsr 3) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute cleanAirCharge(5) with type PaymentFee
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute operatorDefined(6) with type OperatorDefined
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
dec_OperatorDefined(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute engineCharacteristics(7) with type INTEGER
{Term7,Bytes9} = case Opt band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes8,
V3@Int2 = case V3@V0 of
0 -> noEntry;
1 -> noEngine;
2 -> petrolUnleaded;
3 -> petrolLeaded;
4 -> diesel;
5 -> lpg;
6 -> battery;
7 -> solar;
8 -> hybrid;
9 -> hydrogen;
10 -> multiFuel;
11 -> bivalentPetrolLpg;
12 -> bivalentPetrolCng;
13 -> combinedPetrolElectric;
14 -> cng;
15 -> lng;
16 -> combinedDieselElectric;
17 -> combinedHydrogenElectric;
18 -> bivalentHydrogenPetrol;
19 -> bivalentHydrogenPetrolElectricEngine;
20 -> fuelCellHydrogen;
21 -> fuelCellPetrol;
22 -> fuelCellMethanol;
23 -> fuelCellEthanol;
24 -> fuelCellDiesel;
25 -> combinedMultiFuelElectricEngine;
26 -> combinedCngElectricEngine;
27 -> combinedLngElectricEngine;
28 -> petrolEthanol;
29 -> combinedLpgElectricEngine;
30 -> hybridPetrolExternalBattery;
31 -> hybridDieselExternalBattery;
32 -> hybridLpgExternalBattery;
33 -> hybridHydrogenExternalBattery;
34 -> hybridMultiFuelExternalBattery;
35 -> hybridCngExternalBattery;
36 -> hybridLngExternalBattery;
37 -> hybridBivalentHydrogenPetrolExternalBattery;
38 -> hydrogenCng;
39 -> hydrogenLng;
40 -> hybridHydrogenCngExternalBattery;
41 -> hybridHydrogenLngExternalBattery;
42 -> ethanol;
43 -> hybridFuelCellHydrogen;
44 -> hybridFuelCellHydrogenExternalBattery;
45 -> dualFuelLngDiesel;
46 -> electricExternal;
47 -> biogas;
48 -> bioDiesel;
49 -> bioPetrol;
50 -> bivalentPetrolBiogas;
51 -> combinedBiogasElectricEngine;
52 -> dualFuelCngDiesel;
255 -> other;
_ -> V3@V0
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% Extensions
{Extensions,Bytes10} = case Ext of
0 -> {<<>>,Bytes9};
1 ->
{V4@V0,V4@Buf1} = case Bytes9 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes11= skipextensions(Bytes10, 1, Extensions),
Res1 = {'SpecialCharges',Term1,Term2,Term3,Term4,Term5,Term6,Term7},
{Res1,Bytes11}.

enc_OperatorDefined(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc11@element = element(12, Val),
Enc12@element = element(13, Val),
if Enc11@element =:= asn1_NOVALUE ->
if Enc12@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc12@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc13@element = element(14, Val),
Enc14@element = element(15, Val),
if Enc13@element =:= asn1_NOVALUE ->
if Enc14@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc14@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc15@element = element(16, Val),
Enc16@element = element(17, Val),
if Enc15@element =:= asn1_NOVALUE ->
if Enc16@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc16@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute opDefCharge1(1) with type PaymentFee
Enc18@element = element(2, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc18@element)
end
end,
begin
%% attribute opDefCharge2(2) with type PaymentFee
Enc20@element = element(3, Val),
if Enc20@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc20@element)
end
end,
begin
%% attribute opDefCharge3(3) with type PaymentFee
Enc22@element = element(4, Val),
if Enc22@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc22@element)
end
end,
begin
%% attribute opDefCharge4(4) with type PaymentFee
Enc24@element = element(5, Val),
if Enc24@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc24@element)
end
end,
begin
%% attribute opDefCharge5(5) with type PaymentFee
Enc26@element = element(6, Val),
if Enc26@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc26@element)
end
end,
begin
%% attribute opDefCharge6(6) with type PaymentFee
Enc28@element = element(7, Val),
if Enc28@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc28@element)
end
end,
begin
%% attribute opDefCharge7(7) with type PaymentFee
Enc30@element = element(8, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc30@element)
end
end,
begin
%% attribute opDefCharge8(8) with type PaymentFee
Enc32@element = element(9, Val),
if Enc32@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc32@element)
end
end,
begin
%% attribute opDefCharge9(9) with type PaymentFee
Enc34@element = element(10, Val),
if Enc34@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc34@element)
end
end,
begin
%% attribute opDefCharge10(10) with type PaymentFee
Enc36@element = element(11, Val),
if Enc36@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc36@element)
end
end,
begin
%% attribute opDefCharge11(11) with type PaymentFee
Enc38@element = element(12, Val),
if Enc38@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc38@element)
end
end,
begin
%% attribute opDefCharge12(12) with type PaymentFee
Enc40@element = element(13, Val),
if Enc40@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc40@element)
end
end,
begin
%% attribute opDefCharge13(13) with type PaymentFee
Enc42@element = element(14, Val),
if Enc42@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc42@element)
end
end,
begin
%% attribute opDefCharge14(14) with type PaymentFee
Enc44@element = element(15, Val),
if Enc44@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc44@element)
end
end,
begin
%% attribute opDefCharge15(15) with type PaymentFee
Enc46@element = element(16, Val),
if Enc46@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc46@element)
end
end|begin
%% attribute opDefCharge16(16) with type PaymentFee
Enc48@element = element(17, Val),
if Enc48@element =:= asn1_NOVALUE ->
[];
true ->
'EfcDataDictionary':enc_PaymentFee(Enc48@element)
end
end].


dec_OperatorDefined(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute opDefCharge1(1) with type PaymentFee
{Term1,Bytes3} = case (Opt bsr 15) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute opDefCharge2(2) with type PaymentFee
{Term2,Bytes4} = case (Opt bsr 14) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute opDefCharge3(3) with type PaymentFee
{Term3,Bytes5} = case (Opt bsr 13) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute opDefCharge4(4) with type PaymentFee
{Term4,Bytes6} = case (Opt bsr 12) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute opDefCharge5(5) with type PaymentFee
{Term5,Bytes7} = case (Opt bsr 11) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute opDefCharge6(6) with type PaymentFee
{Term6,Bytes8} = case (Opt bsr 10) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute opDefCharge7(7) with type PaymentFee
{Term7,Bytes9} = case (Opt bsr 9) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute opDefCharge8(8) with type PaymentFee
{Term8,Bytes10} = case (Opt bsr 8) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute opDefCharge9(9) with type PaymentFee
{Term9,Bytes11} = case (Opt bsr 7) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute opDefCharge10(10) with type PaymentFee
{Term10,Bytes12} = case (Opt bsr 6) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute opDefCharge11(11) with type PaymentFee
{Term11,Bytes13} = case (Opt bsr 5) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes12);
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute opDefCharge12(12) with type PaymentFee
{Term12,Bytes14} = case (Opt bsr 4) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes13);
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% attribute opDefCharge13(13) with type PaymentFee
{Term13,Bytes15} = case (Opt bsr 3) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes14);
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% attribute opDefCharge14(14) with type PaymentFee
{Term14,Bytes16} = case (Opt bsr 2) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes15);
0 ->
{asn1_NOVALUE,Bytes15}
end,

%% attribute opDefCharge15(15) with type PaymentFee
{Term15,Bytes17} = case (Opt bsr 1) band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes16);
0 ->
{asn1_NOVALUE,Bytes16}
end,

%% attribute opDefCharge16(16) with type PaymentFee
{Term16,Bytes18} = case Opt band 1 of
1 ->
'EfcDataDictionary':dec_PaymentFee(Bytes17);
0 ->
{asn1_NOVALUE,Bytes17}
end,

%% Extensions
{Extensions,Bytes19} = case Ext of
0 -> {<<>>,Bytes18};
1 ->
{V3@V0,V3@Buf1} = case Bytes18 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes20= skipextensions(Bytes19, 1, Extensions),
Res1 = {'OperatorDefined',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13,Term14,Term15,Term16},
{Res1,Bytes20}.

enc_WeightChargesTable(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if 0 =< Enc1@len@sub, Enc1@len@sub < 10 ->
<<0:1,Enc1@len@sub:4>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_WeightCharges(Comp) || Comp <- Val]].



dec_WeightChargesTable(Bytes) ->
%% Length with constraint {{1,10},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components4(V1@V0, V1@Buf1, []).

enc_WeightCharges(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= totalWeightCharges ->
[<<0:1,0:1>>|enc_TotalWeightCharges(ChoiceVal)];
ChoiceTag =:= perAxleWeightCharges ->
[<<0:1,1:1>>|enc_PerAxleWeightCharges(ChoiceVal)]
end.


dec_WeightCharges(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_TotalWeightCharges(Bytes2)
end,
{{totalWeightCharges,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_PerAxleWeightCharges(Bytes2)
end,
{{perAxleWeightCharges,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_TotalWeightCharges(Val) ->
[begin
%% attribute weightLimit(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 24 =:= 0 ->
<<0:1,Enc2@element:24>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute weightLimitUnits(2) with type ENUMERATED
Enc4@element = element(3, Val),
if Enc4@element =:= pounds ->
<<0:1,0:1>>;
Enc4@element =:= kilograms ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc4@element}}})
end
end|begin
%% attribute weightCharge(3) with type PaymentFee
Enc6@element = element(4, Val),
'EfcDataDictionary':enc_PaymentFee(Enc6@element)
end].


dec_TotalWeightCharges(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute weightLimit(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:24,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute weightLimitUnits(2) with type ENUMERATED
{Term2,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:1,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> pounds;
1 -> kilograms
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11};
<<1:1,1:1,V3@V10:6,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
V3@Mul12 = V3@V10 * 16384,
{V3@Mul12,V3@Buf11}
end,
<<V3@V13:V3@V6/unit:8,V3@Buf14/bitstring>> = V3@Buf7,
{V3@V13,V3@Buf14}
end,
V3@Int15 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int15,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,

%% attribute weightCharge(3) with type PaymentFee
{Term3,Bytes4} = 'EfcDataDictionary':dec_PaymentFee(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V4@V0,V4@Buf1} = case Bytes4 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'TotalWeightCharges',Term1,Term2,Term3},
{Res1,Bytes6}.

enc_PerAxleWeightCharges(Val) ->
[begin
%% attribute totalWeightLimit(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 24 =:= 0 ->
<<0:1,Enc2@element:24>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute maxLadenWeightOnAxle(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element bsr 16 =:= 0 ->
<<Enc4@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end,
begin
%% attribute weightLimitUnits(3) with type ENUMERATED
Enc6@element = element(4, Val),
if Enc6@element =:= pounds ->
<<0:1,0:1>>;
Enc6@element =:= kilograms ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc6@element}}})
end
end|begin
%% attribute axleWeightCharge(4) with type PaymentFee
Enc8@element = element(5, Val),
'EfcDataDictionary':enc_PaymentFee(Enc8@element)
end].


dec_PerAxleWeightCharges(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute totalWeightLimit(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:24,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute maxLadenWeightOnAxle(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute weightLimitUnits(3) with type ENUMERATED
{Term3,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:1,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> pounds;
1 -> kilograms
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11};
<<1:1,1:1,V4@V10:6,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
V4@Mul12 = V4@V10 * 16384,
{V4@Mul12,V4@Buf11}
end,
<<V4@V13:V4@V6/unit:8,V4@Buf14/bitstring>> = V4@Buf7,
{V4@V13,V4@Buf14}
end,
V4@Int15 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int15,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end,

%% attribute axleWeightCharge(4) with type PaymentFee
{Term4,Bytes5} = 'EfcDataDictionary':dec_PaymentFee(Bytes4),

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V5@V0,V5@Buf1} = case Bytes5 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'PerAxleWeightCharges',Term1,Term2,Term3,Term4},
{Res1,Bytes7}.

enc_AxlesChargesTable(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 2,
[if 0 =< Enc1@len@sub, Enc1@len@sub < 9 ->
<<0:1,Enc1@len@sub:4>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_AxlesCharges(Comp) || Comp <- Val]].



dec_AxlesChargesTable(Bytes) ->
%% Length with constraint {{2,10},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 2,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components5(V1@V0, V1@Buf1, []).

enc_AxlesCharges(Val) ->
[begin
%% attribute axlesLimit(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - 2,
if 0 =< Enc2@element@sub, Enc2@element@sub < 9 ->
<<0:1,0:1,Enc2@element@sub:4>>;
true ->
[<<0:1,1:1>>|encode_unconstrained_number(Enc2@element)]
end
end|begin
%% attribute axlesCharge(2) with type PaymentFee
Enc4@element = element(3, Val),
'EfcDataDictionary':enc_PaymentFee(Enc4@element)
end].


dec_AxlesCharges(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute axlesLimit(1) with type INTEGER
{Term1,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:4,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 2,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
<<V2@V10:V2@V3/signed-unit:8,V2@Buf11/bitstring>> = V2@Buf4,
{V2@V10,V2@Buf11}
end,
{V2@V0,V2@Buf1}
end,

%% attribute axlesCharge(2) with type PaymentFee
{Term2,Bytes3} = 'EfcDataDictionary':dec_PaymentFee(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'AxlesCharges',Term1,Term2},
{Res1,Bytes5}.

enc_TollPointMap(Val) ->
[begin
%% attribute revisionNum(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - 1,
if 0 =< Enc2@element@sub, Enc2@element@sub < 10 ->
<<0:1,0:1,Enc2@element@sub:4>>;
true ->
[<<0:1,1:1>>|encode_unconstrained_number(Enc2@element)]
end
end,
begin
%% attribute referencePoint(2) with type Position3D
Enc4@element = element(3, Val),
'Common':enc_Position3D(Enc4@element)
end,
begin
%% attribute speedLimit(3) with type RegulatorySpeedLimit
Enc5@element = element(4, Val),
'Common':enc_RegulatorySpeedLimit(Enc5@element)
end,
begin
%% attribute laneWidth(4) with type INTEGER
Enc6@element = element(5, Val),
if Enc6@element bsr 15 =:= 0 ->
<<Enc6@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end,
begin
%% attribute approachLanesMap(5) with type SEQUENCE OF
Enc8@element = element(6, Val),
enc_TollPointMap_approachLanesMap(Enc8@element)
end|begin
%% attribute tollZoneLanesMap(6) with type SEQUENCE OF
Enc9@element = element(7, Val),
enc_TollPointMap_tollZoneLanesMap(Enc9@element)
end].
enc_TollPointMap_approachLanesMap(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if Enc1@len@sub bsr 6 =:= 0 ->
<<0:1,Enc1@len@sub:6>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|['MapData':enc_GenericLane(Comp) || Comp <- Val]].

enc_TollPointMap_tollZoneLanesMap(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if Enc1@len@sub bsr 6 =:= 0 ->
<<0:1,Enc1@len@sub:6>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|['MapData':enc_GenericLane(Comp) || Comp <- Val]].



dec_TollPointMap(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute revisionNum(1) with type INTEGER
{Term1,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:4,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
<<V2@V10:V2@V3/signed-unit:8,V2@Buf11/bitstring>> = V2@Buf4,
{V2@V10,V2@Buf11}
end,
{V2@V0,V2@Buf1}
end,

%% attribute referencePoint(2) with type Position3D
{Term2,Bytes3} = 'Common':dec_Position3D(Bytes2),

%% attribute speedLimit(3) with type RegulatorySpeedLimit
{Term3,Bytes4} = 'Common':dec_RegulatorySpeedLimit(Bytes3),

%% attribute laneWidth(4) with type INTEGER
{Term4,Bytes5} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes4,
{V3@V0,V3@Buf1}
end,

%% attribute approachLanesMap(5) with type SEQUENCE OF
{Term5,Bytes6} = dec_TollPointMap_approachLanesMap(Bytes5),

%% attribute tollZoneLanesMap(6) with type SEQUENCE OF
{Term6,Bytes7} = dec_TollPointMap_tollZoneLanesMap(Bytes6),

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V4@V0,V4@Buf1} = case Bytes7 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'TollPointMap',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes9}.


dec_TollPointMap_approachLanesMap(Bytes) ->
%% Length with constraint {{1,64},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components6(V1@V0, V1@Buf1, []).


dec_TollPointMap_tollZoneLanesMap(Bytes) ->
%% Length with constraint {{1,64},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components7(V1@V0, V1@Buf1, []).

enc_TollChargerInfo(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute tollChargerId(1) with type OBJECT IDENTIFIER
Enc3@element = element(2, Val),
Enc4@bin = encode_oid(Enc3@element),
Enc4@len = byte_size(Enc4@bin),
if Enc4@len < 128 ->
[Enc4@len|Enc4@bin];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc4@bin];
true ->
encode_fragmented(Enc4@bin, 8)
end
end,
begin
%% attribute tollPointId(2) with type INTEGER
Enc5@element = element(3, Val),
Enc5@element@sub = Enc5@element - 1,
if Enc5@element@sub bsr 11 =:= 0 ->
<<Enc5@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end|begin
%% attribute descriptiveName(3) with type IA5String
Enc7@element = element(4, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc8@len = length(Enc7@element),
Enc8@bin = encode_chars(Enc7@element, 7),
Enc8@len@sub = Enc8@len - 1,
if 0 =< Enc8@len@sub, Enc8@len@sub < 63 ->
[<<Enc8@len@sub:6>>|Enc8@bin]
end
end
end
end].


dec_TollChargerInfo(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tollChargerId(1) with type OBJECT IDENTIFIER
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@Buf4/bitstring>> ->
{V3@V3,V3@Buf4};
<<1:1,0:1,V3@V4:14,V3@Buf5/bitstring>> ->
{V3@V4,V3@Buf5};
<<1:1,1:1,V3@V4:6,V3@Buf5/bitstring>> ->
V3@Mul6 = V3@V4 * 16384,
{V3@Mul6,V3@Buf5}
end,
<<V3@V7:V3@V0/binary-unit:8,V3@Buf8/bitstring>> = V3@Buf1,
V3@Conv9 = binary_to_list(V3@V7),
{V3@V10,V3@Buf11}  = {decode_oid(V3@Conv9),V3@Buf8},
{V3@V10,V3@Buf11}
end,

%% attribute tollPointId(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:11,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end,

%% attribute descriptiveName(3) with type IA5String
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:6,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
<<V5@V3:V5@Add2/binary-unit:7,V5@Buf4/bitstring>> = V5@Buf1,
{V5@V5,V5@Buf6}  = {decode_chars(V5@V3, 7),V5@Buf4},
{V5@V5,V5@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'TollChargerInfo',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_TollPointID(Val) ->
Val@sub = Val - 1,
if Val@sub bsr 11 =:= 0 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TollPointID(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

typeinfo('TollAdvertisementMessage') ->
  {sequence,'TollAdvertisementMessage',2,[{<<116,111,108,108,67,104,97,114,103,101,115,84,97,98,108,101>>,{typeinfo,{'TollAdvertisementMessage','TollChargesTable'}},mandatory},{<<116,111,108,108,65,100,118,73,110,102,111>>,{typeinfo,{'TollAdvertisementMessage','TollAdvertisementInfo'}},'OPTIONAL'}]};
typeinfo('TollAdvertisementInfo') ->
  {sequence,'TollAdvertisementInfo',10,[{<<116,97,109,83,101,113,117,101,110,99,101,78,117,109>>,{'INTEGER',{0,127}},mandatory},{<<116,111,116,97,108,84,97,109,115>>,'INTEGER',mandatory},{<<116,97,109,78,117,109>>,'INTEGER',mandatory},{<<116,111,108,108,67,104,97,114,103,101,114,73,110,102,111>>,{typeinfo,{'TollAdvertisementMessage','TollChargerInfo'}},mandatory},{<<116,105,109,101,115,116,97,109,112>>,{typeinfo,{'Common','DDateTime'}},mandatory},{<<116,117,109,73,110,115,116,114,117,99,116,105,111,110,115>>,{typeinfo,{'TollAdvertisementMessage','TumInstructions'}},'OPTIONAL'},{<<116,111,108,108,80,111,105,110,116,77,97,112>>,{typeinfo,{'TollAdvertisementMessage','TollPointMap'}},mandatory},{<<116,117,109,80,117,98,108,105,99,75,101,121>>,octet_string,mandatory},{<<97,99,107,80,111,108,105,99,121>>,{typeinfo,{'TollAdvertisementMessage','AckPolicy'}},mandatory},{<<108,97,115,116,84,111,108,108,80,116,68,97,116,97,82,101,113>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('TumInstructions') ->
  {sequence,'TumInstructions',2,[{<<109,97,120,78,117,109,79,102,76,111,99,84,105,109,101,83,116,97,109,112,115>>,'INTEGER',mandatory},{<<108,111,99,84,105,109,101,83,116,97,109,112,82,97,116,101>>,'INTEGER',mandatory}]};
typeinfo('AckPolicy') ->
  {sequence,'AckPolicy',2,[{<<116,105,109,101,111,117,116>>,{'INTEGER',{100,10000}},mandatory},{<<110,117,109,79,102,82,101,116,114,105,101,115>>,'INTEGER',mandatory}]};
typeinfo('TollChargesTable') ->
  {sequence,'TollChargesTable',1,[{<<116,111,108,108,84,121,112,101,67,104,97,114,103,101>>,{choice,#{<<99,108,111,115,101,100,78,101,116,119,111,114,107,67,104,97,114,103,101,115>> => {sof,{typeinfo,{'TollAdvertisementMessage','ClosedNetworkChargesTable'}}},<<112,101,114,76,97,110,101,67,104,97,114,103,101,115>> => {sof,{typeinfo,{'TollAdvertisementMessage','LaneChargesTable'}}},<<112,111,105,110,116,67,104,97,114,103,101,115>> => {typeinfo,{'TollAdvertisementMessage','ChargesTable'}},<<116,105,109,101,66,97,115,101,100,67,104,97,114,103,101,115>> => {typeinfo,{'TollAdvertisementMessage','TimeChargesTable'}}}},mandatory}]};
typeinfo('LaneChargesTable') ->
  {sequence,'LaneChargesTable',2,[{<<108,97,110,101,73,100>>,{'INTEGER',{0,255}},mandatory},{<<99,104,97,114,103,101,115,84,97,98,108,101>>,{typeinfo,{'TollAdvertisementMessage','ChargesTable'}},mandatory}]};
typeinfo('ClosedNetworkChargesTable') ->
  {choice,#{<<101,110,116,114,121,67,104,97,114,103,101,115,84,97,98,108,101>> => {typeinfo,{'TollAdvertisementMessage','EntryChargesTable'}},<<101,120,105,116,67,104,97,114,103,101,115,84,97,98,108,101>> => {typeinfo,{'TollAdvertisementMessage','ExitChargesTable'}}}};
typeinfo('EntryChargesTable') ->
  {sequence,'EntryChargesTable',2,[{<<101,120,105,116,73,110,102,111>>,{typeinfo,{'TollAdvertisementMessage','ExitInfo'}},mandatory},{<<99,104,97,114,103,101,115,84,97,98,108,101>>,{typeinfo,{'TollAdvertisementMessage','ChargesTable'}},mandatory}]};
typeinfo('ExitChargesTable') ->
  {sequence,'ExitChargesTable',2,[{<<101,110,116,114,121,73,110,102,111>>,{'INTEGER',{1,2048}},'OPTIONAL'},{<<99,104,97,114,103,101,115,84,97,98,108,101>>,{typeinfo,{'TollAdvertisementMessage','ChargesTable'}},mandatory}]};
typeinfo('ExitInfo') ->
  {sequence,'ExitInfo',3,[{<<101,120,105,116,78,117,109,98,101,114>>,'INTEGER',mandatory},{<<101,120,105,116,76,101,116,116,101,114>>,{'INTEGER',{65,90}},'OPTIONAL'},{<<116,111,108,108,80,111,105,110,116,73,68>>,{'INTEGER',{1,2048}},'OPTIONAL'}]};
typeinfo('TimeChargesTable') ->
  {sequence,'TimeChargesTable',2,[{<<109,97,120,84,105,109,101>>,{'INTEGER',{1,1440}},mandatory},{<<99,104,97,114,103,101,115,84,97,98,108,101>>,{typeinfo,{'TollAdvertisementMessage','ChargesTable'}},mandatory}]};
typeinfo('ChargesTable') ->
  {choice,#{<<110,117,109,65,120,108,101,115,66,97,115,101,100>> => {typeinfo,{'TollAdvertisementMessage','AxlesChargesTable'}},<<118,101,104,84,121,112,101,66,97,115,101,100>> => {typeinfo,{'TollAdvertisementMessage','VehTypeChargesTable'}},<<119,101,105,103,104,116,66,97,115,101,100>> => {typeinfo,{'TollAdvertisementMessage','WeightChargesTable'}}}};
typeinfo('VehTypeChargesTable') ->
  {sof,{typeinfo,{'TollAdvertisementMessage','VehTypeCharges'}}};
typeinfo('VehTypeCharges') ->
  {sequence,'VehTypeCharges',3,[{<<118,101,104,84,121,112,101>>,{'ENUMERATED_EXT',#{motorcycles => 1,buses => 4,passengerCars => 2,fourTireSingleUnit => 3,twoAxleSixTireSingleUnit => 5,threeAxleSingleUnit => 6,fourOrMoreAxleSingleUnit => 7,fourOrLessAxleSingleTrailer => 8,fiveAxleTractorSemitrailer => 9,sixOrMoreAxleSingleTrailer => 10,fiveOrLessAxleMultiTrailer => 11,sixAxleMultiTrailer => 12,sevenOrMoreAxleMultiTrailer => 13}},mandatory},{<<99,104,97,114,103,101,115>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},mandatory},{<<115,112,101,99,105,97,108,67,104,97,114,103,101,115>>,{typeinfo,{'TollAdvertisementMessage','SpecialCharges'}},'OPTIONAL'}]};
typeinfo('VehicleTypes') ->
  {'ENUMERATED_EXT',#{motorcycles => 1,buses => 4,passengerCars => 2,fourTireSingleUnit => 3,twoAxleSixTireSingleUnit => 5,threeAxleSingleUnit => 6,fourOrMoreAxleSingleUnit => 7,fourOrLessAxleSingleTrailer => 8,fiveAxleTractorSemitrailer => 9,sixOrMoreAxleSingleTrailer => 10,fiveOrLessAxleMultiTrailer => 11,sixAxleMultiTrailer => 12,sevenOrMoreAxleMultiTrailer => 13}};
typeinfo('SpecialCharges') ->
  {sequence,'SpecialCharges',7,[{<<104,111,118,50,67,104,97,114,103,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<104,111,118,51,67,104,97,114,103,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<104,111,118,52,67,104,97,114,103,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<104,111,118,53,80,108,117,115,67,104,97,114,103,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<99,108,101,97,110,65,105,114,67,104,97,114,103,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,101,114,97,116,111,114,68,101,102,105,110,101,100>>,{typeinfo,{'TollAdvertisementMessage','OperatorDefined'}},'OPTIONAL'},{<<101,110,103,105,110,101,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115>>,{{'INTEGER_NNL',[{noEntry,0},{noEngine,1},{petrolUnleaded,2},{petrolLeaded,3},{diesel,4},{lpg,5},{battery,6},{solar,7},{hybrid,8},{hydrogen,9},{multiFuel,10},{bivalentPetrolLpg,11},{bivalentPetrolCng,12},{combinedPetrolElectric,13},{cng,14},{lng,15},{combinedDieselElectric,16},{combinedHydrogenElectric,17},{bivalentHydrogenPetrol,18},{bivalentHydrogenPetrolElectricEngine,19},{fuelCellHydrogen,20},{fuelCellPetrol,21},{fuelCellMethanol,22},{fuelCellEthanol,23},{fuelCellDiesel,24},{combinedMultiFuelElectricEngine,25},{combinedCngElectricEngine,26},{combinedLngElectricEngine,27},{petrolEthanol,28},{combinedLpgElectricEngine,29},{hybridPetrolExternalBattery,30},{hybridDieselExternalBattery,31},{hybridLpgExternalBattery,32},{hybridHydrogenExternalBattery,33},{hybridMultiFuelExternalBattery,34},{hybridCngExternalBattery,35},{hybridLngExternalBattery,36},{hybridBivalentHydrogenPetrolExternalBattery,37},{hydrogenCng,38},{hydrogenLng,39},{hybridHydrogenCngExternalBattery,40},{hybridHydrogenLngExternalBattery,41},{ethanol,42},{hybridFuelCellHydrogen,43},{hybridFuelCellHydrogenExternalBattery,44},{dualFuelLngDiesel,45},{electricExternal,46},{biogas,47},{bioDiesel,48},{bioPetrol,49},{bivalentPetrolBiogas,50},{combinedBiogasElectricEngine,51},{dualFuelCngDiesel,52},{other,255}]},{0,255}},'OPTIONAL'}]};
typeinfo('OperatorDefined') ->
  {sequence,'OperatorDefined',16,[{<<111,112,68,101,102,67,104,97,114,103,101,49>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,50>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,51>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,52>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,53>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,54>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,55>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,56>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,57>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,49,48>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,49,49>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,49,50>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,49,51>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,49,52>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,49,53>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<111,112,68,101,102,67,104,97,114,103,101,49,54>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'}]};
typeinfo('WeightChargesTable') ->
  {sof,{typeinfo,{'TollAdvertisementMessage','WeightCharges'}}};
typeinfo('WeightCharges') ->
  {choice,#{<<112,101,114,65,120,108,101,87,101,105,103,104,116,67,104,97,114,103,101,115>> => {typeinfo,{'TollAdvertisementMessage','PerAxleWeightCharges'}},<<116,111,116,97,108,87,101,105,103,104,116,67,104,97,114,103,101,115>> => {typeinfo,{'TollAdvertisementMessage','TotalWeightCharges'}}}};
typeinfo('TotalWeightCharges') ->
  {sequence,'TotalWeightCharges',3,[{<<119,101,105,103,104,116,76,105,109,105,116>>,{'INTEGER',{0,16777215}},mandatory},{<<119,101,105,103,104,116,76,105,109,105,116,85,110,105,116,115>>,{'ENUMERATED_EXT',#{kilograms => 1,pounds => 0}},mandatory},{<<119,101,105,103,104,116,67,104,97,114,103,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},mandatory}]};
typeinfo('PerAxleWeightCharges') ->
  {sequence,'PerAxleWeightCharges',4,[{<<116,111,116,97,108,87,101,105,103,104,116,76,105,109,105,116>>,{'INTEGER',{0,16777215}},mandatory},{<<109,97,120,76,97,100,101,110,87,101,105,103,104,116,79,110,65,120,108,101>>,{'INTEGER',{0,65535}},mandatory},{<<119,101,105,103,104,116,76,105,109,105,116,85,110,105,116,115>>,{'ENUMERATED_EXT',#{kilograms => 1,pounds => 0}},mandatory},{<<97,120,108,101,87,101,105,103,104,116,67,104,97,114,103,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},mandatory}]};
typeinfo('AxlesChargesTable') ->
  {sof,{typeinfo,{'TollAdvertisementMessage','AxlesCharges'}}};
typeinfo('AxlesCharges') ->
  {sequence,'AxlesCharges',2,[{<<97,120,108,101,115,76,105,109,105,116>>,'INTEGER',mandatory},{<<97,120,108,101,115,67,104,97,114,103,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},mandatory}]};
typeinfo('TollPointMap') ->
  {sequence,'TollPointMap',6,[{<<114,101,118,105,115,105,111,110,78,117,109>>,'INTEGER',mandatory},{<<114,101,102,101,114,101,110,99,101,80,111,105,110,116>>,{typeinfo,{'Common','Position3D'}},mandatory},{<<115,112,101,101,100,76,105,109,105,116>>,{typeinfo,{'Common','RegulatorySpeedLimit'}},mandatory},{<<108,97,110,101,87,105,100,116,104>>,{'INTEGER',{0,32767}},mandatory},{<<97,112,112,114,111,97,99,104,76,97,110,101,115,77,97,112>>,{sof,{typeinfo,{'MapData','GenericLane'}}},mandatory},{<<116,111,108,108,90,111,110,101,76,97,110,101,115,77,97,112>>,{sof,{typeinfo,{'MapData','GenericLane'}}},mandatory}]};
typeinfo('TollChargerInfo') ->
  {sequence,'TollChargerInfo',3,[{<<116,111,108,108,67,104,97,114,103,101,114,73,100>>,'OBJECT IDENTIFIER',mandatory},{<<116,111,108,108,80,111,105,110,116,73,100>>,{'INTEGER',{1,2048}},mandatory},{<<100,101,115,99,114,105,112,116,105,118,101,78,97,109,101>>,string,'OPTIONAL'}]};
typeinfo('TollPointID') ->
  {'INTEGER',{1,2048}};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

dec_components1(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components1(Num, Bytes, Acc) ->
{Term,Remain} = dec_LaneChargesTable(Bytes),
dec_components1(Num-1, Remain, [Term|Acc]).

dec_components2(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components2(Num, Bytes, Acc) ->
{Term,Remain} = dec_ClosedNetworkChargesTable(Bytes),
dec_components2(Num-1, Remain, [Term|Acc]).

dec_components3(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components3(Num, Bytes, Acc) ->
{Term,Remain} = dec_VehTypeCharges(Bytes),
dec_components3(Num-1, Remain, [Term|Acc]).

dec_components4(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components4(Num, Bytes, Acc) ->
{Term,Remain} = dec_WeightCharges(Bytes),
dec_components4(Num-1, Remain, [Term|Acc]).

dec_components5(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components5(Num, Bytes, Acc) ->
{Term,Remain} = dec_AxlesCharges(Bytes),
dec_components5(Num-1, Remain, [Term|Acc]).

dec_components6(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components6(Num, Bytes, Acc) ->
{Term,Remain} = 'MapData':dec_GenericLane(Bytes),
dec_components6(Num-1, Remain, [Term|Acc]).

dec_components7(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components7(Num, Bytes, Acc) ->
{Term,Remain} = 'MapData':dec_GenericLane(Bytes),
dec_components7(Num-1, Remain, [Term|Acc]).

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

dec_subidentifiers([H | T], Av, Al) when H >= 128 ->
    dec_subidentifiers(T, Av bsl 7 bor H band 127, Al);
dec_subidentifiers([H | T], Av, Al) ->
    dec_subidentifiers(T, 0, [Av bsl 7 bor H | Al]);
dec_subidentifiers([], _Av, Al) ->
    lists:reverse(Al).

decode_chars(Val, N) ->
    [ 
     C ||
         <<C:N>> <= Val
    ].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

decode_oid(Octets) ->
    [First | Rest] = dec_subidentifiers(Octets, 0, []),
    Idlist =
        if
            First < 40 ->
                [0, First | Rest];
            First < 80 ->
                [1, First - 40 | Rest];
            true ->
                [2, First - 80 | Rest]
        end,
    list_to_tuple(Idlist).

e_o_e(Num) when Num < 128 ->
    Num bor 128;
e_o_e(Num) ->
    [e_o_e(Num bsr 7), Num band 127 bor 128].

e_object_element(Num) when Num < 128 ->
    [Num];
e_object_element(Num) ->
    [e_o_e(Num bsr 7), Num band 127].

e_object_elements([], Acc) ->
    lists:reverse(Acc);
e_object_elements([H | T], Acc) ->
    e_object_elements(T, [e_object_element(H) | Acc]).

e_object_identifier([E1, E2 | Tail])
    when E1 >= 0, E1 < 2, E2 < 40; E1 =:= 2 ->
    Head = 40 * E1 + E2,
    e_object_elements([Head | Tail], []);
e_object_identifier([_, _ | _Tail] = Oid) ->
    exit({error, {asn1, {illegal_value, Oid}}}).

encode_chars(Val, NumBits) ->
    << 
      <<C:NumBits>> ||
          C <- Val
    >>.

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

encode_oid(Val) when is_tuple(Val) ->
    encode_oid(tuple_to_list(Val));
encode_oid(Val) ->
    iolist_to_binary(e_object_identifier(Val)).

encode_unconstrained_number(Val) when not is_integer(Val) ->
    exit({error, {asn1, {illegal_integer, Val}}});
encode_unconstrained_number(Val) when Val >= 0 ->
    if
        Val < 128 ->
            [1, Val];
        Val < 256 ->
            [<<2,0>>, Val];
        true ->
            case binary:encode_unsigned(Val) of
                <<0:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) of
                        Sz when Sz < 128 ->
                            [Sz, Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14>>, Bin]
                    end;
                <<1:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) + 1 of
                        Sz when Sz < 128 ->
                            [Sz, 0, Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14,0:8>>, Bin]
                    end
            end
    end;
encode_unconstrained_number(Val) ->
    Oct = enint(Val, []),
    Len = length(Oct),
    if
        Len < 128 ->
            [Len | Oct];
        Len < 16384 ->
            [<<2:2,Len:14>> | Oct]
    end.

enint(-1, [B1 | T]) when B1 > 127 ->
    [B1 | T];
enint(N, Acc) ->
    enint(N bsr 8, [N band 255 | Acc]).

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
