%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in ProbeDataConfig.

-module('ProbeDataConfig').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("ProbeDataConfig.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'ProbeDataConfig'},
            {options,[{i,"./erl"},uper,jer,verbose,{i,"./asn"},{outdir,"./erl"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_ProbeDataConfigMessage/1,
enc_ProbeDataConfig/1,
enc_ConfigDescriptor/1,
enc_ConfigId/1,
enc_CfgVehicleClass/1,
enc_ConfigBoundary/1,
enc_ConfigTemporalBoundary/1,
enc_CfgEventRecurrence/1,
enc_ConfigTriggers/1,
enc_CfgInstantaneousEventTriggers/1,
enc_CfgIntervalEvents/1,
enc_CfgTransitVehicleData/1,
enc_CfgInterval/1,
enc_CfgVehicleEvents/1,
enc_CfgKinematicEvents/1,
enc_CfgEvents/1,
enc_CfgHysteresis/1,
enc_CfgEmerAndTransitInfo/1,
enc_CfgMsgRecepIndicators/1,
enc_CfgMsgDictionary/1,
enc_CfgRoadwayEvents/1,
enc_CfgTrafficSigEncounters/1,
enc_CfgRoadSignInfo/1,
enc_CfgRoadSignTypes/1,
enc_CfgCommSysPerfEvents/1,
enc_CfgAveragedAndSummaryTriggers/1,
enc_CfgAveragedTriggers/1,
enc_CfgSummaryTriggers/1,
enc_CfgLowSpeedCriteria/1,
enc_CfgStoppedCriteria/1
]).

-export([
dec_ProbeDataConfigMessage/1,
dec_ProbeDataConfig/1,
dec_ConfigDescriptor/1,
dec_ConfigId/1,
dec_CfgVehicleClass/1,
dec_ConfigBoundary/1,
dec_ConfigTemporalBoundary/1,
dec_CfgEventRecurrence/1,
dec_ConfigTriggers/1,
dec_CfgInstantaneousEventTriggers/1,
dec_CfgIntervalEvents/1,
dec_CfgTransitVehicleData/1,
dec_CfgInterval/1,
dec_CfgVehicleEvents/1,
dec_CfgKinematicEvents/1,
dec_CfgEvents/1,
dec_CfgHysteresis/1,
dec_CfgEmerAndTransitInfo/1,
dec_CfgMsgRecepIndicators/1,
dec_CfgMsgDictionary/1,
dec_CfgRoadwayEvents/1,
dec_CfgTrafficSigEncounters/1,
dec_CfgRoadSignInfo/1,
dec_CfgRoadSignTypes/1,
dec_CfgCommSysPerfEvents/1,
dec_CfgAveragedAndSummaryTriggers/1,
dec_CfgAveragedTriggers/1,
dec_CfgSummaryTriggers/1,
dec_CfgLowSpeedCriteria/1,
dec_CfgStoppedCriteria/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('ProbeDataConfig', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('ProbeDataConfig', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('ProbeDataConfigMessage', Data) -> enc_ProbeDataConfigMessage(Data);
encode_disp('ProbeDataConfig', Data) -> enc_ProbeDataConfig(Data);
encode_disp('ConfigDescriptor', Data) -> enc_ConfigDescriptor(Data);
encode_disp('ConfigId', Data) -> enc_ConfigId(Data);
encode_disp('CfgVehicleClass', Data) -> enc_CfgVehicleClass(Data);
encode_disp('ConfigBoundary', Data) -> enc_ConfigBoundary(Data);
encode_disp('ConfigTemporalBoundary', Data) -> enc_ConfigTemporalBoundary(Data);
encode_disp('CfgEventRecurrence', Data) -> enc_CfgEventRecurrence(Data);
encode_disp('ConfigTriggers', Data) -> enc_ConfigTriggers(Data);
encode_disp('CfgInstantaneousEventTriggers', Data) -> enc_CfgInstantaneousEventTriggers(Data);
encode_disp('CfgIntervalEvents', Data) -> enc_CfgIntervalEvents(Data);
encode_disp('CfgTransitVehicleData', Data) -> enc_CfgTransitVehicleData(Data);
encode_disp('CfgInterval', Data) -> enc_CfgInterval(Data);
encode_disp('CfgVehicleEvents', Data) -> enc_CfgVehicleEvents(Data);
encode_disp('CfgKinematicEvents', Data) -> enc_CfgKinematicEvents(Data);
encode_disp('CfgEvents', Data) -> enc_CfgEvents(Data);
encode_disp('CfgHysteresis', Data) -> enc_CfgHysteresis(Data);
encode_disp('CfgEmerAndTransitInfo', Data) -> enc_CfgEmerAndTransitInfo(Data);
encode_disp('CfgMsgRecepIndicators', Data) -> enc_CfgMsgRecepIndicators(Data);
encode_disp('CfgMsgDictionary', Data) -> enc_CfgMsgDictionary(Data);
encode_disp('CfgRoadwayEvents', Data) -> enc_CfgRoadwayEvents(Data);
encode_disp('CfgTrafficSigEncounters', Data) -> enc_CfgTrafficSigEncounters(Data);
encode_disp('CfgRoadSignInfo', Data) -> enc_CfgRoadSignInfo(Data);
encode_disp('CfgRoadSignTypes', Data) -> enc_CfgRoadSignTypes(Data);
encode_disp('CfgCommSysPerfEvents', Data) -> enc_CfgCommSysPerfEvents(Data);
encode_disp('CfgAveragedAndSummaryTriggers', Data) -> enc_CfgAveragedAndSummaryTriggers(Data);
encode_disp('CfgAveragedTriggers', Data) -> enc_CfgAveragedTriggers(Data);
encode_disp('CfgSummaryTriggers', Data) -> enc_CfgSummaryTriggers(Data);
encode_disp('CfgLowSpeedCriteria', Data) -> enc_CfgLowSpeedCriteria(Data);
encode_disp('CfgStoppedCriteria', Data) -> enc_CfgStoppedCriteria(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('ProbeDataConfigMessage', Data) -> dec_ProbeDataConfigMessage(Data);
decode_disp('ProbeDataConfig', Data) -> dec_ProbeDataConfig(Data);
decode_disp('ConfigDescriptor', Data) -> dec_ConfigDescriptor(Data);
decode_disp('ConfigId', Data) -> dec_ConfigId(Data);
decode_disp('CfgVehicleClass', Data) -> dec_CfgVehicleClass(Data);
decode_disp('ConfigBoundary', Data) -> dec_ConfigBoundary(Data);
decode_disp('ConfigTemporalBoundary', Data) -> dec_ConfigTemporalBoundary(Data);
decode_disp('CfgEventRecurrence', Data) -> dec_CfgEventRecurrence(Data);
decode_disp('ConfigTriggers', Data) -> dec_ConfigTriggers(Data);
decode_disp('CfgInstantaneousEventTriggers', Data) -> dec_CfgInstantaneousEventTriggers(Data);
decode_disp('CfgIntervalEvents', Data) -> dec_CfgIntervalEvents(Data);
decode_disp('CfgTransitVehicleData', Data) -> dec_CfgTransitVehicleData(Data);
decode_disp('CfgInterval', Data) -> dec_CfgInterval(Data);
decode_disp('CfgVehicleEvents', Data) -> dec_CfgVehicleEvents(Data);
decode_disp('CfgKinematicEvents', Data) -> dec_CfgKinematicEvents(Data);
decode_disp('CfgEvents', Data) -> dec_CfgEvents(Data);
decode_disp('CfgHysteresis', Data) -> dec_CfgHysteresis(Data);
decode_disp('CfgEmerAndTransitInfo', Data) -> dec_CfgEmerAndTransitInfo(Data);
decode_disp('CfgMsgRecepIndicators', Data) -> dec_CfgMsgRecepIndicators(Data);
decode_disp('CfgMsgDictionary', Data) -> dec_CfgMsgDictionary(Data);
decode_disp('CfgRoadwayEvents', Data) -> dec_CfgRoadwayEvents(Data);
decode_disp('CfgTrafficSigEncounters', Data) -> dec_CfgTrafficSigEncounters(Data);
decode_disp('CfgRoadSignInfo', Data) -> dec_CfgRoadSignInfo(Data);
decode_disp('CfgRoadSignTypes', Data) -> dec_CfgRoadSignTypes(Data);
decode_disp('CfgCommSysPerfEvents', Data) -> dec_CfgCommSysPerfEvents(Data);
decode_disp('CfgAveragedAndSummaryTriggers', Data) -> dec_CfgAveragedAndSummaryTriggers(Data);
decode_disp('CfgAveragedTriggers', Data) -> dec_CfgAveragedTriggers(Data);
decode_disp('CfgSummaryTriggers', Data) -> dec_CfgSummaryTriggers(Data);
decode_disp('CfgLowSpeedCriteria', Data) -> dec_CfgLowSpeedCriteria(Data);
decode_disp('CfgStoppedCriteria', Data) -> dec_CfgStoppedCriteria(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_ProbeDataConfigMessage(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if 0 =< Enc1@len@sub, Enc1@len@sub < 255 ->
[<<0:1,Enc1@len@sub:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_ProbeDataConfig(Comp) || Comp <- Val]].



dec_ProbeDataConfigMessage(Bytes) ->
%% Length with constraint {{1,255},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:8,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components1(V1@V0, V1@Buf1, []).

enc_ProbeDataConfig(Val) ->
[begin
Enc1@element = element(5, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute descriptor(1) with type ConfigDescriptor
Enc3@element = element(2, Val),
enc_ConfigDescriptor(Enc3@element)
end,
begin
%% attribute triggers(2) with type ConfigTriggers
Enc4@element = element(3, Val),
enc_ConfigTriggers(Enc4@element)
end,
begin
%% attribute maxAgeOfData(3) with type INTEGER
Enc5@element = element(4, Val),
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 90 ->
<<Enc5@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end|begin
%% attribute boundary(4) with type ConfigBoundary
Enc7@element = element(5, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
enc_ConfigBoundary(Enc7@element)
end
end].


dec_ProbeDataConfig(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute descriptor(1) with type ConfigDescriptor
{Term1,Bytes3} = dec_ConfigDescriptor(Bytes2),

%% attribute triggers(2) with type ConfigTriggers
{Term2,Bytes4} = dec_ConfigTriggers(Bytes3),

%% attribute maxAgeOfData(3) with type INTEGER
{Term3,Bytes5} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes4,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% attribute boundary(4) with type ConfigBoundary
{Term4,Bytes6} = case Opt band 1 of
1 ->
dec_ConfigBoundary(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V4@V0,V4@Buf1} = case Bytes6 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = {'ProbeDataConfig',Term1,Term2,Term3,Term4},
{Res1,Bytes8}.

enc_ConfigDescriptor(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute identifier(1) with type INTEGER
Enc5@element = element(2, Val),
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 255 ->
Enc5@element@sub;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end,
begin
%% attribute vehClass(2) with type CfgVehicleClass
Enc7@element = element(3, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgVehicleClass(Enc7@element)
end
end,
begin
%% attribute roadAuthorityID(3) with type RoadAuthorityID
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_RoadAuthorityID(Enc9@element)
end
end|begin
%% attribute percentOfResp(4) with type INTEGER
Enc11@element = element(5, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc11@element@sub = Enc11@element - 1,
if 0 =< Enc11@element@sub, Enc11@element@sub < 10 ->
<<Enc11@element@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc11@element}}})
end
end
end
end].


dec_ConfigDescriptor(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute identifier(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% attribute vehClass(2) with type CfgVehicleClass
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
dec_CfgVehicleClass(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute roadAuthorityID(3) with type RoadAuthorityID
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
'Common':dec_RoadAuthorityID(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute percentOfResp(4) with type INTEGER
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes5,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V5@V0,V5@Buf1} = case Bytes6 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = {'ConfigDescriptor',Term1,Term2,Term3,Term4},
{Res1,Bytes8}.

enc_ConfigId(Val) ->
Val@sub = Val - 1,
if 0 =< Val@sub, Val@sub < 255 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ConfigId(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_CfgVehicleClass(Val) ->
[begin
%% attribute motorcycles(1) with type BOOLEAN
Enc2@element = element(2, Val),
%% attribute passengerCars(2) with type BOOLEAN
Enc4@element = element(3, Val),
if Enc2@element =:= false ->
if Enc4@element =:= false ->
<<0:1,0:1,0:1>>;
Enc4@element =:= true ->
<<0:1,0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc4@element}}})
end;
Enc2@element =:= true ->
if Enc4@element =:= false ->
<<0:1,1:1,0:1>>;
Enc4@element =:= true ->
<<0:1,1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc4@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc2@element}}})
end
end,
begin
%% attribute other2axle4tireSingleUnitVehs(3) with type BOOLEAN
Enc6@element = element(4, Val),
%% attribute buses(4) with type BOOLEAN
Enc8@element = element(5, Val),
if Enc6@element =:= false ->
if Enc8@element =:= false ->
<<0:1,0:1>>;
Enc8@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc8@element}}})
end;
Enc6@element =:= true ->
if Enc8@element =:= false ->
<<1:1,0:1>>;
Enc8@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc8@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc6@element}}})
end
end,
begin
%% attribute twoAxle6TireSingleUnitTrucks(5) with type BOOLEAN
Enc10@element = element(6, Val),
%% attribute threeAxleSingleUnitTrucks(6) with type BOOLEAN
Enc12@element = element(7, Val),
if Enc10@element =:= false ->
if Enc12@element =:= false ->
<<0:1,0:1>>;
Enc12@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc12@element}}})
end;
Enc10@element =:= true ->
if Enc12@element =:= false ->
<<1:1,0:1>>;
Enc12@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc12@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc10@element}}})
end
end,
begin
%% attribute fourOrMoreAxleSingleUnitTrucks(7) with type BOOLEAN
Enc14@element = element(8, Val),
%% attribute fourOrFewerAxleSingleTrailerTrucks(8) with type BOOLEAN
Enc16@element = element(9, Val),
if Enc14@element =:= false ->
if Enc16@element =:= false ->
<<0:1,0:1>>;
Enc16@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc16@element}}})
end;
Enc14@element =:= true ->
if Enc16@element =:= false ->
<<1:1,0:1>>;
Enc16@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc16@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc14@element}}})
end
end,
begin
%% attribute fiveAxleSingleTrailerTrucks(9) with type BOOLEAN
Enc18@element = element(10, Val),
%% attribute sixOrMoreAxleSingleTrailerTrucks(10) with type BOOLEAN
Enc20@element = element(11, Val),
if Enc18@element =:= false ->
if Enc20@element =:= false ->
<<0:1,0:1>>;
Enc20@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc20@element}}})
end;
Enc18@element =:= true ->
if Enc20@element =:= false ->
<<1:1,0:1>>;
Enc20@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc20@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc18@element}}})
end
end,
begin
%% attribute fiveOrFewerAxleMultiTrailerTrucks(11) with type BOOLEAN
Enc22@element = element(12, Val),
%% attribute sixAxleMultiTrailerTrucks(12) with type BOOLEAN
Enc24@element = element(13, Val),
if Enc22@element =:= false ->
if Enc24@element =:= false ->
<<0:1,0:1>>;
Enc24@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc24@element}}})
end;
Enc22@element =:= true ->
if Enc24@element =:= false ->
<<1:1,0:1>>;
Enc24@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc24@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc22@element}}})
end
end|begin
%% attribute sevenOrMoreAxleMultiTrailerTrucks(13) with type BOOLEAN
Enc26@element = element(14, Val),
if Enc26@element =:= false ->
<<0:1>>;
Enc26@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc26@element}}})
end
end].


dec_CfgVehicleClass(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute motorcycles(1) with type BOOLEAN
{Term1,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> false;
1 -> true
end,
{V2@Int2,V2@Buf1}
end,

%% attribute passengerCars(2) with type BOOLEAN
{Term2,Bytes3} = begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end,

%% attribute other2axle4tireSingleUnitVehs(3) with type BOOLEAN
{Term3,Bytes4} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end,

%% attribute buses(4) with type BOOLEAN
{Term4,Bytes5} = begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end,

%% attribute twoAxle6TireSingleUnitTrucks(5) with type BOOLEAN
{Term5,Bytes6} = begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end,

%% attribute threeAxleSingleUnitTrucks(6) with type BOOLEAN
{Term6,Bytes7} = begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes6,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end,

%% attribute fourOrMoreAxleSingleUnitTrucks(7) with type BOOLEAN
{Term7,Bytes8} = begin
<<V8@V0:1,V8@Buf1/bitstring>> = Bytes7,
V8@Int2 = case V8@V0 of
0 -> false;
1 -> true
end,
{V8@Int2,V8@Buf1}
end,

%% attribute fourOrFewerAxleSingleTrailerTrucks(8) with type BOOLEAN
{Term8,Bytes9} = begin
<<V9@V0:1,V9@Buf1/bitstring>> = Bytes8,
V9@Int2 = case V9@V0 of
0 -> false;
1 -> true
end,
{V9@Int2,V9@Buf1}
end,

%% attribute fiveAxleSingleTrailerTrucks(9) with type BOOLEAN
{Term9,Bytes10} = begin
<<V10@V0:1,V10@Buf1/bitstring>> = Bytes9,
V10@Int2 = case V10@V0 of
0 -> false;
1 -> true
end,
{V10@Int2,V10@Buf1}
end,

%% attribute sixOrMoreAxleSingleTrailerTrucks(10) with type BOOLEAN
{Term10,Bytes11} = begin
<<V11@V0:1,V11@Buf1/bitstring>> = Bytes10,
V11@Int2 = case V11@V0 of
0 -> false;
1 -> true
end,
{V11@Int2,V11@Buf1}
end,

%% attribute fiveOrFewerAxleMultiTrailerTrucks(11) with type BOOLEAN
{Term11,Bytes12} = begin
<<V12@V0:1,V12@Buf1/bitstring>> = Bytes11,
V12@Int2 = case V12@V0 of
0 -> false;
1 -> true
end,
{V12@Int2,V12@Buf1}
end,

%% attribute sixAxleMultiTrailerTrucks(12) with type BOOLEAN
{Term12,Bytes13} = begin
<<V13@V0:1,V13@Buf1/bitstring>> = Bytes12,
V13@Int2 = case V13@V0 of
0 -> false;
1 -> true
end,
{V13@Int2,V13@Buf1}
end,

%% attribute sevenOrMoreAxleMultiTrailerTrucks(13) with type BOOLEAN
{Term13,Bytes14} = begin
<<V14@V0:1,V14@Buf1/bitstring>> = Bytes13,
V14@Int2 = case V14@V0 of
0 -> false;
1 -> true
end,
{V14@Int2,V14@Buf1}
end,

%% Extensions
{Extensions,Bytes15} = case Ext of
0 -> {<<>>,Bytes14};
1 ->
{V15@V0,V15@Buf1} = case Bytes14 of
<<0:1,V15@V3:6,V15@Buf4/bitstring>> ->
V15@Add5 = V15@V3 + 1,
{V15@Add5,V15@Buf4};
<<1:1,V15@Buf2/bitstring>> ->
{V15@V3,V15@Buf4} = case V15@Buf2 of
<<0:1,V15@V6:7,V15@Buf7/bitstring>> when V15@V6 =/= 0 ->
{V15@V6,V15@Buf7};
<<1:1,0:1,V15@V7:14,V15@Buf8/bitstring>> when V15@V7 =/= 0 ->
{V15@V7,V15@Buf8};
<<1:1,1:1,V15@V7:6,V15@Buf8/bitstring>> when V15@V7 =/= 0 ->
V15@Mul9 = V15@V7 * 16384,
{V15@Mul9,V15@Buf8}
end,
{V15@V3,V15@Buf4}
end,
<<V15@V10:V15@V0/bitstring-unit:1,V15@Buf11/bitstring>> = V15@Buf1,
{V15@V10,V15@Buf11}
end,
Bytes16= skipextensions(Bytes15, 1, Extensions),
Res1 = {'CfgVehicleClass',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13},
{Res1,Bytes16}.

enc_ConfigBoundary(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= temporalBoundary ->
[<<0:1,0:1>>|enc_ConfigTemporalBoundary(ChoiceVal)];
ChoiceTag =:= geoAndDistBoundary ->
[<<0:1,1:1>>|'TravelerInformation':enc_ValidRegion(ChoiceVal)]
end.


dec_ConfigBoundary(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_ConfigTemporalBoundary(Bytes2)
end,
{{temporalBoundary,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'TravelerInformation':dec_ValidRegion(Bytes2)
end,
{{geoAndDistBoundary,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_ConfigTemporalBoundary(Val) ->
[<<0:1>>,
begin
%% attribute beginTime(1) with type DDateTime
Enc2@element = element(2, Val),
'Common':enc_DDateTime(Enc2@element)
end,
begin
%% attribute endTime(2) with type DDateTime
Enc3@element = element(3, Val),
'Common':enc_DDateTime(Enc3@element)
end|begin
%% attribute recurring(3) with type CfgEventRecurrence
Enc4@element = element(4, Val),
enc_CfgEventRecurrence(Enc4@element)
end].


dec_ConfigTemporalBoundary(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute beginTime(1) with type DDateTime
{Term1,Bytes2} = 'Common':dec_DDateTime(Bytes1),

%% attribute endTime(2) with type DDateTime
{Term2,Bytes3} = 'Common':dec_DDateTime(Bytes2),

%% attribute recurring(3) with type CfgEventRecurrence
{Term3,Bytes4} = dec_CfgEventRecurrence(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V2@V0,V2@Buf1} = case Bytes4 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'ConfigTemporalBoundary',Term1,Term2,Term3},
{Res1,Bytes6}.

enc_CfgEventRecurrence(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(13, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute startTime(1) with type DTime
Enc7@element = element(2, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DTime(Enc7@element)
end
end,
begin
%% attribute endTime(2) with type DTime
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DTime(Enc9@element)
end
end,
begin
%% attribute startDate(3) with type DDate
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DDate(Enc11@element)
end
end,
begin
%% attribute endDate(4) with type DDate
Enc13@element = element(5, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DDate(Enc13@element)
end
end,
begin
%% attribute monday(5) with type BOOLEAN
Enc15@element = element(6, Val),
%% attribute tuesday(6) with type BOOLEAN
Enc17@element = element(7, Val),
if Enc15@element =:= false ->
if Enc17@element =:= false ->
<<0:1,0:1>>;
Enc17@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc17@element}}})
end;
Enc15@element =:= true ->
if Enc17@element =:= false ->
<<1:1,0:1>>;
Enc17@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc17@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc15@element}}})
end
end,
begin
%% attribute wednesday(7) with type BOOLEAN
Enc19@element = element(8, Val),
%% attribute thursday(8) with type BOOLEAN
Enc21@element = element(9, Val),
if Enc19@element =:= false ->
if Enc21@element =:= false ->
<<0:1,0:1>>;
Enc21@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc21@element}}})
end;
Enc19@element =:= true ->
if Enc21@element =:= false ->
<<1:1,0:1>>;
Enc21@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc21@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc19@element}}})
end
end,
begin
%% attribute friday(9) with type BOOLEAN
Enc23@element = element(10, Val),
%% attribute saturday(10) with type BOOLEAN
Enc25@element = element(11, Val),
if Enc23@element =:= false ->
if Enc25@element =:= false ->
<<0:1,0:1>>;
Enc25@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc25@element}}})
end;
Enc23@element =:= true ->
if Enc25@element =:= false ->
<<1:1,0:1>>;
Enc25@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc25@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc23@element}}})
end
end|begin
%% attribute sunday(11) with type BOOLEAN
Enc27@element = element(12, Val),
%% attribute exclusion(12) with type BOOLEAN
Enc29@element = element(13, Val),
if Enc27@element =:= false ->
if Enc29@element =:= asn1_NOVALUE ->
<<0:1>>;
Enc29@element =:= false ->
<<0:1,0:1>>;
Enc29@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc29@element}}})
end;
Enc27@element =:= true ->
if Enc29@element =:= asn1_NOVALUE ->
<<1:1>>;
Enc29@element =:= false ->
<<1:1,0:1>>;
Enc29@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc29@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc27@element}}})
end
end].


dec_CfgEventRecurrence(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute startTime(1) with type DTime
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
'Common':dec_DTime(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute endTime(2) with type DTime
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
'Common':dec_DTime(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute startDate(3) with type DDate
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
'Common':dec_DDate(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute endDate(4) with type DDate
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
'Common':dec_DDate(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute monday(5) with type BOOLEAN
{Term5,Bytes7} = begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes6,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end,

%% attribute tuesday(6) with type BOOLEAN
{Term6,Bytes8} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes7,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end,

%% attribute wednesday(7) with type BOOLEAN
{Term7,Bytes9} = begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes8,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end,

%% attribute thursday(8) with type BOOLEAN
{Term8,Bytes10} = begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes9,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end,

%% attribute friday(9) with type BOOLEAN
{Term9,Bytes11} = begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes10,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end,

%% attribute saturday(10) with type BOOLEAN
{Term10,Bytes12} = begin
<<V8@V0:1,V8@Buf1/bitstring>> = Bytes11,
V8@Int2 = case V8@V0 of
0 -> false;
1 -> true
end,
{V8@Int2,V8@Buf1}
end,

%% attribute sunday(11) with type BOOLEAN
{Term11,Bytes13} = begin
<<V9@V0:1,V9@Buf1/bitstring>> = Bytes12,
V9@Int2 = case V9@V0 of
0 -> false;
1 -> true
end,
{V9@Int2,V9@Buf1}
end,

%% attribute exclusion(12) with type BOOLEAN
{Term12,Bytes14} = case Opt band 1 of
1 ->
begin
<<V10@V0:1,V10@Buf1/bitstring>> = Bytes13,
V10@Int2 = case V10@V0 of
0 -> false;
1 -> true
end,
{V10@Int2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% Extensions
{Extensions,Bytes15} = case Ext of
0 -> {<<>>,Bytes14};
1 ->
{V11@V0,V11@Buf1} = case Bytes14 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8};
<<1:1,1:1,V11@V7:6,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
V11@Mul9 = V11@V7 * 16384,
{V11@Mul9,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V10:V11@V0/bitstring-unit:1,V11@Buf11/bitstring>> = V11@Buf1,
{V11@V10,V11@Buf11}
end,
Bytes16= skipextensions(Bytes15, 1, Extensions),
Res1 = {'CfgEventRecurrence',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12},
{Res1,Bytes16}.

enc_ConfigTriggers(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= instantaneousTriggers ->
[<<0:1,0:1>>|enc_CfgInstantaneousEventTriggers(ChoiceVal)];
ChoiceTag =:= avgAndSumTriggers ->
[<<0:1,1:1>>|enc_CfgAveragedAndSummaryTriggers(ChoiceVal)]
end.


dec_ConfigTriggers(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_CfgInstantaneousEventTriggers(Bytes2)
end,
{{instantaneousTriggers,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_CfgAveragedAndSummaryTriggers(Bytes2)
end,
{{avgAndSumTriggers,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_CfgInstantaneousEventTriggers(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= intervalEvents ->
[<<0:1,0:2>>|enc_CfgIntervalEvents(ChoiceVal)];
ChoiceTag =:= vehicleEvents ->
[<<0:1,1:2>>|enc_CfgVehicleEvents(ChoiceVal)];
ChoiceTag =:= roadwayEvents ->
[<<0:1,2:2>>|enc_CfgRoadwayEvents(ChoiceVal)];
ChoiceTag =:= commSysPerfEvents ->
[<<0:1,3:2>>|enc_CfgCommSysPerfEvents(ChoiceVal)]
end.


dec_CfgInstantaneousEventTriggers(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_CfgIntervalEvents(Bytes2)
end,
{{intervalEvents,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_CfgVehicleEvents(Bytes2)
end,
{{vehicleEvents,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_CfgRoadwayEvents(Bytes2)
end,
{{roadwayEvents,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
dec_CfgCommSysPerfEvents(Bytes2)
end,
{{commSysPerfEvents,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_CfgIntervalEvents(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute interval(1) with type CfgInterval
Enc7@element = element(2, Val),
enc_CfgInterval(Enc7@element)
end,
begin
%% attribute wiperStatus(2) with type BOOLEAN
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
Enc8@element =:= false ->
<<0:1>>;
Enc8@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc8@element}}})
end
end,
begin
%% attribute vehCount(3) with type BOOLEAN
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
Enc11@element =:= false ->
<<0:1>>;
Enc11@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc11@element}}})
end
end,
begin
%% attribute weatherData(4) with type BOOLEAN
Enc14@element = element(5, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
Enc14@element =:= false ->
<<0:1>>;
Enc14@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc14@element}}})
end
end,
begin
%% attribute transitVehData(5) with type CfgTransitVehicleData
Enc17@element = element(6, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgTransitVehicleData(Enc17@element)
end
end|begin
%% attribute numOfOccupants(6) with type BOOLEAN
Enc19@element = element(7, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
Enc19@element =:= false ->
<<0:1>>;
Enc19@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc19@element}}})
end
end].


dec_CfgIntervalEvents(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute interval(1) with type CfgInterval
{Term1,Bytes3} = dec_CfgInterval(Bytes2),

%% attribute wiperStatus(2) with type BOOLEAN
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes3,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute vehCount(3) with type BOOLEAN
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes4,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute weatherData(4) with type BOOLEAN
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes5,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute transitVehData(5) with type CfgTransitVehicleData
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
dec_CfgTransitVehicleData(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute numOfOccupants(6) with type BOOLEAN
{Term6,Bytes8} = case Opt band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes7,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V7@V0,V7@Buf1} = case Bytes8 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = {'CfgIntervalEvents',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes10}.

enc_CfgTransitVehicleData(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
%% attribute currNumPasngers(1) with type BOOLEAN
Enc5@element = element(2, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
Enc5@element =:= false ->
<<0:1,0:1>>;
Enc5@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc5@element}}})
end;
true ->
if Enc5@element =:= asn1_NOVALUE ->
<<1:1>>;
Enc5@element =:= false ->
<<1:1,0:1>>;
Enc5@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc5@element}}})
end
end
end,
begin
%% attribute avgNumPasngers(2) with type BOOLEAN
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
Enc8@element =:= false ->
<<0:1>>;
Enc8@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc8@element}}})
end
end|begin
%% attribute trnstVehSchAdh(3) with type BOOLEAN
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
Enc11@element =:= false ->
<<0:1>>;
Enc11@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc11@element}}})
end
end].


dec_CfgTransitVehicleData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute currNumPasngers(1) with type BOOLEAN
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute avgNumPasngers(2) with type BOOLEAN
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute trnstVehSchAdh(3) with type BOOLEAN
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'CfgTransitVehicleData',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_CfgInterval(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= timeInterval ->
begin
ChoiceVal@sub = ChoiceVal - 1,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 36000 ->
<<0:1,0:1,ChoiceVal@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end;
ChoiceTag =:= distanceInterval ->
begin
ChoiceVal@sub = ChoiceVal - 1,
if 0 =< ChoiceVal@sub, ChoiceVal@sub < 100 ->
<<0:1,1:1,ChoiceVal@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end
end.


dec_CfgInterval(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes2,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end
end,
{{timeInterval,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end
end,
{{distanceInterval,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_CfgVehicleEvents(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc11@element = element(12, Val),
Enc12@element = element(13, Val),
if Enc11@element =:= asn1_NOVALUE ->
if Enc12@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc12@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute headLights(1) with type BOOLEAN
Enc14@element = element(2, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
Enc14@element =:= false ->
<<0:1>>;
Enc14@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc14@element}}})
end
end,
begin
%% attribute fogLights(2) with type BOOLEAN
Enc17@element = element(3, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
Enc17@element =:= false ->
<<0:1>>;
Enc17@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc17@element}}})
end
end,
begin
%% attribute hazardLights(3) with type BOOLEAN
Enc20@element = element(4, Val),
if Enc20@element =:= asn1_NOVALUE ->
[];
Enc20@element =:= false ->
<<0:1>>;
Enc20@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc20@element}}})
end
end,
begin
%% attribute kinematicEvents(4) with type CfgKinematicEvents
Enc23@element = element(5, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgKinematicEvents(Enc23@element)
end
end,
begin
%% attribute wiperStatusChange(5) with type BOOLEAN
Enc25@element = element(6, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
Enc25@element =:= false ->
<<0:1>>;
Enc25@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc25@element}}})
end
end,
begin
%% attribute lowSpeed(6) with type CfgLowSpeedCriteria
Enc28@element = element(7, Val),
if Enc28@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgLowSpeedCriteria(Enc28@element)
end
end,
begin
%% attribute resumedSpeed(7) with type INTEGER
Enc30@element = element(8, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc30@element@sub = Enc30@element - 1,
if 0 =< Enc30@element@sub, Enc30@element@sub < 100 ->
<<Enc30@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc30@element}}})
end
end
end
end,
begin
%% attribute vehEntrsExitsRegion(8) with type BOOLEAN
Enc33@element = element(9, Val),
if Enc33@element =:= asn1_NOVALUE ->
[];
Enc33@element =:= false ->
<<0:1>>;
Enc33@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc33@element}}})
end
end,
begin
%% attribute emerVehDetect(9) with type BOOLEAN
Enc36@element = element(10, Val),
if Enc36@element =:= asn1_NOVALUE ->
[];
Enc36@element =:= false ->
<<0:1>>;
Enc36@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc36@element}}})
end
end,
begin
%% attribute emerAndTransInfo(10) with type CfgEmerAndTransitInfo
Enc39@element = element(11, Val),
if Enc39@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgEmerAndTransitInfo(Enc39@element)
end
end,
begin
%% attribute v2xMsgRecption(11) with type CfgMsgRecepIndicators
Enc41@element = element(12, Val),
if Enc41@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgMsgRecepIndicators(Enc41@element)
end
end|begin
%% attribute driverAlertsAndWarnings(12) with type BOOLEAN
Enc43@element = element(13, Val),
if Enc43@element =:= asn1_NOVALUE ->
[];
Enc43@element =:= false ->
<<0:1>>;
Enc43@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc43@element}}})
end
end].


dec_CfgVehicleEvents(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute headLights(1) with type BOOLEAN
{Term1,Bytes3} = case (Opt bsr 11) band 1 of
1 ->
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute fogLights(2) with type BOOLEAN
{Term2,Bytes4} = case (Opt bsr 10) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute hazardLights(3) with type BOOLEAN
{Term3,Bytes5} = case (Opt bsr 9) band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute kinematicEvents(4) with type CfgKinematicEvents
{Term4,Bytes6} = case (Opt bsr 8) band 1 of
1 ->
dec_CfgKinematicEvents(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute wiperStatusChange(5) with type BOOLEAN
{Term5,Bytes7} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes6,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute lowSpeed(6) with type CfgLowSpeedCriteria
{Term6,Bytes8} = case (Opt bsr 6) band 1 of
1 ->
dec_CfgLowSpeedCriteria(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute resumedSpeed(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V7@V0:7,V7@Buf1/bitstring>> = Bytes8,
V7@Add2 = V7@V0 + 1,
{V7@Add2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute vehEntrsExitsRegion(8) with type BOOLEAN
{Term8,Bytes10} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V8@V0:1,V8@Buf1/bitstring>> = Bytes9,
V8@Int2 = case V8@V0 of
0 -> false;
1 -> true
end,
{V8@Int2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute emerVehDetect(9) with type BOOLEAN
{Term9,Bytes11} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V9@V0:1,V9@Buf1/bitstring>> = Bytes10,
V9@Int2 = case V9@V0 of
0 -> false;
1 -> true
end,
{V9@Int2,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute emerAndTransInfo(10) with type CfgEmerAndTransitInfo
{Term10,Bytes12} = case (Opt bsr 2) band 1 of
1 ->
dec_CfgEmerAndTransitInfo(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute v2xMsgRecption(11) with type CfgMsgRecepIndicators
{Term11,Bytes13} = case (Opt bsr 1) band 1 of
1 ->
dec_CfgMsgRecepIndicators(Bytes12);
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute driverAlertsAndWarnings(12) with type BOOLEAN
{Term12,Bytes14} = case Opt band 1 of
1 ->
begin
<<V10@V0:1,V10@Buf1/bitstring>> = Bytes13,
V10@Int2 = case V10@V0 of
0 -> false;
1 -> true
end,
{V10@Int2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% Extensions
{Extensions,Bytes15} = case Ext of
0 -> {<<>>,Bytes14};
1 ->
{V11@V0,V11@Buf1} = case Bytes14 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8};
<<1:1,1:1,V11@V7:6,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
V11@Mul9 = V11@V7 * 16384,
{V11@Mul9,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V10:V11@V0/bitstring-unit:1,V11@Buf11/bitstring>> = V11@Buf1,
{V11@V10,V11@Buf11}
end,
Bytes16= skipextensions(Bytes15, 1, Extensions),
Res1 = {'CfgVehicleEvents',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12},
{Res1,Bytes16}.

enc_CfgKinematicEvents(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute events(1) with type CfgEvents
Enc3@element = element(2, Val),
enc_CfgEvents(Enc3@element)
end|begin
%% attribute hysteresis(2) with type CfgHysteresis
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgHysteresis(Enc4@element)
end
end].


dec_CfgKinematicEvents(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute events(1) with type CfgEvents
{Term1,Bytes3} = dec_CfgEvents(Bytes2),

%% attribute hysteresis(2) with type CfgHysteresis
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_CfgHysteresis(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'CfgKinematicEvents',Term1,Term2},
{Res1,Bytes6}.

enc_CfgEvents(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
%% attribute absActivated(1) with type BOOLEAN
Enc7@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc7@element =:= asn1_NOVALUE ->
<<0:1>>;
Enc7@element =:= false ->
<<0:1,0:1>>;
Enc7@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc7@element}}})
end;
true ->
if Enc7@element =:= asn1_NOVALUE ->
<<1:1>>;
Enc7@element =:= false ->
<<1:1,0:1>>;
Enc7@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc7@element}}})
end
end
end,
begin
%% attribute tractionCtlLoss(2) with type BOOLEAN
Enc10@element = element(3, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
Enc10@element =:= false ->
<<0:1>>;
Enc10@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc10@element}}})
end
end,
begin
%% attribute stabilityCtlActivated(3) with type BOOLEAN
Enc13@element = element(4, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
Enc13@element =:= false ->
<<0:1>>;
Enc13@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc13@element}}})
end
end,
begin
%% attribute hardBraking(4) with type BOOLEAN
Enc16@element = element(5, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
Enc16@element =:= false ->
<<0:1>>;
Enc16@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc16@element}}})
end
end|begin
%% attribute swerveThreshold(5) with type INTEGER
Enc19@element = element(6, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc19@element@sub = Enc19@element - 1,
if 0 =< Enc19@element@sub, Enc19@element@sub < 50 ->
<<Enc19@element@sub:6>>;
true ->
exit({error,{asn1,{illegal_integer,Enc19@element}}})
end
end
end
end].


dec_CfgEvents(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute absActivated(1) with type BOOLEAN
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute tractionCtlLoss(2) with type BOOLEAN
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute stabilityCtlActivated(3) with type BOOLEAN
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute hardBraking(4) with type BOOLEAN
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute swerveThreshold(5) with type INTEGER
{Term5,Bytes7} = case Opt band 1 of
1 ->
begin
<<V7@V0:6,V7@Buf1/bitstring>> = Bytes6,
V7@Add2 = V7@V0 + 1,
{V7@Add2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V8@V0,V8@Buf1} = case Bytes7 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8};
<<1:1,1:1,V8@V7:6,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
V8@Mul9 = V8@V7 * 16384,
{V8@Mul9,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V10:V8@V0/bitstring-unit:1,V8@Buf11/bitstring>> = V8@Buf1,
{V8@V10,V8@Buf11}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'CfgEvents',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes9}.

enc_CfgHysteresis(Val) ->
[begin
%% attribute hysSamples(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - 1,
if 0 =< Enc2@element@sub, Enc2@element@sub < 10 ->
<<0:1,Enc2@element@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute hysRate(2) with type INTEGER
Enc4@element = element(3, Val),
Enc4@element@sub = Enc4@element - 1,
if 0 =< Enc4@element@sub, Enc4@element@sub < 10 ->
<<Enc4@element@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_CfgHysteresis(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute hysSamples(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,

%% attribute hysRate(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'CfgHysteresis',Term1,Term2},
{Res1,Bytes5}.

enc_CfgEmerAndTransitInfo(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= emerVehLightBar ->
if ChoiceVal =:= false ->
<<0:1,0:2,0:1>>;
ChoiceVal =:= true ->
<<0:1,0:2,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,ChoiceVal}}})
end;
ChoiceTag =:= reqTspEvp ->
if ChoiceVal =:= false ->
<<0:1,1:2,0:1>>;
ChoiceVal =:= true ->
<<0:1,1:2,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,ChoiceVal}}})
end;
ChoiceTag =:= transitVehPassCnt ->
if ChoiceVal =:= false ->
<<0:1,2:2,0:1>>;
ChoiceVal =:= true ->
<<0:1,2:2,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,ChoiceVal}}})
end;
ChoiceTag =:= transitVehDoor ->
if ChoiceVal =:= false ->
<<0:1,3:2,0:1>>;
ChoiceVal =:= true ->
<<0:1,3:2,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,ChoiceVal}}})
end
end.


dec_CfgEmerAndTransitInfo(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes2,
V2@Int2 = case V2@V0 of
0 -> false;
1 -> true
end,
{V2@Int2,V2@Buf1}
end
end,
{{emerVehLightBar,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end
end,
{{reqTspEvp,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes2,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end
end,
{{transitVehPassCnt,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes2,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end
end,
{{transitVehDoor,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_CfgMsgRecepIndicators(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute msgDictionary(1) with type ENUMERATED
Enc4@element = element(2, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
Enc4@element =:= sae ->
<<0:1,0:2>>;
Enc4@element =:= etsi ->
<<0:1,1:2>>;
Enc4@element =:= iso ->
<<0:1,2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc4@element}}})
end
end|begin
%% attribute messages(2) with type SEQUENCE OF
Enc7@element = element(3, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgMsgRecepIndicators_messages(Enc7@element)
end
end].
enc_CfgMsgRecepIndicators_messages(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
[if Enc2@len@sub bsr 3 =:= 0 ->
<<0:1,Enc2@len@sub:3>>;
Enc2@len < 128 ->
[<<1:1,Enc2@len:8>>];
Enc2@len < 16384 ->
<<1:1,2:2,Enc2@len:14>>
end|[if Comp bsr 15 =:= 0 ->
<<Comp:15>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_CfgMsgRecepIndicators(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute msgDictionary(1) with type ENUMERATED
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:2,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> sae;
1 -> etsi;
2 -> iso;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11};
<<1:1,1:1,V3@V10:6,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
V3@Mul12 = V3@V10 * 16384,
{V3@Mul12,V3@Buf11}
end,
<<V3@V13:V3@V6/unit:8,V3@Buf14/bitstring>> = V3@Buf7,
{V3@V13,V3@Buf14}
end,
V3@Int15 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int15,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute messages(2) with type SEQUENCE OF
{Term2,Bytes4} = case Opt band 1 of
1 ->
dec_CfgMsgRecepIndicators_messages(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V4@V0,V4@Buf1} = case Bytes4 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'CfgMsgRecepIndicators',Term1,Term2},
{Res1,Bytes6}.


dec_CfgMsgRecepIndicators_messages(Bytes) ->
%% Length with constraint {{1,8},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components2(V1@V0, V1@Buf1, []).

enc_CfgMsgDictionary(Val) ->
if Val =:= sae ->
<<0:1,0:2>>;
Val =:= etsi ->
<<0:1,1:2>>;
Val =:= iso ->
<<0:1,2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_CfgMsgDictionary(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> sae;
1 -> etsi;
2 -> iso;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_CfgRoadwayEvents(Val) ->
[begin
Enc1@element = element(4, Val),
Enc2@element = element(7, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(8, Val),
%% attribute obstacleDetected(1) with type BOOLEAN
Enc5@element = element(2, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc5@element =:= false ->
<<0:1,0:1>>;
Enc5@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc5@element}}})
end;
true ->
if Enc5@element =:= false ->
<<1:1,0:1>>;
Enc5@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc5@element}}})
end
end
end,
begin
%% attribute adverseRoadSurface(2) with type BOOLEAN
Enc7@element = element(3, Val),
if Enc7@element =:= false ->
<<0:1>>;
Enc7@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc7@element}}})
end
end,
begin
%% attribute trafficSigEncounters(3) with type CfgTrafficSigEncounters
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgTrafficSigEncounters(Enc9@element)
end
end,
begin
%% attribute trfsigLightOut(4) with type BOOLEAN
Enc11@element = element(5, Val),
%% attribute trfsigRoadGeoMismatch(5) with type BOOLEAN
Enc13@element = element(6, Val),
if Enc11@element =:= false ->
if Enc13@element =:= false ->
<<0:1,0:1>>;
Enc13@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc13@element}}})
end;
Enc11@element =:= true ->
if Enc13@element =:= false ->
<<1:1,0:1>>;
Enc13@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc13@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc11@element}}})
end
end,
begin
%% attribute roadSignInfo(6) with type CfgRoadSignInfo
Enc15@element = element(7, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgRoadSignInfo(Enc15@element)
end
end,
begin
%% attribute lowLaneMarkReflect(7) with type INTEGER
Enc17@element = element(8, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc17@element@sub = Enc17@element - 1,
if 0 =< Enc17@element@sub, Enc17@element@sub < 100 ->
<<Enc17@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc17@element}}})
end
end
end
end,
begin
%% attribute roadsignIncnstncy(8) with type BOOLEAN
Enc20@element = element(9, Val),
%% attribute laneGeoIncnstncy(9) with type BOOLEAN
Enc22@element = element(10, Val),
if Enc20@element =:= false ->
if Enc22@element =:= false ->
<<0:1,0:1>>;
Enc22@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc22@element}}})
end;
Enc20@element =:= true ->
if Enc22@element =:= false ->
<<1:1,0:1>>;
Enc22@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc22@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc20@element}}})
end
end,
begin
%% attribute incidentDetect(10) with type BOOLEAN
Enc24@element = element(11, Val),
%% attribute workZoneCharDetect(11) with type BOOLEAN
Enc26@element = element(12, Val),
if Enc24@element =:= false ->
if Enc26@element =:= false ->
<<0:1,0:1>>;
Enc26@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc26@element}}})
end;
Enc24@element =:= true ->
if Enc26@element =:= false ->
<<1:1,0:1>>;
Enc26@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc26@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc24@element}}})
end
end,
begin
%% attribute inclWeatherDetect(12) with type BOOLEAN
Enc28@element = element(13, Val),
%% attribute railrdCrossActivated(13) with type BOOLEAN
Enc30@element = element(14, Val),
if Enc28@element =:= false ->
if Enc30@element =:= false ->
<<0:1,0:1>>;
Enc30@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc30@element}}})
end;
Enc28@element =:= true ->
if Enc30@element =:= false ->
<<1:1,0:1>>;
Enc30@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc30@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc28@element}}})
end
end|begin
%% attribute drawBridgeActivated(14) with type BOOLEAN
Enc32@element = element(15, Val),
if Enc32@element =:= false ->
<<0:1>>;
Enc32@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc32@element}}})
end
end].


dec_CfgRoadwayEvents(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute obstacleDetected(1) with type BOOLEAN
{Term1,Bytes3} = begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end,

%% attribute adverseRoadSurface(2) with type BOOLEAN
{Term2,Bytes4} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end,

%% attribute trafficSigEncounters(3) with type CfgTrafficSigEncounters
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
dec_CfgTrafficSigEncounters(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute trfsigLightOut(4) with type BOOLEAN
{Term4,Bytes6} = begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes5,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end,

%% attribute trfsigRoadGeoMismatch(5) with type BOOLEAN
{Term5,Bytes7} = begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes6,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end,

%% attribute roadSignInfo(6) with type CfgRoadSignInfo
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
dec_CfgRoadSignInfo(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute lowLaneMarkReflect(7) with type INTEGER
{Term7,Bytes9} = case Opt band 1 of
1 ->
begin
<<V7@V0:7,V7@Buf1/bitstring>> = Bytes8,
V7@Add2 = V7@V0 + 1,
{V7@Add2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute roadsignIncnstncy(8) with type BOOLEAN
{Term8,Bytes10} = begin
<<V8@V0:1,V8@Buf1/bitstring>> = Bytes9,
V8@Int2 = case V8@V0 of
0 -> false;
1 -> true
end,
{V8@Int2,V8@Buf1}
end,

%% attribute laneGeoIncnstncy(9) with type BOOLEAN
{Term9,Bytes11} = begin
<<V9@V0:1,V9@Buf1/bitstring>> = Bytes10,
V9@Int2 = case V9@V0 of
0 -> false;
1 -> true
end,
{V9@Int2,V9@Buf1}
end,

%% attribute incidentDetect(10) with type BOOLEAN
{Term10,Bytes12} = begin
<<V10@V0:1,V10@Buf1/bitstring>> = Bytes11,
V10@Int2 = case V10@V0 of
0 -> false;
1 -> true
end,
{V10@Int2,V10@Buf1}
end,

%% attribute workZoneCharDetect(11) with type BOOLEAN
{Term11,Bytes13} = begin
<<V11@V0:1,V11@Buf1/bitstring>> = Bytes12,
V11@Int2 = case V11@V0 of
0 -> false;
1 -> true
end,
{V11@Int2,V11@Buf1}
end,

%% attribute inclWeatherDetect(12) with type BOOLEAN
{Term12,Bytes14} = begin
<<V12@V0:1,V12@Buf1/bitstring>> = Bytes13,
V12@Int2 = case V12@V0 of
0 -> false;
1 -> true
end,
{V12@Int2,V12@Buf1}
end,

%% attribute railrdCrossActivated(13) with type BOOLEAN
{Term13,Bytes15} = begin
<<V13@V0:1,V13@Buf1/bitstring>> = Bytes14,
V13@Int2 = case V13@V0 of
0 -> false;
1 -> true
end,
{V13@Int2,V13@Buf1}
end,

%% attribute drawBridgeActivated(14) with type BOOLEAN
{Term14,Bytes16} = begin
<<V14@V0:1,V14@Buf1/bitstring>> = Bytes15,
V14@Int2 = case V14@V0 of
0 -> false;
1 -> true
end,
{V14@Int2,V14@Buf1}
end,

%% Extensions
{Extensions,Bytes17} = case Ext of
0 -> {<<>>,Bytes16};
1 ->
{V15@V0,V15@Buf1} = case Bytes16 of
<<0:1,V15@V3:6,V15@Buf4/bitstring>> ->
V15@Add5 = V15@V3 + 1,
{V15@Add5,V15@Buf4};
<<1:1,V15@Buf2/bitstring>> ->
{V15@V3,V15@Buf4} = case V15@Buf2 of
<<0:1,V15@V6:7,V15@Buf7/bitstring>> when V15@V6 =/= 0 ->
{V15@V6,V15@Buf7};
<<1:1,0:1,V15@V7:14,V15@Buf8/bitstring>> when V15@V7 =/= 0 ->
{V15@V7,V15@Buf8};
<<1:1,1:1,V15@V7:6,V15@Buf8/bitstring>> when V15@V7 =/= 0 ->
V15@Mul9 = V15@V7 * 16384,
{V15@Mul9,V15@Buf8}
end,
{V15@V3,V15@Buf4}
end,
<<V15@V10:V15@V0/bitstring-unit:1,V15@Buf11/bitstring>> = V15@Buf1,
{V15@V10,V15@Buf11}
end,
Bytes18= skipextensions(Bytes17, 1, Extensions),
Res1 = {'CfgRoadwayEvents',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13,Term14},
{Res1,Bytes18}.

enc_CfgTrafficSigEncounters(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute intersections(1) with type SEQUENCE OF
Enc10@element = element(2, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgTrafficSigEncounters_intersections(Enc10@element)
end
end,
begin
%% attribute trfcsigApproachDelay(2) with type INTEGER
Enc12@element = element(3, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc12@element@sub = Enc12@element - 1,
if 0 =< Enc12@element@sub, Enc12@element@sub < 3600 ->
<<Enc12@element@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end
end
end,
begin
%% attribute trfsigApproachSpeed(3) with type INTEGER
Enc15@element = element(4, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc15@element@sub = Enc15@element - 1,
if 0 =< Enc15@element@sub, Enc15@element@sub < 200 ->
Enc15@element@sub;
true ->
exit({error,{asn1,{illegal_integer,Enc15@element}}})
end
end
end
end,
begin
%% attribute trfsigArrivalGreen(4) with type BOOLEAN
Enc18@element = element(5, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
Enc18@element =:= false ->
<<0:1>>;
Enc18@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc18@element}}})
end
end,
begin
%% attribute trfsigArrivalRed(5) with type BOOLEAN
Enc21@element = element(6, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
Enc21@element =:= false ->
<<0:1>>;
Enc21@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc21@element}}})
end
end,
begin
%% attribute trfsigPedDelay(6) with type INTEGER
Enc24@element = element(7, Val),
if Enc24@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc24@element@sub = Enc24@element - 1,
if 0 =< Enc24@element@sub, Enc24@element@sub < 300 ->
<<Enc24@element@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Enc24@element}}})
end
end
end
end,
begin
%% attribute trfsigSpatMismatch(7) with type BOOLEAN
Enc27@element = element(8, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
Enc27@element =:= false ->
<<0:1>>;
Enc27@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc27@element}}})
end
end|begin
%% attribute trfsigSpatTimingError(8) with type BOOLEAN
Enc30@element = element(9, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
Enc30@element =:= false ->
<<0:1>>;
Enc30@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc30@element}}})
end
end].
enc_CfgTrafficSigEncounters_intersections(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 100 ->
[<<Enc2@len@sub:7>>|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.



dec_CfgTrafficSigEncounters(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute intersections(1) with type SEQUENCE OF
{Term1,Bytes3} = case (Opt bsr 7) band 1 of
1 ->
dec_CfgTrafficSigEncounters_intersections(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute trfcsigApproachDelay(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V3@V0:12,V3@Buf1/bitstring>> = Bytes3,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute trfsigApproachSpeed(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes4,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute trfsigArrivalGreen(4) with type BOOLEAN
{Term4,Bytes6} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes5,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute trfsigArrivalRed(5) with type BOOLEAN
{Term5,Bytes7} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes6,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute trfsigPedDelay(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V7@V0:9,V7@Buf1/bitstring>> = Bytes7,
V7@Add2 = V7@V0 + 1,
{V7@Add2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute trfsigSpatMismatch(7) with type BOOLEAN
{Term7,Bytes9} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V8@V0:1,V8@Buf1/bitstring>> = Bytes8,
V8@Int2 = case V8@V0 of
0 -> false;
1 -> true
end,
{V8@Int2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute trfsigSpatTimingError(8) with type BOOLEAN
{Term8,Bytes10} = case Opt band 1 of
1 ->
begin
<<V9@V0:1,V9@Buf1/bitstring>> = Bytes9,
V9@Int2 = case V9@V0 of
0 -> false;
1 -> true
end,
{V9@Int2,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% Extensions
{Extensions,Bytes11} = case Ext of
0 -> {<<>>,Bytes10};
1 ->
{V10@V0,V10@Buf1} = case Bytes10 of
<<0:1,V10@V3:6,V10@Buf4/bitstring>> ->
V10@Add5 = V10@V3 + 1,
{V10@Add5,V10@Buf4};
<<1:1,V10@Buf2/bitstring>> ->
{V10@V3,V10@Buf4} = case V10@Buf2 of
<<0:1,V10@V6:7,V10@Buf7/bitstring>> when V10@V6 =/= 0 ->
{V10@V6,V10@Buf7};
<<1:1,0:1,V10@V7:14,V10@Buf8/bitstring>> when V10@V7 =/= 0 ->
{V10@V7,V10@Buf8};
<<1:1,1:1,V10@V7:6,V10@Buf8/bitstring>> when V10@V7 =/= 0 ->
V10@Mul9 = V10@V7 * 16384,
{V10@Mul9,V10@Buf8}
end,
{V10@V3,V10@Buf4}
end,
<<V10@V10:V10@V0/bitstring-unit:1,V10@Buf11/bitstring>> = V10@Buf1,
{V10@V10,V10@Buf11}
end,
Bytes12= skipextensions(Bytes11, 1, Extensions),
Res1 = {'CfgTrafficSigEncounters',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8},
{Res1,Bytes12}.


dec_CfgTrafficSigEncounters_intersections(Bytes) ->
%% Length with constraint {1,100}
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components3(V1@Add2, V1@Buf1, []).

enc_CfgRoadSignInfo(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute roadsignDetection(1) with type CfgRoadSignTypes
Enc4@element = element(2, Val),
enc_CfgRoadSignTypes(Enc4@element)
end,
begin
%% attribute lowRoadsignReflect1(2) with type INTEGER
Enc5@element = element(3, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 250 ->
Enc5@element@sub;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end
end
end|begin
%% attribute lowRoadsignReflect2(3) with type INTEGER
Enc8@element = element(4, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc8@element@sub = Enc8@element - 1,
if 0 =< Enc8@element@sub, Enc8@element@sub < 250 ->
[Enc8@element@sub];
true ->
exit({error,{asn1,{illegal_integer,Enc8@element}}})
end
end
end
end].


dec_CfgRoadSignInfo(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute roadsignDetection(1) with type CfgRoadSignTypes
{Term1,Bytes3} = dec_CfgRoadSignTypes(Bytes2),

%% attribute lowRoadsignReflect1(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes3,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute lowRoadsignReflect2(3) with type INTEGER
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes4,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V5@V0,V5@Buf1} = case Bytes5 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'CfgRoadSignInfo',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_CfgRoadSignTypes(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc11@element = element(12, Val),
Enc12@element = element(13, Val),
if Enc11@element =:= asn1_NOVALUE ->
if Enc12@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc12@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc13@element = element(14, Val),
Enc14@element = element(15, Val),
if Enc13@element =:= asn1_NOVALUE ->
if Enc14@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc14@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute whiteOnGreen(1) with type BOOLEAN
Enc16@element = element(2, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
Enc16@element =:= false ->
<<0:1>>;
Enc16@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc16@element}}})
end
end,
begin
%% attribute blackOnYellow(2) with type BOOLEAN
Enc19@element = element(3, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
Enc19@element =:= false ->
<<0:1>>;
Enc19@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc19@element}}})
end
end,
begin
%% attribute blackOnOrange(3) with type BOOLEAN
Enc22@element = element(4, Val),
if Enc22@element =:= asn1_NOVALUE ->
[];
Enc22@element =:= false ->
<<0:1>>;
Enc22@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc22@element}}})
end
end,
begin
%% attribute whiteOnRed(4) with type BOOLEAN
Enc25@element = element(5, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
Enc25@element =:= false ->
<<0:1>>;
Enc25@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc25@element}}})
end
end,
begin
%% attribute blackOnWhite(5) with type BOOLEAN
Enc28@element = element(6, Val),
if Enc28@element =:= asn1_NOVALUE ->
[];
Enc28@element =:= false ->
<<0:1>>;
Enc28@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc28@element}}})
end
end,
begin
%% attribute octagon(6) with type BOOLEAN
Enc31@element = element(7, Val),
if Enc31@element =:= asn1_NOVALUE ->
[];
Enc31@element =:= false ->
<<0:1>>;
Enc31@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc31@element}}})
end
end,
begin
%% attribute eqlatTriangle(7) with type BOOLEAN
Enc34@element = element(8, Val),
if Enc34@element =:= asn1_NOVALUE ->
[];
Enc34@element =:= false ->
<<0:1>>;
Enc34@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc34@element}}})
end
end,
begin
%% attribute circle(8) with type BOOLEAN
Enc37@element = element(9, Val),
if Enc37@element =:= asn1_NOVALUE ->
[];
Enc37@element =:= false ->
<<0:1>>;
Enc37@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc37@element}}})
end
end,
begin
%% attribute pennant(9) with type BOOLEAN
Enc40@element = element(10, Val),
if Enc40@element =:= asn1_NOVALUE ->
[];
Enc40@element =:= false ->
<<0:1>>;
Enc40@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc40@element}}})
end
end,
begin
%% attribute pentagon(10) with type BOOLEAN
Enc43@element = element(11, Val),
if Enc43@element =:= asn1_NOVALUE ->
[];
Enc43@element =:= false ->
<<0:1>>;
Enc43@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc43@element}}})
end
end,
begin
%% attribute crossbuck(11) with type BOOLEAN
Enc46@element = element(12, Val),
if Enc46@element =:= asn1_NOVALUE ->
[];
Enc46@element =:= false ->
<<0:1>>;
Enc46@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc46@element}}})
end
end,
begin
%% attribute diamond(12) with type BOOLEAN
Enc49@element = element(13, Val),
if Enc49@element =:= asn1_NOVALUE ->
[];
Enc49@element =:= false ->
<<0:1>>;
Enc49@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc49@element}}})
end
end,
begin
%% attribute trapezoid(13) with type BOOLEAN
Enc52@element = element(14, Val),
if Enc52@element =:= asn1_NOVALUE ->
[];
Enc52@element =:= false ->
<<0:1>>;
Enc52@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc52@element}}})
end
end|begin
%% attribute other(14) with type BOOLEAN
Enc55@element = element(15, Val),
if Enc55@element =:= asn1_NOVALUE ->
[];
Enc55@element =:= false ->
<<0:1>>;
Enc55@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc55@element}}})
end
end].


dec_CfgRoadSignTypes(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:14,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute whiteOnGreen(1) with type BOOLEAN
{Term1,Bytes3} = case (Opt bsr 13) band 1 of
1 ->
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute blackOnYellow(2) with type BOOLEAN
{Term2,Bytes4} = case (Opt bsr 12) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute blackOnOrange(3) with type BOOLEAN
{Term3,Bytes5} = case (Opt bsr 11) band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute whiteOnRed(4) with type BOOLEAN
{Term4,Bytes6} = case (Opt bsr 10) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute blackOnWhite(5) with type BOOLEAN
{Term5,Bytes7} = case (Opt bsr 9) band 1 of
1 ->
begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes6,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute octagon(6) with type BOOLEAN
{Term6,Bytes8} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V8@V0:1,V8@Buf1/bitstring>> = Bytes7,
V8@Int2 = case V8@V0 of
0 -> false;
1 -> true
end,
{V8@Int2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute eqlatTriangle(7) with type BOOLEAN
{Term7,Bytes9} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V9@V0:1,V9@Buf1/bitstring>> = Bytes8,
V9@Int2 = case V9@V0 of
0 -> false;
1 -> true
end,
{V9@Int2,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute circle(8) with type BOOLEAN
{Term8,Bytes10} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V10@V0:1,V10@Buf1/bitstring>> = Bytes9,
V10@Int2 = case V10@V0 of
0 -> false;
1 -> true
end,
{V10@Int2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute pennant(9) with type BOOLEAN
{Term9,Bytes11} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V11@V0:1,V11@Buf1/bitstring>> = Bytes10,
V11@Int2 = case V11@V0 of
0 -> false;
1 -> true
end,
{V11@Int2,V11@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute pentagon(10) with type BOOLEAN
{Term10,Bytes12} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V12@V0:1,V12@Buf1/bitstring>> = Bytes11,
V12@Int2 = case V12@V0 of
0 -> false;
1 -> true
end,
{V12@Int2,V12@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute crossbuck(11) with type BOOLEAN
{Term11,Bytes13} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V13@V0:1,V13@Buf1/bitstring>> = Bytes12,
V13@Int2 = case V13@V0 of
0 -> false;
1 -> true
end,
{V13@Int2,V13@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute diamond(12) with type BOOLEAN
{Term12,Bytes14} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V14@V0:1,V14@Buf1/bitstring>> = Bytes13,
V14@Int2 = case V14@V0 of
0 -> false;
1 -> true
end,
{V14@Int2,V14@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% attribute trapezoid(13) with type BOOLEAN
{Term13,Bytes15} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V15@V0:1,V15@Buf1/bitstring>> = Bytes14,
V15@Int2 = case V15@V0 of
0 -> false;
1 -> true
end,
{V15@Int2,V15@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% attribute other(14) with type BOOLEAN
{Term14,Bytes16} = case Opt band 1 of
1 ->
begin
<<V16@V0:1,V16@Buf1/bitstring>> = Bytes15,
V16@Int2 = case V16@V0 of
0 -> false;
1 -> true
end,
{V16@Int2,V16@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes15}
end,

%% Extensions
{Extensions,Bytes17} = case Ext of
0 -> {<<>>,Bytes16};
1 ->
{V17@V0,V17@Buf1} = case Bytes16 of
<<0:1,V17@V3:6,V17@Buf4/bitstring>> ->
V17@Add5 = V17@V3 + 1,
{V17@Add5,V17@Buf4};
<<1:1,V17@Buf2/bitstring>> ->
{V17@V3,V17@Buf4} = case V17@Buf2 of
<<0:1,V17@V6:7,V17@Buf7/bitstring>> when V17@V6 =/= 0 ->
{V17@V6,V17@Buf7};
<<1:1,0:1,V17@V7:14,V17@Buf8/bitstring>> when V17@V7 =/= 0 ->
{V17@V7,V17@Buf8};
<<1:1,1:1,V17@V7:6,V17@Buf8/bitstring>> when V17@V7 =/= 0 ->
V17@Mul9 = V17@V7 * 16384,
{V17@Mul9,V17@Buf8}
end,
{V17@V3,V17@Buf4}
end,
<<V17@V10:V17@V0/bitstring-unit:1,V17@Buf11/bitstring>> = V17@Buf1,
{V17@V10,V17@Buf11}
end,
Bytes18= skipextensions(Bytes17, 1, Extensions),
Res1 = {'CfgRoadSignTypes',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13,Term14},
{Res1,Bytes18}.

enc_CfgCommSysPerfEvents(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute j2945-1ChanBusyThresh(1) with type INTEGER
Enc12@element = element(2, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc12@element@sub = Enc12@element - 1,
if 0 =< Enc12@element@sub, Enc12@element@sub < 100 ->
<<Enc12@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end
end
end,
begin
%% attribute rfDataRsuInfo(2) with type BOOLEAN
Enc15@element = element(3, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
Enc15@element =:= false ->
<<0:1>>;
Enc15@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc15@element}}})
end
end,
begin
%% attribute numRsusObservedThresh(3) with type INTEGER
Enc18@element = element(4, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc18@element@sub = Enc18@element - 1,
if 0 =< Enc18@element@sub, Enc18@element@sub < 254 ->
Enc18@element@sub;
true ->
exit({error,{asn1,{illegal_integer,Enc18@element}}})
end
end
end
end,
begin
%% attribute rfV2xJamDetectThresh(4) with type INTEGER
Enc21@element = element(5, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc21@element@sub = Enc21@element - 1,
if 0 =< Enc21@element@sub, Enc21@element@sub < 140 ->
Enc21@element@sub;
true ->
exit({error,{asn1,{illegal_integer,Enc21@element}}})
end
end
end
end,
begin
%% attribute j2945-1VehDensThresh(5) with type INTEGER
Enc24@element = element(6, Val),
if Enc24@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc24@element@sub = Enc24@element - 1,
if 0 =< Enc24@element@sub, Enc24@element@sub < 255 ->
Enc24@element@sub;
true ->
exit({error,{asn1,{illegal_integer,Enc24@element}}})
end
end
end
end,
begin
%% attribute j2945-1CqiBelowThresh(6) with type INTEGER
Enc27@element = element(7, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc27@element@sub = Enc27@element - 1,
if 0 =< Enc27@element@sub, Enc27@element@sub < 100 ->
<<Enc27@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc27@element}}})
end
end
end
end,
begin
%% attribute j2945-1TrackErrorThresh(7) with type INTEGER
Enc30@element = element(8, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc30@element@sub = Enc30@element - 1,
if 0 =< Enc30@element@sub, Enc30@element@sub < 100 ->
<<Enc30@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc30@element}}})
end
end
end
end,
begin
%% attribute gnssHdopExceedsThresh(8) with type INTEGER
Enc33@element = element(9, Val),
if Enc33@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc33@element@sub = Enc33@element - 1,
if 0 =< Enc33@element@sub, Enc33@element@sub < 20 ->
<<Enc33@element@sub:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc33@element}}})
end
end
end
end,
begin
%% attribute gnssSatsBelowThresh(9) with type INTEGER
Enc36@element = element(10, Val),
if Enc36@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc36@element@sub = Enc36@element - 1,
if 0 =< Enc36@element@sub, Enc36@element@sub < 20 ->
<<Enc36@element@sub:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc36@element}}})
end
end
end
end|begin
%% attribute gnssJammingDetect(10) with type BOOLEAN
Enc39@element = element(11, Val),
if Enc39@element =:= asn1_NOVALUE ->
[];
Enc39@element =:= false ->
<<0:1>>;
Enc39@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc39@element}}})
end
end].


dec_CfgCommSysPerfEvents(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute j2945-1ChanBusyThresh(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 9) band 1 of
1 ->
begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute rfDataRsuInfo(2) with type BOOLEAN
{Term2,Bytes4} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute numRsusObservedThresh(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute rfV2xJamDetectThresh(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + 1,
{V6@Add2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute j2945-1VehDensThresh(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V7@V0:8,V7@Buf1/bitstring>> = Bytes6,
V7@Add2 = V7@V0 + 1,
{V7@Add2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute j2945-1CqiBelowThresh(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V8@V0:7,V8@Buf1/bitstring>> = Bytes7,
V8@Add2 = V8@V0 + 1,
{V8@Add2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute j2945-1TrackErrorThresh(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V9@V0:7,V9@Buf1/bitstring>> = Bytes8,
V9@Add2 = V9@V0 + 1,
{V9@Add2,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute gnssHdopExceedsThresh(8) with type INTEGER
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V10@V0:5,V10@Buf1/bitstring>> = Bytes9,
V10@Add2 = V10@V0 + 1,
{V10@Add2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute gnssSatsBelowThresh(9) with type INTEGER
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V11@V0:5,V11@Buf1/bitstring>> = Bytes10,
V11@Add2 = V11@V0 + 1,
{V11@Add2,V11@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute gnssJammingDetect(10) with type BOOLEAN
{Term10,Bytes12} = case Opt band 1 of
1 ->
begin
<<V12@V0:1,V12@Buf1/bitstring>> = Bytes11,
V12@Int2 = case V12@V0 of
0 -> false;
1 -> true
end,
{V12@Int2,V12@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V13@V0,V13@Buf1} = case Bytes12 of
<<0:1,V13@V3:6,V13@Buf4/bitstring>> ->
V13@Add5 = V13@V3 + 1,
{V13@Add5,V13@Buf4};
<<1:1,V13@Buf2/bitstring>> ->
{V13@V3,V13@Buf4} = case V13@Buf2 of
<<0:1,V13@V6:7,V13@Buf7/bitstring>> when V13@V6 =/= 0 ->
{V13@V6,V13@Buf7};
<<1:1,0:1,V13@V7:14,V13@Buf8/bitstring>> when V13@V7 =/= 0 ->
{V13@V7,V13@Buf8};
<<1:1,1:1,V13@V7:6,V13@Buf8/bitstring>> when V13@V7 =/= 0 ->
V13@Mul9 = V13@V7 * 16384,
{V13@Mul9,V13@Buf8}
end,
{V13@V3,V13@Buf4}
end,
<<V13@V10:V13@V0/bitstring-unit:1,V13@Buf11/bitstring>> = V13@Buf1,
{V13@V10,V13@Buf11}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = {'CfgCommSysPerfEvents',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10},
{Res1,Bytes14}.

enc_CfgAveragedAndSummaryTriggers(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= averagedTriggers ->
[<<0:1,0:1>>|enc_CfgAveragedTriggers(ChoiceVal)];
ChoiceTag =:= summaryTriggers ->
[<<0:1,1:1>>|enc_CfgSummaryTriggers(ChoiceVal)]
end.


dec_CfgAveragedAndSummaryTriggers(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_CfgAveragedTriggers(Bytes2)
end,
{{averagedTriggers,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_CfgSummaryTriggers(Bytes2)
end,
{{summaryTriggers,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_CfgAveragedTriggers(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
%% attribute avgSpeed(1) with type BOOLEAN
Enc7@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc7@element =:= asn1_NOVALUE ->
<<0:1>>;
Enc7@element =:= false ->
<<0:1,0:1>>;
Enc7@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc7@element}}})
end;
true ->
if Enc7@element =:= asn1_NOVALUE ->
<<1:1>>;
Enc7@element =:= false ->
<<1:1,0:1>>;
Enc7@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc7@element}}})
end
end
end,
begin
%% attribute avgStopDuration(2) with type BOOLEAN
Enc10@element = element(3, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
Enc10@element =:= false ->
<<0:1>>;
Enc10@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc10@element}}})
end
end,
begin
%% attribute avgFuelConsumption(3) with type BOOLEAN
Enc13@element = element(4, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
Enc13@element =:= false ->
<<0:1>>;
Enc13@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc13@element}}})
end
end,
begin
%% attribute avgEmissions(4) with type BOOLEAN
Enc16@element = element(5, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
Enc16@element =:= false ->
<<0:1>>;
Enc16@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc16@element}}})
end
end|begin
%% attribute avgNumOfOccupants(5) with type BOOLEAN
Enc19@element = element(6, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
Enc19@element =:= false ->
<<0:1>>;
Enc19@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc19@element}}})
end
end].


dec_CfgAveragedTriggers(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute avgSpeed(1) with type BOOLEAN
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute avgStopDuration(2) with type BOOLEAN
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute avgFuelConsumption(3) with type BOOLEAN
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute avgEmissions(4) with type BOOLEAN
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute avgNumOfOccupants(5) with type BOOLEAN
{Term5,Bytes7} = case Opt band 1 of
1 ->
begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes6,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V8@V0,V8@Buf1} = case Bytes7 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8};
<<1:1,1:1,V8@V7:6,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
V8@Mul9 = V8@V7 * 16384,
{V8@Mul9,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V10:V8@V0/bitstring-unit:1,V8@Buf11/bitstring>> = V8@Buf1,
{V8@V10,V8@Buf11}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'CfgAveragedTriggers',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes9}.

enc_CfgSummaryTriggers(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc11@element = element(12, Val),
Enc12@element = element(13, Val),
if Enc11@element =:= asn1_NOVALUE ->
if Enc12@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc12@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute regTravelTime(1) with type BOOLEAN
Enc14@element = element(2, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
Enc14@element =:= false ->
<<0:1>>;
Enc14@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc14@element}}})
end
end,
begin
%% attribute regVehDistTraveled(2) with type BOOLEAN
Enc17@element = element(3, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
Enc17@element =:= false ->
<<0:1>>;
Enc17@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc17@element}}})
end
end,
begin
%% attribute regVehTimeTraveled(3) with type BOOLEAN
Enc20@element = element(4, Val),
if Enc20@element =:= asn1_NOVALUE ->
[];
Enc20@element =:= false ->
<<0:1>>;
Enc20@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc20@element}}})
end
end,
begin
%% attribute fuelConsumption(4) with type BOOLEAN
Enc23@element = element(5, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
Enc23@element =:= false ->
<<0:1>>;
Enc23@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc23@element}}})
end
end,
begin
%% attribute totalVehEmissions(5) with type BOOLEAN
Enc26@element = element(6, Val),
if Enc26@element =:= asn1_NOVALUE ->
[];
Enc26@element =:= false ->
<<0:1>>;
Enc26@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc26@element}}})
end
end,
begin
%% attribute numOfLowSpeedEvents(6) with type CfgLowSpeedCriteria
Enc29@element = element(7, Val),
if Enc29@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgLowSpeedCriteria(Enc29@element)
end
end,
begin
%% attribute timeStopped(7) with type CfgStoppedCriteria
Enc31@element = element(8, Val),
if Enc31@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgStoppedCriteria(Enc31@element)
end
end,
begin
%% attribute numOfStopped(8) with type CfgStoppedCriteria
Enc33@element = element(9, Val),
if Enc33@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgStoppedCriteria(Enc33@element)
end
end,
begin
%% attribute locOfStops(9) with type BOOLEAN
Enc35@element = element(10, Val),
if Enc35@element =:= asn1_NOVALUE ->
[];
Enc35@element =:= false ->
<<0:1>>;
Enc35@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc35@element}}})
end
end,
begin
%% attribute regNumOfVehPassed(10) with type BOOLEAN
Enc38@element = element(11, Val),
if Enc38@element =:= asn1_NOVALUE ->
[];
Enc38@element =:= false ->
<<0:1>>;
Enc38@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc38@element}}})
end
end,
begin
%% attribute regNumOfSurpassedVeh(11) with type BOOLEAN
Enc41@element = element(12, Val),
if Enc41@element =:= asn1_NOVALUE ->
[];
Enc41@element =:= false ->
<<0:1>>;
Enc41@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc41@element}}})
end
end|begin
%% attribute totalMsgsReceived(12) with type CfgMsgRecepIndicators
Enc44@element = element(13, Val),
if Enc44@element =:= asn1_NOVALUE ->
[];
true ->
enc_CfgMsgRecepIndicators(Enc44@element)
end
end].


dec_CfgSummaryTriggers(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:12,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute regTravelTime(1) with type BOOLEAN
{Term1,Bytes3} = case (Opt bsr 11) band 1 of
1 ->
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute regVehDistTraveled(2) with type BOOLEAN
{Term2,Bytes4} = case (Opt bsr 10) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute regVehTimeTraveled(3) with type BOOLEAN
{Term3,Bytes5} = case (Opt bsr 9) band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute fuelConsumption(4) with type BOOLEAN
{Term4,Bytes6} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute totalVehEmissions(5) with type BOOLEAN
{Term5,Bytes7} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes6,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute numOfLowSpeedEvents(6) with type CfgLowSpeedCriteria
{Term6,Bytes8} = case (Opt bsr 6) band 1 of
1 ->
dec_CfgLowSpeedCriteria(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute timeStopped(7) with type CfgStoppedCriteria
{Term7,Bytes9} = case (Opt bsr 5) band 1 of
1 ->
dec_CfgStoppedCriteria(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute numOfStopped(8) with type CfgStoppedCriteria
{Term8,Bytes10} = case (Opt bsr 4) band 1 of
1 ->
dec_CfgStoppedCriteria(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute locOfStops(9) with type BOOLEAN
{Term9,Bytes11} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V8@V0:1,V8@Buf1/bitstring>> = Bytes10,
V8@Int2 = case V8@V0 of
0 -> false;
1 -> true
end,
{V8@Int2,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute regNumOfVehPassed(10) with type BOOLEAN
{Term10,Bytes12} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V9@V0:1,V9@Buf1/bitstring>> = Bytes11,
V9@Int2 = case V9@V0 of
0 -> false;
1 -> true
end,
{V9@Int2,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute regNumOfSurpassedVeh(11) with type BOOLEAN
{Term11,Bytes13} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V10@V0:1,V10@Buf1/bitstring>> = Bytes12,
V10@Int2 = case V10@V0 of
0 -> false;
1 -> true
end,
{V10@Int2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute totalMsgsReceived(12) with type CfgMsgRecepIndicators
{Term12,Bytes14} = case Opt band 1 of
1 ->
dec_CfgMsgRecepIndicators(Bytes13);
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% Extensions
{Extensions,Bytes15} = case Ext of
0 -> {<<>>,Bytes14};
1 ->
{V11@V0,V11@Buf1} = case Bytes14 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8};
<<1:1,1:1,V11@V7:6,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
V11@Mul9 = V11@V7 * 16384,
{V11@Mul9,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V10:V11@V0/bitstring-unit:1,V11@Buf11/bitstring>> = V11@Buf1,
{V11@V10,V11@Buf11}
end,
Bytes16= skipextensions(Bytes15, 1, Extensions),
Res1 = {'CfgSummaryTriggers',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12},
{Res1,Bytes16}.

enc_CfgLowSpeedCriteria(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute lowSpeedThreshold(1) with type INTEGER
Enc3@element = element(2, Val),
Enc3@element@sub = Enc3@element - 5,
if 0 =< Enc3@element@sub, Enc3@element@sub < 96 ->
<<Enc3@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute lowSpeedTimeThresh(2) with type INTEGER
Enc5@element = element(3, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 30 ->
<<Enc5@element@sub:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end
end
end].


dec_CfgLowSpeedCriteria(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute lowSpeedThreshold(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 5,
{V3@Add2,V3@Buf1}
end,

%% attribute lowSpeedTimeThresh(2) with type INTEGER
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:5,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'CfgLowSpeedCriteria',Term1,Term2},
{Res1,Bytes6}.

enc_CfgStoppedCriteria(Val) ->
[begin
%% attribute stoppedSpeedThreshold(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - 1,
if 0 =< Enc2@element@sub, Enc2@element@sub < 30 ->
<<0:1,Enc2@element@sub:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute amountOfTimeBelow(2) with type INTEGER
Enc4@element = element(3, Val),
Enc4@element@sub = Enc4@element - 1,
if 0 =< Enc4@element@sub, Enc4@element@sub < 300 ->
<<Enc4@element@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_CfgStoppedCriteria(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute stoppedSpeedThreshold(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,

%% attribute amountOfTimeBelow(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:9,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'CfgStoppedCriteria',Term1,Term2},
{Res1,Bytes5}.

typeinfo('ProbeDataConfigMessage') ->
  {sof,{typeinfo,{'ProbeDataConfig','ProbeDataConfig'}}};
typeinfo('ProbeDataConfig') ->
  {sequence,'ProbeDataConfig',4,[{<<100,101,115,99,114,105,112,116,111,114>>,{typeinfo,{'ProbeDataConfig','ConfigDescriptor'}},mandatory},{<<116,114,105,103,103,101,114,115>>,{typeinfo,{'ProbeDataConfig','ConfigTriggers'}},mandatory},{<<109,97,120,65,103,101,79,102,68,97,116,97>>,{'INTEGER',{1,90}},mandatory},{<<98,111,117,110,100,97,114,121>>,{typeinfo,{'ProbeDataConfig','ConfigBoundary'}},'OPTIONAL'}]};
typeinfo('ConfigDescriptor') ->
  {sequence,'ConfigDescriptor',4,[{<<105,100,101,110,116,105,102,105,101,114>>,{'INTEGER',{1,255}},mandatory},{<<118,101,104,67,108,97,115,115>>,{typeinfo,{'ProbeDataConfig','CfgVehicleClass'}},'OPTIONAL'},{<<114,111,97,100,65,117,116,104,111,114,105,116,121,73,68>>,{typeinfo,{'Common','RoadAuthorityID'}},'OPTIONAL'},{<<112,101,114,99,101,110,116,79,102,82,101,115,112>>,{'INTEGER',{1,10}},'OPTIONAL'}]};
typeinfo('ConfigId') ->
  {'INTEGER',{1,255}};
typeinfo('CfgVehicleClass') ->
  {sequence,'CfgVehicleClass',13,[{<<109,111,116,111,114,99,121,99,108,101,115>>,'BOOLEAN',mandatory},{<<112,97,115,115,101,110,103,101,114,67,97,114,115>>,'BOOLEAN',mandatory},{<<111,116,104,101,114,50,97,120,108,101,52,116,105,114,101,83,105,110,103,108,101,85,110,105,116,86,101,104,115>>,'BOOLEAN',mandatory},{<<98,117,115,101,115>>,'BOOLEAN',mandatory},{<<116,119,111,65,120,108,101,54,84,105,114,101,83,105,110,103,108,101,85,110,105,116,84,114,117,99,107,115>>,'BOOLEAN',mandatory},{<<116,104,114,101,101,65,120,108,101,83,105,110,103,108,101,85,110,105,116,84,114,117,99,107,115>>,'BOOLEAN',mandatory},{<<102,111,117,114,79,114,77,111,114,101,65,120,108,101,83,105,110,103,108,101,85,110,105,116,84,114,117,99,107,115>>,'BOOLEAN',mandatory},{<<102,111,117,114,79,114,70,101,119,101,114,65,120,108,101,83,105,110,103,108,101,84,114,97,105,108,101,114,84,114,117,99,107,115>>,'BOOLEAN',mandatory},{<<102,105,118,101,65,120,108,101,83,105,110,103,108,101,84,114,97,105,108,101,114,84,114,117,99,107,115>>,'BOOLEAN',mandatory},{<<115,105,120,79,114,77,111,114,101,65,120,108,101,83,105,110,103,108,101,84,114,97,105,108,101,114,84,114,117,99,107,115>>,'BOOLEAN',mandatory},{<<102,105,118,101,79,114,70,101,119,101,114,65,120,108,101,77,117,108,116,105,84,114,97,105,108,101,114,84,114,117,99,107,115>>,'BOOLEAN',mandatory},{<<115,105,120,65,120,108,101,77,117,108,116,105,84,114,97,105,108,101,114,84,114,117,99,107,115>>,'BOOLEAN',mandatory},{<<115,101,118,101,110,79,114,77,111,114,101,65,120,108,101,77,117,108,116,105,84,114,97,105,108,101,114,84,114,117,99,107,115>>,'BOOLEAN',mandatory}]};
typeinfo('ConfigBoundary') ->
  {choice,#{<<103,101,111,65,110,100,68,105,115,116,66,111,117,110,100,97,114,121>> => {typeinfo,{'TravelerInformation','ValidRegion'}},<<116,101,109,112,111,114,97,108,66,111,117,110,100,97,114,121>> => {typeinfo,{'ProbeDataConfig','ConfigTemporalBoundary'}}}};
typeinfo('ConfigTemporalBoundary') ->
  {sequence,'ConfigTemporalBoundary',3,[{<<98,101,103,105,110,84,105,109,101>>,{typeinfo,{'Common','DDateTime'}},mandatory},{<<101,110,100,84,105,109,101>>,{typeinfo,{'Common','DDateTime'}},mandatory},{<<114,101,99,117,114,114,105,110,103>>,{typeinfo,{'ProbeDataConfig','CfgEventRecurrence'}},mandatory}]};
typeinfo('CfgEventRecurrence') ->
  {sequence,'CfgEventRecurrence',12,[{<<115,116,97,114,116,84,105,109,101>>,{typeinfo,{'Common','DTime'}},'OPTIONAL'},{<<101,110,100,84,105,109,101>>,{typeinfo,{'Common','DTime'}},'OPTIONAL'},{<<115,116,97,114,116,68,97,116,101>>,{typeinfo,{'Common','DDate'}},'OPTIONAL'},{<<101,110,100,68,97,116,101>>,{typeinfo,{'Common','DDate'}},'OPTIONAL'},{<<109,111,110,100,97,121>>,'BOOLEAN',mandatory},{<<116,117,101,115,100,97,121>>,'BOOLEAN',mandatory},{<<119,101,100,110,101,115,100,97,121>>,'BOOLEAN',mandatory},{<<116,104,117,114,115,100,97,121>>,'BOOLEAN',mandatory},{<<102,114,105,100,97,121>>,'BOOLEAN',mandatory},{<<115,97,116,117,114,100,97,121>>,'BOOLEAN',mandatory},{<<115,117,110,100,97,121>>,'BOOLEAN',mandatory},{<<101,120,99,108,117,115,105,111,110>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('ConfigTriggers') ->
  {choice,#{<<97,118,103,65,110,100,83,117,109,84,114,105,103,103,101,114,115>> => {typeinfo,{'ProbeDataConfig','CfgAveragedAndSummaryTriggers'}},<<105,110,115,116,97,110,116,97,110,101,111,117,115,84,114,105,103,103,101,114,115>> => {typeinfo,{'ProbeDataConfig','CfgInstantaneousEventTriggers'}}}};
typeinfo('CfgInstantaneousEventTriggers') ->
  {choice,#{<<99,111,109,109,83,121,115,80,101,114,102,69,118,101,110,116,115>> => {typeinfo,{'ProbeDataConfig','CfgCommSysPerfEvents'}},<<105,110,116,101,114,118,97,108,69,118,101,110,116,115>> => {typeinfo,{'ProbeDataConfig','CfgIntervalEvents'}},<<114,111,97,100,119,97,121,69,118,101,110,116,115>> => {typeinfo,{'ProbeDataConfig','CfgRoadwayEvents'}},<<118,101,104,105,99,108,101,69,118,101,110,116,115>> => {typeinfo,{'ProbeDataConfig','CfgVehicleEvents'}}}};
typeinfo('CfgIntervalEvents') ->
  {sequence,'CfgIntervalEvents',6,[{<<105,110,116,101,114,118,97,108>>,{typeinfo,{'ProbeDataConfig','CfgInterval'}},mandatory},{<<119,105,112,101,114,83,116,97,116,117,115>>,'BOOLEAN','OPTIONAL'},{<<118,101,104,67,111,117,110,116>>,'BOOLEAN','OPTIONAL'},{<<119,101,97,116,104,101,114,68,97,116,97>>,'BOOLEAN','OPTIONAL'},{<<116,114,97,110,115,105,116,86,101,104,68,97,116,97>>,{typeinfo,{'ProbeDataConfig','CfgTransitVehicleData'}},'OPTIONAL'},{<<110,117,109,79,102,79,99,99,117,112,97,110,116,115>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('CfgTransitVehicleData') ->
  {sequence,'CfgTransitVehicleData',3,[{<<99,117,114,114,78,117,109,80,97,115,110,103,101,114,115>>,'BOOLEAN','OPTIONAL'},{<<97,118,103,78,117,109,80,97,115,110,103,101,114,115>>,'BOOLEAN','OPTIONAL'},{<<116,114,110,115,116,86,101,104,83,99,104,65,100,104>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('CfgInterval') ->
  {choice,#{<<100,105,115,116,97,110,99,101,73,110,116,101,114,118,97,108>> => {'INTEGER',{1,100}},<<116,105,109,101,73,110,116,101,114,118,97,108>> => {'INTEGER',{1,36000}}}};
typeinfo('CfgVehicleEvents') ->
  {sequence,'CfgVehicleEvents',12,[{<<104,101,97,100,76,105,103,104,116,115>>,'BOOLEAN','OPTIONAL'},{<<102,111,103,76,105,103,104,116,115>>,'BOOLEAN','OPTIONAL'},{<<104,97,122,97,114,100,76,105,103,104,116,115>>,'BOOLEAN','OPTIONAL'},{<<107,105,110,101,109,97,116,105,99,69,118,101,110,116,115>>,{typeinfo,{'ProbeDataConfig','CfgKinematicEvents'}},'OPTIONAL'},{<<119,105,112,101,114,83,116,97,116,117,115,67,104,97,110,103,101>>,'BOOLEAN','OPTIONAL'},{<<108,111,119,83,112,101,101,100>>,{typeinfo,{'ProbeDataConfig','CfgLowSpeedCriteria'}},'OPTIONAL'},{<<114,101,115,117,109,101,100,83,112,101,101,100>>,{'INTEGER',{1,100}},'OPTIONAL'},{<<118,101,104,69,110,116,114,115,69,120,105,116,115,82,101,103,105,111,110>>,'BOOLEAN','OPTIONAL'},{<<101,109,101,114,86,101,104,68,101,116,101,99,116>>,'BOOLEAN','OPTIONAL'},{<<101,109,101,114,65,110,100,84,114,97,110,115,73,110,102,111>>,{typeinfo,{'ProbeDataConfig','CfgEmerAndTransitInfo'}},'OPTIONAL'},{<<118,50,120,77,115,103,82,101,99,112,116,105,111,110>>,{typeinfo,{'ProbeDataConfig','CfgMsgRecepIndicators'}},'OPTIONAL'},{<<100,114,105,118,101,114,65,108,101,114,116,115,65,110,100,87,97,114,110,105,110,103,115>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('CfgKinematicEvents') ->
  {sequence,'CfgKinematicEvents',2,[{<<101,118,101,110,116,115>>,{typeinfo,{'ProbeDataConfig','CfgEvents'}},mandatory},{<<104,121,115,116,101,114,101,115,105,115>>,{typeinfo,{'ProbeDataConfig','CfgHysteresis'}},'OPTIONAL'}]};
typeinfo('CfgEvents') ->
  {sequence,'CfgEvents',5,[{<<97,98,115,65,99,116,105,118,97,116,101,100>>,'BOOLEAN','OPTIONAL'},{<<116,114,97,99,116,105,111,110,67,116,108,76,111,115,115>>,'BOOLEAN','OPTIONAL'},{<<115,116,97,98,105,108,105,116,121,67,116,108,65,99,116,105,118,97,116,101,100>>,'BOOLEAN','OPTIONAL'},{<<104,97,114,100,66,114,97,107,105,110,103>>,'BOOLEAN','OPTIONAL'},{<<115,119,101,114,118,101,84,104,114,101,115,104,111,108,100>>,{'INTEGER',{1,50}},'OPTIONAL'}]};
typeinfo('CfgHysteresis') ->
  {sequence,'CfgHysteresis',2,[{<<104,121,115,83,97,109,112,108,101,115>>,{'INTEGER',{1,10}},mandatory},{<<104,121,115,82,97,116,101>>,{'INTEGER',{1,10}},mandatory}]};
typeinfo('CfgEmerAndTransitInfo') ->
  {choice,#{<<101,109,101,114,86,101,104,76,105,103,104,116,66,97,114>> => 'BOOLEAN',<<114,101,113,84,115,112,69,118,112>> => 'BOOLEAN',<<116,114,97,110,115,105,116,86,101,104,68,111,111,114>> => 'BOOLEAN',<<116,114,97,110,115,105,116,86,101,104,80,97,115,115,67,110,116>> => 'BOOLEAN'}};
typeinfo('CfgMsgRecepIndicators') ->
  {sequence,'CfgMsgRecepIndicators',2,[{<<109,115,103,68,105,99,116,105,111,110,97,114,121>>,{'ENUMERATED_EXT',#{sae => 1,iso => 3,etsi => 2}},'OPTIONAL'},{<<109,101,115,115,97,103,101,115>>,{sof,{'INTEGER',{0,32767}}},'OPTIONAL'}]};
typeinfo('CfgMsgDictionary') ->
  {'ENUMERATED_EXT',#{sae => 1,iso => 3,etsi => 2}};
typeinfo('CfgRoadwayEvents') ->
  {sequence,'CfgRoadwayEvents',14,[{<<111,98,115,116,97,99,108,101,68,101,116,101,99,116,101,100>>,'BOOLEAN',mandatory},{<<97,100,118,101,114,115,101,82,111,97,100,83,117,114,102,97,99,101>>,'BOOLEAN',mandatory},{<<116,114,97,102,102,105,99,83,105,103,69,110,99,111,117,110,116,101,114,115>>,{typeinfo,{'ProbeDataConfig','CfgTrafficSigEncounters'}},'OPTIONAL'},{<<116,114,102,115,105,103,76,105,103,104,116,79,117,116>>,'BOOLEAN',mandatory},{<<116,114,102,115,105,103,82,111,97,100,71,101,111,77,105,115,109,97,116,99,104>>,'BOOLEAN',mandatory},{<<114,111,97,100,83,105,103,110,73,110,102,111>>,{typeinfo,{'ProbeDataConfig','CfgRoadSignInfo'}},'OPTIONAL'},{<<108,111,119,76,97,110,101,77,97,114,107,82,101,102,108,101,99,116>>,{'INTEGER',{1,100}},'OPTIONAL'},{<<114,111,97,100,115,105,103,110,73,110,99,110,115,116,110,99,121>>,'BOOLEAN',mandatory},{<<108,97,110,101,71,101,111,73,110,99,110,115,116,110,99,121>>,'BOOLEAN',mandatory},{<<105,110,99,105,100,101,110,116,68,101,116,101,99,116>>,'BOOLEAN',mandatory},{<<119,111,114,107,90,111,110,101,67,104,97,114,68,101,116,101,99,116>>,'BOOLEAN',mandatory},{<<105,110,99,108,87,101,97,116,104,101,114,68,101,116,101,99,116>>,'BOOLEAN',mandatory},{<<114,97,105,108,114,100,67,114,111,115,115,65,99,116,105,118,97,116,101,100>>,'BOOLEAN',mandatory},{<<100,114,97,119,66,114,105,100,103,101,65,99,116,105,118,97,116,101,100>>,'BOOLEAN',mandatory}]};
typeinfo('CfgTrafficSigEncounters') ->
  {sequence,'CfgTrafficSigEncounters',8,[{<<105,110,116,101,114,115,101,99,116,105,111,110,115>>,{sof,{'INTEGER',{0,65535}}},'OPTIONAL'},{<<116,114,102,99,115,105,103,65,112,112,114,111,97,99,104,68,101,108,97,121>>,{'INTEGER',{1,3600}},'OPTIONAL'},{<<116,114,102,115,105,103,65,112,112,114,111,97,99,104,83,112,101,101,100>>,{'INTEGER',{1,200}},'OPTIONAL'},{<<116,114,102,115,105,103,65,114,114,105,118,97,108,71,114,101,101,110>>,'BOOLEAN','OPTIONAL'},{<<116,114,102,115,105,103,65,114,114,105,118,97,108,82,101,100>>,'BOOLEAN','OPTIONAL'},{<<116,114,102,115,105,103,80,101,100,68,101,108,97,121>>,{'INTEGER',{1,300}},'OPTIONAL'},{<<116,114,102,115,105,103,83,112,97,116,77,105,115,109,97,116,99,104>>,'BOOLEAN','OPTIONAL'},{<<116,114,102,115,105,103,83,112,97,116,84,105,109,105,110,103,69,114,114,111,114>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('CfgRoadSignInfo') ->
  {sequence,'CfgRoadSignInfo',3,[{<<114,111,97,100,115,105,103,110,68,101,116,101,99,116,105,111,110>>,{typeinfo,{'ProbeDataConfig','CfgRoadSignTypes'}},mandatory},{<<108,111,119,82,111,97,100,115,105,103,110,82,101,102,108,101,99,116,49>>,{'INTEGER',{1,250}},'OPTIONAL'},{<<108,111,119,82,111,97,100,115,105,103,110,82,101,102,108,101,99,116,50>>,{'INTEGER',{1,250}},'OPTIONAL'}]};
typeinfo('CfgRoadSignTypes') ->
  {sequence,'CfgRoadSignTypes',14,[{<<119,104,105,116,101,79,110,71,114,101,101,110>>,'BOOLEAN','OPTIONAL'},{<<98,108,97,99,107,79,110,89,101,108,108,111,119>>,'BOOLEAN','OPTIONAL'},{<<98,108,97,99,107,79,110,79,114,97,110,103,101>>,'BOOLEAN','OPTIONAL'},{<<119,104,105,116,101,79,110,82,101,100>>,'BOOLEAN','OPTIONAL'},{<<98,108,97,99,107,79,110,87,104,105,116,101>>,'BOOLEAN','OPTIONAL'},{<<111,99,116,97,103,111,110>>,'BOOLEAN','OPTIONAL'},{<<101,113,108,97,116,84,114,105,97,110,103,108,101>>,'BOOLEAN','OPTIONAL'},{<<99,105,114,99,108,101>>,'BOOLEAN','OPTIONAL'},{<<112,101,110,110,97,110,116>>,'BOOLEAN','OPTIONAL'},{<<112,101,110,116,97,103,111,110>>,'BOOLEAN','OPTIONAL'},{<<99,114,111,115,115,98,117,99,107>>,'BOOLEAN','OPTIONAL'},{<<100,105,97,109,111,110,100>>,'BOOLEAN','OPTIONAL'},{<<116,114,97,112,101,122,111,105,100>>,'BOOLEAN','OPTIONAL'},{<<111,116,104,101,114>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('CfgCommSysPerfEvents') ->
  {sequence,'CfgCommSysPerfEvents',10,[{<<106,50,57,52,53,45,49,67,104,97,110,66,117,115,121,84,104,114,101,115,104>>,{'INTEGER',{1,100}},'OPTIONAL'},{<<114,102,68,97,116,97,82,115,117,73,110,102,111>>,'BOOLEAN','OPTIONAL'},{<<110,117,109,82,115,117,115,79,98,115,101,114,118,101,100,84,104,114,101,115,104>>,{'INTEGER',{1,254}},'OPTIONAL'},{<<114,102,86,50,120,74,97,109,68,101,116,101,99,116,84,104,114,101,115,104>>,{'INTEGER',{1,140}},'OPTIONAL'},{<<106,50,57,52,53,45,49,86,101,104,68,101,110,115,84,104,114,101,115,104>>,{'INTEGER',{1,255}},'OPTIONAL'},{<<106,50,57,52,53,45,49,67,113,105,66,101,108,111,119,84,104,114,101,115,104>>,{'INTEGER',{1,100}},'OPTIONAL'},{<<106,50,57,52,53,45,49,84,114,97,99,107,69,114,114,111,114,84,104,114,101,115,104>>,{'INTEGER',{1,100}},'OPTIONAL'},{<<103,110,115,115,72,100,111,112,69,120,99,101,101,100,115,84,104,114,101,115,104>>,{'INTEGER',{1,20}},'OPTIONAL'},{<<103,110,115,115,83,97,116,115,66,101,108,111,119,84,104,114,101,115,104>>,{'INTEGER',{1,20}},'OPTIONAL'},{<<103,110,115,115,74,97,109,109,105,110,103,68,101,116,101,99,116>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('CfgAveragedAndSummaryTriggers') ->
  {choice,#{<<97,118,101,114,97,103,101,100,84,114,105,103,103,101,114,115>> => {typeinfo,{'ProbeDataConfig','CfgAveragedTriggers'}},<<115,117,109,109,97,114,121,84,114,105,103,103,101,114,115>> => {typeinfo,{'ProbeDataConfig','CfgSummaryTriggers'}}}};
typeinfo('CfgAveragedTriggers') ->
  {sequence,'CfgAveragedTriggers',5,[{<<97,118,103,83,112,101,101,100>>,'BOOLEAN','OPTIONAL'},{<<97,118,103,83,116,111,112,68,117,114,97,116,105,111,110>>,'BOOLEAN','OPTIONAL'},{<<97,118,103,70,117,101,108,67,111,110,115,117,109,112,116,105,111,110>>,'BOOLEAN','OPTIONAL'},{<<97,118,103,69,109,105,115,115,105,111,110,115>>,'BOOLEAN','OPTIONAL'},{<<97,118,103,78,117,109,79,102,79,99,99,117,112,97,110,116,115>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('CfgSummaryTriggers') ->
  {sequence,'CfgSummaryTriggers',12,[{<<114,101,103,84,114,97,118,101,108,84,105,109,101>>,'BOOLEAN','OPTIONAL'},{<<114,101,103,86,101,104,68,105,115,116,84,114,97,118,101,108,101,100>>,'BOOLEAN','OPTIONAL'},{<<114,101,103,86,101,104,84,105,109,101,84,114,97,118,101,108,101,100>>,'BOOLEAN','OPTIONAL'},{<<102,117,101,108,67,111,110,115,117,109,112,116,105,111,110>>,'BOOLEAN','OPTIONAL'},{<<116,111,116,97,108,86,101,104,69,109,105,115,115,105,111,110,115>>,'BOOLEAN','OPTIONAL'},{<<110,117,109,79,102,76,111,119,83,112,101,101,100,69,118,101,110,116,115>>,{typeinfo,{'ProbeDataConfig','CfgLowSpeedCriteria'}},'OPTIONAL'},{<<116,105,109,101,83,116,111,112,112,101,100>>,{typeinfo,{'ProbeDataConfig','CfgStoppedCriteria'}},'OPTIONAL'},{<<110,117,109,79,102,83,116,111,112,112,101,100>>,{typeinfo,{'ProbeDataConfig','CfgStoppedCriteria'}},'OPTIONAL'},{<<108,111,99,79,102,83,116,111,112,115>>,'BOOLEAN','OPTIONAL'},{<<114,101,103,78,117,109,79,102,86,101,104,80,97,115,115,101,100>>,'BOOLEAN','OPTIONAL'},{<<114,101,103,78,117,109,79,102,83,117,114,112,97,115,115,101,100,86,101,104>>,'BOOLEAN','OPTIONAL'},{<<116,111,116,97,108,77,115,103,115,82,101,99,101,105,118,101,100>>,{typeinfo,{'ProbeDataConfig','CfgMsgRecepIndicators'}},'OPTIONAL'}]};
typeinfo('CfgLowSpeedCriteria') ->
  {sequence,'CfgLowSpeedCriteria',2,[{<<108,111,119,83,112,101,101,100,84,104,114,101,115,104,111,108,100>>,{'INTEGER',{5,100}},mandatory},{<<108,111,119,83,112,101,101,100,84,105,109,101,84,104,114,101,115,104>>,{'INTEGER',{1,30}},'OPTIONAL'}]};
typeinfo('CfgStoppedCriteria') ->
  {sequence,'CfgStoppedCriteria',2,[{<<115,116,111,112,112,101,100,83,112,101,101,100,84,104,114,101,115,104,111,108,100>>,{'INTEGER',{1,30}},mandatory},{<<97,109,111,117,110,116,79,102,84,105,109,101,66,101,108,111,119>>,{'INTEGER',{1,300}},mandatory}]};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

dec_components1(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components1(Num, Bytes, Acc) ->
{Term,Remain} = dec_ProbeDataConfig(Bytes),
dec_components1(Num-1, Remain, [Term|Acc]).

dec_components2(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components2(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
dec_components2(Num-1, Remain, [Term|Acc]).

dec_components3(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components3(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes,
{V2@V0,V2@Buf1}
end,
dec_components3(Num-1, Remain, [Term|Acc]).

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
