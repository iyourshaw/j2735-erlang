%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in RoadSafetyMessage.

-module('RoadSafetyMessage').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("RoadSafetyMessage.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'RoadSafetyMessage'},
            {options,[{i,"./erl"},uper,jer,verbose,{i,"./asn"},{outdir,"./erl"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_RoadSafetyMessage/1,
enc_CommonContainer/1,
enc_ContentContainer/1,
enc_CurveContainer/1,
enc_DynamicInfoContainer/1,
enc_IncidentsContainer/1,
enc_LaneClosureContainer/1,
enc_ReducedSpeedZoneContainer/1,
enc_SituationalContainer/1,
enc_ApplicableHeading/1,
enc_AreaType/1,
enc_AudioLink/1,
enc_BroadRegion/1,
enc_BroadRegionArea/1,
enc_CrossLinking/1,
enc_EventIdentifier/1,
enc_EventInfo/1,
enc_EventRecurrence/1,
enc_LaneInfo/1,
enc_NodePointLLE/1,
enc_Obstructions/1,
enc_Offset3D/1,
enc_Path/1,
enc_PathList/1,
enc_PathPoints/1,
enc_RegionInfo/1,
enc_RegionUncertainty/1,
enc_RSMPolygon/1,
enc_VisualLink/1,
enc_Activity/1,
enc_LatOffset/1,
enc_LongOffset/1,
enc_ElevOffset/1,
enc_BankAngle/1,
enc_HeadingDeg/1,
enc_LaneClosed/1,
enc_Radius/1,
enc_ReferencePointType/1,
enc_RSMLanePosition/1,
enc_ShortString/1,
enc_Tolerance/1
]).

-export([
dec_RoadSafetyMessage/1,
dec_CommonContainer/1,
dec_ContentContainer/1,
dec_CurveContainer/1,
dec_DynamicInfoContainer/1,
dec_IncidentsContainer/1,
dec_LaneClosureContainer/1,
dec_ReducedSpeedZoneContainer/1,
dec_SituationalContainer/1,
dec_ApplicableHeading/1,
dec_AreaType/1,
dec_AudioLink/1,
dec_BroadRegion/1,
dec_BroadRegionArea/1,
dec_CrossLinking/1,
dec_EventIdentifier/1,
dec_EventInfo/1,
dec_EventRecurrence/1,
dec_LaneInfo/1,
dec_NodePointLLE/1,
dec_Obstructions/1,
dec_Offset3D/1,
dec_Path/1,
dec_PathList/1,
dec_PathPoints/1,
dec_RegionInfo/1,
dec_RegionUncertainty/1,
dec_RSMPolygon/1,
dec_VisualLink/1,
dec_Activity/1,
dec_LatOffset/1,
dec_LongOffset/1,
dec_ElevOffset/1,
dec_BankAngle/1,
dec_HeadingDeg/1,
dec_LaneClosed/1,
dec_Radius/1,
dec_ReferencePointType/1,
dec_RSMLanePosition/1,
dec_ShortString/1,
dec_Tolerance/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('RoadSafetyMessage', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('RoadSafetyMessage', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('RoadSafetyMessage', Data) -> enc_RoadSafetyMessage(Data);
encode_disp('CommonContainer', Data) -> enc_CommonContainer(Data);
encode_disp('ContentContainer', Data) -> enc_ContentContainer(Data);
encode_disp('CurveContainer', Data) -> enc_CurveContainer(Data);
encode_disp('DynamicInfoContainer', Data) -> enc_DynamicInfoContainer(Data);
encode_disp('IncidentsContainer', Data) -> enc_IncidentsContainer(Data);
encode_disp('LaneClosureContainer', Data) -> enc_LaneClosureContainer(Data);
encode_disp('ReducedSpeedZoneContainer', Data) -> enc_ReducedSpeedZoneContainer(Data);
encode_disp('SituationalContainer', Data) -> enc_SituationalContainer(Data);
encode_disp('ApplicableHeading', Data) -> enc_ApplicableHeading(Data);
encode_disp('AreaType', Data) -> enc_AreaType(Data);
encode_disp('AudioLink', Data) -> enc_AudioLink(Data);
encode_disp('BroadRegion', Data) -> enc_BroadRegion(Data);
encode_disp('BroadRegionArea', Data) -> enc_BroadRegionArea(Data);
encode_disp('CrossLinking', Data) -> enc_CrossLinking(Data);
encode_disp('EventIdentifier', Data) -> enc_EventIdentifier(Data);
encode_disp('EventInfo', Data) -> enc_EventInfo(Data);
encode_disp('EventRecurrence', Data) -> enc_EventRecurrence(Data);
encode_disp('LaneInfo', Data) -> enc_LaneInfo(Data);
encode_disp('NodePointLLE', Data) -> enc_NodePointLLE(Data);
encode_disp('Obstructions', Data) -> enc_Obstructions(Data);
encode_disp('Offset3D', Data) -> enc_Offset3D(Data);
encode_disp('Path', Data) -> enc_Path(Data);
encode_disp('PathList', Data) -> enc_PathList(Data);
encode_disp('PathPoints', Data) -> enc_PathPoints(Data);
encode_disp('RegionInfo', Data) -> enc_RegionInfo(Data);
encode_disp('RegionUncertainty', Data) -> enc_RegionUncertainty(Data);
encode_disp('RSMPolygon', Data) -> enc_RSMPolygon(Data);
encode_disp('VisualLink', Data) -> enc_VisualLink(Data);
encode_disp('Activity', Data) -> enc_Activity(Data);
encode_disp('LatOffset', Data) -> enc_LatOffset(Data);
encode_disp('LongOffset', Data) -> enc_LongOffset(Data);
encode_disp('ElevOffset', Data) -> enc_ElevOffset(Data);
encode_disp('BankAngle', Data) -> enc_BankAngle(Data);
encode_disp('HeadingDeg', Data) -> enc_HeadingDeg(Data);
encode_disp('LaneClosed', Data) -> enc_LaneClosed(Data);
encode_disp('Radius', Data) -> enc_Radius(Data);
encode_disp('ReferencePointType', Data) -> enc_ReferencePointType(Data);
encode_disp('RSMLanePosition', Data) -> enc_RSMLanePosition(Data);
encode_disp('ShortString', Data) -> enc_ShortString(Data);
encode_disp('Tolerance', Data) -> enc_Tolerance(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('RoadSafetyMessage', Data) -> dec_RoadSafetyMessage(Data);
decode_disp('CommonContainer', Data) -> dec_CommonContainer(Data);
decode_disp('ContentContainer', Data) -> dec_ContentContainer(Data);
decode_disp('CurveContainer', Data) -> dec_CurveContainer(Data);
decode_disp('DynamicInfoContainer', Data) -> dec_DynamicInfoContainer(Data);
decode_disp('IncidentsContainer', Data) -> dec_IncidentsContainer(Data);
decode_disp('LaneClosureContainer', Data) -> dec_LaneClosureContainer(Data);
decode_disp('ReducedSpeedZoneContainer', Data) -> dec_ReducedSpeedZoneContainer(Data);
decode_disp('SituationalContainer', Data) -> dec_SituationalContainer(Data);
decode_disp('ApplicableHeading', Data) -> dec_ApplicableHeading(Data);
decode_disp('AreaType', Data) -> dec_AreaType(Data);
decode_disp('AudioLink', Data) -> dec_AudioLink(Data);
decode_disp('BroadRegion', Data) -> dec_BroadRegion(Data);
decode_disp('BroadRegionArea', Data) -> dec_BroadRegionArea(Data);
decode_disp('CrossLinking', Data) -> dec_CrossLinking(Data);
decode_disp('EventIdentifier', Data) -> dec_EventIdentifier(Data);
decode_disp('EventInfo', Data) -> dec_EventInfo(Data);
decode_disp('EventRecurrence', Data) -> dec_EventRecurrence(Data);
decode_disp('LaneInfo', Data) -> dec_LaneInfo(Data);
decode_disp('NodePointLLE', Data) -> dec_NodePointLLE(Data);
decode_disp('Obstructions', Data) -> dec_Obstructions(Data);
decode_disp('Offset3D', Data) -> dec_Offset3D(Data);
decode_disp('Path', Data) -> dec_Path(Data);
decode_disp('PathList', Data) -> dec_PathList(Data);
decode_disp('PathPoints', Data) -> dec_PathPoints(Data);
decode_disp('RegionInfo', Data) -> dec_RegionInfo(Data);
decode_disp('RegionUncertainty', Data) -> dec_RegionUncertainty(Data);
decode_disp('RSMPolygon', Data) -> dec_RSMPolygon(Data);
decode_disp('VisualLink', Data) -> dec_VisualLink(Data);
decode_disp('Activity', Data) -> dec_Activity(Data);
decode_disp('LatOffset', Data) -> dec_LatOffset(Data);
decode_disp('LongOffset', Data) -> dec_LongOffset(Data);
decode_disp('ElevOffset', Data) -> dec_ElevOffset(Data);
decode_disp('BankAngle', Data) -> dec_BankAngle(Data);
decode_disp('HeadingDeg', Data) -> dec_HeadingDeg(Data);
decode_disp('LaneClosed', Data) -> dec_LaneClosed(Data);
decode_disp('Radius', Data) -> dec_Radius(Data);
decode_disp('ReferencePointType', Data) -> dec_ReferencePointType(Data);
decode_disp('RSMLanePosition', Data) -> dec_RSMLanePosition(Data);
decode_disp('ShortString', Data) -> dec_ShortString(Data);
decode_disp('Tolerance', Data) -> dec_Tolerance(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_RoadSafetyMessage(Val) ->
[<<0:1>>,
begin
%% attribute commonContainer(1) with type CommonContainer
Enc2@element = element(2, Val),
enc_CommonContainer(Enc2@element)
end|begin
%% attribute content(2) with type SEQUENCE OF
Enc3@element = element(3, Val),
enc_RoadSafetyMessage_content(Enc3@element)
end].
enc_RoadSafetyMessage_content(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_ContentContainer(Comp) || Comp <- Val]]
end.



dec_RoadSafetyMessage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute commonContainer(1) with type CommonContainer
{Term1,Bytes2} = dec_CommonContainer(Bytes1),

%% attribute content(2) with type SEQUENCE OF
{Term2,Bytes3} = dec_RoadSafetyMessage_content(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V2@V0,V2@Buf1} = case Bytes3 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'RoadSafetyMessage',Term1,Term2},
{Res1,Bytes5}.


dec_RoadSafetyMessage_content(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components1(V1@Add2, V1@Buf1, []).

enc_CommonContainer(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute eventInfo(1) with type EventInfo
Enc3@element = element(2, Val),
enc_EventInfo(Enc3@element)
end,
begin
%% attribute regionInfo(2) with type SEQUENCE OF
Enc4@element = element(3, Val),
enc_CommonContainer_regionInfo(Enc4@element)
end|begin
%% attribute crossLinking(3) with type CrossLinking
Enc5@element = element(4, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
enc_CrossLinking(Enc5@element)
end
end].
enc_CommonContainer_regionInfo(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_RegionInfo(Comp) || Comp <- Val]]
end.



dec_CommonContainer(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute eventInfo(1) with type EventInfo
{Term1,Bytes3} = dec_EventInfo(Bytes2),

%% attribute regionInfo(2) with type SEQUENCE OF
{Term2,Bytes4} = dec_CommonContainer_regionInfo(Bytes3),

%% attribute crossLinking(3) with type CrossLinking
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_CrossLinking(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V3@V0,V3@Buf1} = case Bytes5 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'CommonContainer',Term1,Term2,Term3},
{Res1,Bytes7}.


dec_CommonContainer_regionInfo(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components2(V1@Add2, V1@Buf1, []).

enc_ContentContainer(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= rszContainer ->
[<<0:1,0:3>>|enc_ReducedSpeedZoneContainer(ChoiceVal)];
ChoiceTag =:= laneClosureContainer ->
[<<0:1,1:3>>|enc_LaneClosureContainer(ChoiceVal)];
ChoiceTag =:= curveContainer ->
[<<0:1,2:3>>|enc_CurveContainer(ChoiceVal)];
ChoiceTag =:= dynamicInfoContainer ->
[<<0:1,3:3>>|enc_DynamicInfoContainer(ChoiceVal)];
ChoiceTag =:= incidentsContainer ->
[<<0:1,4:3>>|enc_IncidentsContainer(ChoiceVal)];
ChoiceTag =:= situationalContainer ->
[<<0:1,5:3>>|enc_SituationalContainer(ChoiceVal)]
end.


dec_ContentContainer(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_ReducedSpeedZoneContainer(Bytes2)
end,
{{rszContainer,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_LaneClosureContainer(Bytes2)
end,
{{laneClosureContainer,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_CurveContainer(Bytes2)
end,
{{curveContainer,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
dec_DynamicInfoContainer(Bytes2)
end,
{{dynamicInfoContainer,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
dec_IncidentsContainer(Bytes2)
end,
{{incidentsContainer,Val},NewBytes};
5 ->
{Val,NewBytes} = begin
dec_SituationalContainer(Bytes2)
end,
{{situationalContainer,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_CurveContainer(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute advisorySpeed(1) with type INTEGER
Enc6@element = element(2, Val),
if 0 =< Enc6@element, Enc6@element < 501 ->
<<Enc6@element:9>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end,
begin
%% attribute surfaceCondition(2) with type FrictionInformation
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_FrictionInformation(Enc8@element)
end
end,
begin
%% attribute minRadius(3) with type INTEGER
Enc10@element = element(4, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
Enc10@element bsr 16 =:= 0 ->
<<Enc10@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc10@element}}})
end
end,
begin
%% attribute bankAngle(4) with type INTEGER
Enc13@element = element(5, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc13@element@sub = Enc13@element - -512,
if 0 =< Enc13@element@sub, Enc13@element@sub < 1025 ->
<<Enc13@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc13@element}}})
end
end
end
end|begin
%% attribute curveRegion(5) with type RegionInfo
Enc16@element = element(6, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
true ->
enc_RegionInfo(Enc16@element)
end
end].


dec_CurveContainer(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute advisorySpeed(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:9,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute surfaceCondition(2) with type FrictionInformation
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
'Common':dec_FrictionInformation(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute minRadius(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute bankAngle(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:11,V5@Buf1/bitstring>> = Bytes5,
V5@Add2 = V5@V0 + -512,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute curveRegion(5) with type RegionInfo
{Term5,Bytes7} = case Opt band 1 of
1 ->
dec_RegionInfo(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V6@V0,V6@Buf1} = case Bytes7 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'CurveContainer',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes9}.

enc_DynamicInfoContainer(Val) ->
[begin
%% attribute priority(1) with type ENUMERATED
Enc2@element = element(2, Val),
if Enc2@element =:= 'low-priority' ->
<<0:1,0:2>>;
Enc2@element =:= 'medium-priority' ->
<<0:1,1:2>>;
Enc2@element =:= 'high-priority' ->
<<0:1,2:2>>;
Enc2@element =:= critical ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc2@element}}})
end
end,
begin
%% attribute dmsSignString(2) with type SEQUENCE OF
Enc4@element = element(3, Val),
enc_DynamicInfoContainer_dmsSignString(Enc4@element)
end|begin
%% attribute applicableRegion(3) with type RegionInfo
Enc5@element = element(4, Val),
enc_RegionInfo(Enc5@element)
end].
enc_DynamicInfoContainer_dmsSignString(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 12 ->
[<<Enc2@len@sub:4>>|[begin
Enc1@len = length(Comp),
Enc1@bin = encode_chars(Comp, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 20 ->
[<<Enc1@len@sub:5>>|Enc1@bin]
end
end || Comp <- Val]]
end.



dec_DynamicInfoContainer(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute priority(1) with type ENUMERATED
{Term1,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> 'low-priority';
1 -> 'medium-priority';
2 -> 'high-priority';
3 -> critical
end,
{V2@Int2,V2@Buf1}
end,

%% attribute dmsSignString(2) with type SEQUENCE OF
{Term2,Bytes3} = dec_DynamicInfoContainer_dmsSignString(Bytes2),

%% attribute applicableRegion(3) with type RegionInfo
{Term3,Bytes4} = dec_RegionInfo(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'DynamicInfoContainer',Term1,Term2,Term3},
{Res1,Bytes6}.


dec_DynamicInfoContainer_dmsSignString(Bytes) ->
%% Length with constraint {1,12}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components3(V1@Add2, V1@Buf1, []).

enc_IncidentsContainer(Val) ->
[begin
Enc1@element = element(2, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute responderType(1) with type SEQUENCE OF
Enc3@element = element(2, Val),
if Enc3@element =:= asn1_NOVALUE ->
[];
true ->
enc_IncidentsContainer_responderType(Enc3@element)
end
end|begin
%% attribute incidentLocation(2) with type RegionInfo
Enc5@element = element(3, Val),
enc_RegionInfo(Enc5@element)
end].
enc_IncidentsContainer_responderType(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 5 ->
[<<Enc2@len@sub:3>>|[if Comp =:= 'emergency-vehicle-units' ->
<<0:1,0:4>>;
Comp =:= 'federal-law-enforcement-units' ->
<<0:1,1:4>>;
Comp =:= 'state-police-units' ->
<<0:1,2:4>>;
Comp =:= 'county-police-units' ->
<<0:1,3:4>>;
Comp =:= 'local-police-units' ->
<<0:1,4:4>>;
Comp =:= 'ambulance-units' ->
<<0:1,5:4>>;
Comp =:= 'rescue-units' ->
<<0:1,6:4>>;
Comp =:= 'fire-units' ->
<<0:1,7:4>>;
Comp =:= 'hAZMAT-units' ->
<<0:1,8:4>>;
Comp =:= 'light-tow-unit' ->
<<0:1,9:4>>;
Comp =:= 'heavy-tow-unit' ->
<<0:1,10:4>>;
Comp =:= 'freeway-service-patrols' ->
<<0:1,11:4>>;
Comp =:= 'transportation-response-units' ->
<<0:1,12:4>>;
Comp =:= 'private-contractor-response-units' ->
<<0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]]
end.



dec_IncidentsContainer(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute responderType(1) with type SEQUENCE OF
{Term1,Bytes3} = case Opt band 1 of
1 ->
dec_IncidentsContainer_responderType(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute incidentLocation(2) with type RegionInfo
{Term2,Bytes4} = dec_RegionInfo(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'IncidentsContainer',Term1,Term2},
{Res1,Bytes6}.


dec_IncidentsContainer_responderType(Bytes) ->
%% Length with constraint {1,5}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components4(V1@Add2, V1@Buf1, []).

enc_LaneClosureContainer(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute laneStatus(1) with type SEQUENCE OF
Enc4@element = element(2, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
enc_LaneClosureContainer_laneStatus(Enc4@element)
end
end,
begin
%% attribute laneStatusVaries(2) with type BOOLEAN
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element =:= false ->
<<0:1>>;
Enc6@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc6@element}}})
end
end|begin
%% attribute closureRegion(3) with type RegionInfo
Enc9@element = element(4, Val),
enc_RegionInfo(Enc9@element)
end].
enc_LaneClosureContainer_laneStatus(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if 0 =< Enc1@len@sub, Enc1@len@sub < 10 ->
<<0:1,Enc1@len@sub:4>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_LaneInfo(Comp) || Comp <- Val]].



dec_LaneClosureContainer(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute laneStatus(1) with type SEQUENCE OF
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
dec_LaneClosureContainer_laneStatus(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute laneStatusVaries(2) with type BOOLEAN
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes3,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute closureRegion(3) with type RegionInfo
{Term3,Bytes5} = dec_RegionInfo(Bytes4),

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V4@V0,V4@Buf1} = case Bytes5 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'LaneClosureContainer',Term1,Term2,Term3},
{Res1,Bytes7}.


dec_LaneClosureContainer_laneStatus(Bytes) ->
%% Length with constraint {{1,10},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components5(V1@V0, V1@Buf1, []).

enc_ReducedSpeedZoneContainer(Val) ->
[<<0:1>>,
begin
%% attribute speedLimit(1) with type RegulatorySpeedLimit
Enc2@element = element(2, Val),
'Common':enc_RegulatorySpeedLimit(Enc2@element)
end|begin
%% attribute rszRegion(2) with type RegionInfo
Enc3@element = element(3, Val),
enc_RegionInfo(Enc3@element)
end].


dec_ReducedSpeedZoneContainer(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute speedLimit(1) with type RegulatorySpeedLimit
{Term1,Bytes2} = 'Common':dec_RegulatorySpeedLimit(Bytes1),

%% attribute rszRegion(2) with type RegionInfo
{Term2,Bytes3} = dec_RegionInfo(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V2@V0,V2@Buf1} = case Bytes3 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'ReducedSpeedZoneContainer',Term1,Term2},
{Res1,Bytes5}.

enc_SituationalContainer(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute obstructions(1) with type Obstructions
Enc6@element = element(2, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
enc_Obstructions(Enc6@element)
end
end,
begin
%% attribute visibility(2) with type INTEGER
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
0 =< Enc8@element, Enc8@element < 1000002 ->
<<Enc8@element:20>>;
true ->
exit({error,{asn1,{illegal_integer,Enc8@element}}})
end
end,
begin
%% attribute peoplePresent(3) with type BOOLEAN
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
Enc11@element =:= false ->
<<0:1>>;
Enc11@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc11@element}}})
end
end,
begin
%% attribute anomalousTraffic(4) with type BOOLEAN
Enc14@element = element(5, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
Enc14@element =:= false ->
<<0:1>>;
Enc14@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc14@element}}})
end
end|begin
%% attribute applicableRegion(5) with type RegionInfo
Enc17@element = element(6, Val),
enc_RegionInfo(Enc17@element)
end].


dec_SituationalContainer(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute obstructions(1) with type Obstructions
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
dec_Obstructions(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute visibility(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute peoplePresent(3) with type BOOLEAN
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes4,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute anomalousTraffic(4) with type BOOLEAN
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes5,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute applicableRegion(5) with type RegionInfo
{Term5,Bytes7} = dec_RegionInfo(Bytes6),

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V6@V0,V6@Buf1} = case Bytes7 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'SituationalContainer',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes9}.

enc_ApplicableHeading(Val) ->
[begin
%% attribute heading(1) with type INTEGER
Enc2@element = element(2, Val),
if 0 =< Enc2@element, Enc2@element < 360 ->
<<0:1,Enc2@element:9>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute tolerance(2) with type INTEGER
Enc4@element = element(3, Val),
if 0 =< Enc4@element, Enc4@element < 181 ->
[Enc4@element];
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_ApplicableHeading(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute heading(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:9,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tolerance(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'ApplicableHeading',Term1,Term2},
{Res1,Bytes5}.

enc_AreaType(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= broadRegion ->
[<<0:1,0:1>>|enc_BroadRegion(ChoiceVal)];
ChoiceTag =:= paths ->
[<<0:1,1:1>>|enc_PathList(ChoiceVal)]
end.


dec_AreaType(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_BroadRegion(Bytes2)
end,
{{broadRegion,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_PathList(Bytes2)
end,
{{paths,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_AudioLink(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute amChannel(1) with type INTEGER
Enc6@element = element(2, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc6@element@sub = Enc6@element - 531,
if 0 =< Enc6@element@sub, Enc6@element@sub < 1180 ->
<<Enc6@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end
end
end,
begin
%% attribute fmChannel(2) with type INTEGER
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc9@element@sub = Enc9@element - 65800,
if 0 =< Enc9@element@sub, Enc9@element@sub < 42210 ->
<<Enc9@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end
end
end,
begin
%% attribute satelliteChannel(3) with type INTEGER
Enc12@element = element(4, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc12@element@sub = Enc12@element - 1,
if 0 =< Enc12@element@sub, Enc12@element@sub < 9999 ->
<<Enc12@element@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end
end
end|begin
%% attribute urlChannel(4) with type IA5String
Enc15@element = element(5, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc16@len = length(Enc15@element),
Enc16@bin = encode_chars(Enc15@element, 7),
Enc16@len@sub = Enc16@len - 1,
if 0 =< Enc16@len@sub, Enc16@len@sub < 500 ->
[<<Enc16@len@sub:9>>|Enc16@bin]
end
end
end
end].


dec_AudioLink(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute amChannel(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:11,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 531,
{V3@Add2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute fmChannel(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 65800,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute satelliteChannel(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:14,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute urlChannel(4) with type IA5String
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
<<V6@V0:9,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + 1,
<<V6@V3:V6@Add2/binary-unit:7,V6@Buf4/bitstring>> = V6@Buf1,
{V6@V5,V6@Buf6}  = {decode_chars(V6@V3, 7),V6@Buf4},
{V6@V5,V6@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = {'AudioLink',Term1,Term2,Term3,Term4},
{Res1,Bytes8}.

enc_BroadRegion(Val) ->
[<<0:1>>,
begin
%% attribute applicableHeading(1) with type ApplicableHeading
Enc2@element = element(2, Val),
enc_ApplicableHeading(Enc2@element)
end|begin
%% attribute broadArea(2) with type BroadRegionArea
Enc3@element = element(3, Val),
enc_BroadRegionArea(Enc3@element)
end].


dec_BroadRegion(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute applicableHeading(1) with type ApplicableHeading
{Term1,Bytes2} = dec_ApplicableHeading(Bytes1),

%% attribute broadArea(2) with type BroadRegionArea
{Term2,Bytes3} = dec_BroadRegionArea(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V2@V0,V2@Buf1} = case Bytes3 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'BroadRegion',Term1,Term2},
{Res1,Bytes5}.

enc_BroadRegionArea(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= polygon ->
[<<0:1,0:1>>|enc_RSMPolygon(ChoiceVal)];
ChoiceTag =:= circle ->
[<<0:1,1:1>>|'TravelerInformation':enc_Circle(ChoiceVal)]
end.


dec_BroadRegionArea(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_RSMPolygon(Bytes2)
end,
{{polygon,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'TravelerInformation':dec_Circle(Bytes2)
end,
{{circle,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_CrossLinking(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
if Enc3@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute audioLinks(1) with type SEQUENCE OF
Enc5@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
enc_CrossLinking_audioLinks(Enc5@element)
end
end,
begin
%% attribute visualLink(2) with type SEQUENCE OF
Enc7@element = element(3, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
enc_CrossLinking_visualLink(Enc7@element)
end
end|begin
%% attribute rsmLink(3) with type SEQUENCE OF
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
enc_CrossLinking_rsmLink(Enc9@element)
end
end].
enc_CrossLinking_audioLinks(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if Enc1@len@sub bsr 2 =:= 0 ->
<<0:1,Enc1@len@sub:2>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_AudioLink(Comp) || Comp <- Val]].

enc_CrossLinking_visualLink(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if Enc1@len@sub bsr 2 =:= 0 ->
<<0:1,Enc1@len@sub:2>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_VisualLink(Comp) || Comp <- Val]].

enc_CrossLinking_rsmLink(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if Enc1@len@sub bsr 2 =:= 0 ->
<<0:1,Enc1@len@sub:2>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_EventIdentifier(Comp) || Comp <- Val]].



dec_CrossLinking(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute audioLinks(1) with type SEQUENCE OF
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
dec_CrossLinking_audioLinks(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute visualLink(2) with type SEQUENCE OF
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
dec_CrossLinking_visualLink(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute rsmLink(3) with type SEQUENCE OF
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_CrossLinking_rsmLink(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V3@V0,V3@Buf1} = case Bytes5 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'CrossLinking',Term1,Term2,Term3},
{Res1,Bytes7}.


dec_CrossLinking_audioLinks(Bytes) ->
%% Length with constraint {{1,4},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components6(V1@V0, V1@Buf1, []).


dec_CrossLinking_visualLink(Bytes) ->
%% Length with constraint {{1,4},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components7(V1@V0, V1@Buf1, []).


dec_CrossLinking_rsmLink(Bytes) ->
%% Length with constraint {{1,4},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components8(V1@V0, V1@Buf1, []).

enc_EventIdentifier(Val) ->
[<<0:1>>,
begin
%% attribute operatorID(1) with type RoadAuthorityID
Enc2@element = element(2, Val),
'Common':enc_RoadAuthorityID(Enc2@element)
end|begin
%% attribute uniqueID(2) with type OCTET STRING
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len =:= 4 ->
Enc3@element
end
end].


dec_EventIdentifier(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute operatorID(1) with type RoadAuthorityID
{Term1,Bytes2} = 'Common':dec_RoadAuthorityID(Bytes1),

%% attribute uniqueID(2) with type OCTET STRING
{Term2,Bytes3} = begin
<<V2@V0:4/binary-unit:8,V2@Buf1/bitstring>> = Bytes2,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'EventIdentifier',Term1,Term2},
{Res1,Bytes5}.

enc_EventInfo(Val) ->
[begin
Enc1@element = element(6, Val),
Enc2@element = element(7, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(9, Val),
Enc4@element = element(10, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute eventID(1) with type EventIdentifier
Enc6@element = element(2, Val),
enc_EventIdentifier(Enc6@element)
end,
begin
%% attribute eventUpdate(2) with type INTEGER
Enc7@element = element(3, Val),
if Enc7@element bsr 7 =:= 0 ->
<<Enc7@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end,
begin
%% attribute eventCancellation(3) with type BOOLEAN
Enc9@element = element(4, Val),
if Enc9@element =:= false ->
<<0:1>>;
Enc9@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc9@element}}})
end
end,
begin
%% attribute startDateTime(4) with type DDateTime
Enc11@element = element(5, Val),
'Common':enc_DDateTime(Enc11@element)
end,
begin
%% attribute endDateTime(5) with type DDateTime
Enc12@element = element(6, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DDateTime(Enc12@element)
end
end,
begin
%% attribute eventRecurrence(6) with type SEQUENCE OF
Enc14@element = element(7, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
true ->
enc_EventInfo_eventRecurrence(Enc14@element)
end
end,
begin
%% attribute causeCode(7) with type INTEGER
Enc16@element = element(8, Val),
if Enc16@element =:= trafficConditions ->
1;
Enc16@element =:= accidentsAndIncidents ->
2;
Enc16@element =:= closures ->
3;
Enc16@element =:= roadwork ->
4;
Enc16@element =:= obstruction ->
5;
Enc16@element =:= delayStatusCancellation ->
6;
Enc16@element =:= unusualDriving ->
7;
Enc16@element =:= mobileSituation ->
8;
Enc16@element =:= deviceStatus ->
9;
Enc16@element =:= restrictionClass ->
10;
Enc16@element =:= incidentResponseStatus ->
11;
Enc16@element =:= disasters ->
12;
Enc16@element =:= disturbances ->
13;
Enc16@element =:= sportingEvents ->
14;
Enc16@element =:= specialEvents ->
15;
Enc16@element =:= parkingInformation ->
16;
Enc16@element =:= systemInformation ->
17;
Enc16@element =:= weatherConditions ->
18;
Enc16@element =:= precipitation ->
19;
Enc16@element =:= winds ->
20;
Enc16@element =:= visibilityAndAirQuality ->
21;
Enc16@element =:= temperature ->
22;
Enc16@element =:= pavementConditions ->
23;
Enc16@element =:= winterDrivingRestrictions ->
24;
Enc16@element =:= winterDrivingIndex ->
25;
Enc16@element =:= suggestionAdvice ->
26;
Enc16@element =:= warningAdvice ->
27;
Enc16@element =:= adviceInstructionsRecommendations ->
28;
Enc16@element =:= adviceInstructionsMandatory ->
29;
Enc16@element =:= qualifiers ->
30;
Enc16@element =:= genericLocations ->
31;
Enc16@element =:= laneRoadway ->
32;
Enc16@element =:= alternateRoute ->
33;
Enc16@element =:= units ->
34;
Enc16@element =:= transitMode ->
35;
Enc16@element =:= vehicleGroupAffected ->
36;
Enc16@element =:= travelerGroupAffected ->
37;
Enc16@element =:= responderGroupAffected ->
38;
Enc16@element =:= incidentResponseEquipment ->
39;
Enc16@element =:= assetStatus ->
40;
Enc16@element =:= roadsideAssets ->
41;
Enc16@element =:= transitOperations ->
42;
Enc16@element =:= objects ->
43;
Enc16@element =:= validManeuvers ->
44;
Enc16@element =:= largeNumbers ->
45;
Enc16@element =:= namedObjects ->
46;
Enc16@element =:= recreationalObjectsAndActivities ->
47;
Enc16@element =:= regulatoryAndWarningSigns ->
48;
Enc16@element =:= smallNumbers ->
49;
Enc16@element =:= states ->
50;
Enc16@element =:= structures ->
51;
Enc16@element =:= streetSuffixes ->
52;
Enc16@element =:= mUTCDLocations ->
53;
Enc16@element bsr 8 =:= 0 ->
Enc16@element;
true ->
exit({error,{asn1,{illegal_integer,Enc16@element}}})
end
end,
begin
%% attribute subCauseCode(8) with type INTEGER
Enc18@element = element(9, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
Enc18@element bsr 16 =:= 0 ->
<<Enc18@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc18@element}}})
end
end|begin
%% attribute affectedVehicles(9) with type SEQUENCE OF
Enc21@element = element(10, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
enc_EventInfo_affectedVehicles(Enc21@element)
end
end].
enc_EventInfo_eventRecurrence(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if 0 =< Enc1@len@sub, Enc1@len@sub < 5 ->
<<0:1,Enc1@len@sub:3>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_EventRecurrence(Comp) || Comp <- Val]].

enc_EventInfo_affectedVehicles(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
[if 0 =< Enc2@len@sub, Enc2@len@sub < 10 ->
<<0:1,Enc2@len@sub:4>>;
Enc2@len < 128 ->
[<<1:1,Enc2@len:8>>];
Enc2@len < 16384 ->
<<1:1,2:2,Enc2@len:14>>
end|[if Comp =:= 'all-vehicles' ->
<<0:1,0:6>>;
Comp =:= bicycles ->
<<0:1,1:6>>;
Comp =:= motorcycles ->
<<0:1,2:6>>;
Comp =:= cars ->
<<0:1,3:6>>;
Comp =:= 'light-vehicles' ->
<<0:1,4:6>>;
Comp =:= 'cars-and-light-vehicles' ->
<<0:1,5:6>>;
Comp =:= 'cars-with-trailers' ->
<<0:1,6:6>>;
Comp =:= 'cars-with-recreational-trailers' ->
<<0:1,7:6>>;
Comp =:= 'vehicles-with-trailers' ->
<<0:1,8:6>>;
Comp =:= 'heavy-vehicles' ->
<<0:1,9:6>>;
Comp =:= trucks ->
<<0:1,10:6>>;
Comp =:= buses ->
<<0:1,11:6>>;
Comp =:= 'articulated-buses' ->
<<0:1,12:6>>;
Comp =:= 'school-buses' ->
<<0:1,13:6>>;
Comp =:= 'vehicles-with-semi-trailers' ->
<<0:1,14:6>>;
Comp =:= 'vehicles-with-double-trailers' ->
<<0:1,15:6>>;
Comp =:= 'high-profile-vehicles' ->
<<0:1,16:6>>;
Comp =:= 'wide-vehicles' ->
<<0:1,17:6>>;
Comp =:= 'long-vehicles' ->
<<0:1,18:6>>;
Comp =:= 'hazardous-loads' ->
<<0:1,19:6>>;
Comp =:= 'exceptional-loads' ->
<<0:1,20:6>>;
Comp =:= 'abnormal-loads' ->
<<0:1,21:6>>;
Comp =:= convoys ->
<<0:1,22:6>>;
Comp =:= 'maintenance-vehicles' ->
<<0:1,23:6>>;
Comp =:= 'delivery-vehicles' ->
<<0:1,24:6>>;
Comp =:= 'vehicles-with-even-numbered-license-plates' ->
<<0:1,25:6>>;
Comp =:= 'vehicles-with-odd-numbered-license-plates' ->
<<0:1,26:6>>;
Comp =:= 'vehicles-with-parking-permits' ->
<<0:1,27:6>>;
Comp =:= 'vehicles-with-catalytic-converters' ->
<<0:1,28:6>>;
Comp =:= 'vehicles-without-catalytic-converters' ->
<<0:1,29:6>>;
Comp =:= 'gas-powered-vehicles' ->
<<0:1,30:6>>;
Comp =:= 'diesel-powered-vehicles' ->
<<0:1,31:6>>;
Comp =:= 'lPG-vehicles' ->
<<0:1,32:6>>;
Comp =:= 'military-convoys' ->
<<0:1,33:6>>;
Comp =:= 'military-vehicles' ->
<<0:1,34:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Comp}}})
end || Comp <- Val]].



dec_EventInfo(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute eventID(1) with type EventIdentifier
{Term1,Bytes3} = dec_EventIdentifier(Bytes2),

%% attribute eventUpdate(2) with type INTEGER
{Term2,Bytes4} = begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end,

%% attribute eventCancellation(3) with type BOOLEAN
{Term3,Bytes5} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes4,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end,

%% attribute startDateTime(4) with type DDateTime
{Term4,Bytes6} = 'Common':dec_DDateTime(Bytes5),

%% attribute endDateTime(5) with type DDateTime
{Term5,Bytes7} = case (Opt bsr 3) band 1 of
1 ->
'Common':dec_DDateTime(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute eventRecurrence(6) with type SEQUENCE OF
{Term6,Bytes8} = case (Opt bsr 2) band 1 of
1 ->
dec_EventInfo_eventRecurrence(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute causeCode(7) with type INTEGER
{Term7,Bytes9} = begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes8,
V5@Int2 = case V5@V0 of
1 -> trafficConditions;
2 -> accidentsAndIncidents;
3 -> closures;
4 -> roadwork;
5 -> obstruction;
6 -> delayStatusCancellation;
7 -> unusualDriving;
8 -> mobileSituation;
9 -> deviceStatus;
10 -> restrictionClass;
11 -> incidentResponseStatus;
12 -> disasters;
13 -> disturbances;
14 -> sportingEvents;
15 -> specialEvents;
16 -> parkingInformation;
17 -> systemInformation;
18 -> weatherConditions;
19 -> precipitation;
20 -> winds;
21 -> visibilityAndAirQuality;
22 -> temperature;
23 -> pavementConditions;
24 -> winterDrivingRestrictions;
25 -> winterDrivingIndex;
26 -> suggestionAdvice;
27 -> warningAdvice;
28 -> adviceInstructionsRecommendations;
29 -> adviceInstructionsMandatory;
30 -> qualifiers;
31 -> genericLocations;
32 -> laneRoadway;
33 -> alternateRoute;
34 -> units;
35 -> transitMode;
36 -> vehicleGroupAffected;
37 -> travelerGroupAffected;
38 -> responderGroupAffected;
39 -> incidentResponseEquipment;
40 -> assetStatus;
41 -> roadsideAssets;
42 -> transitOperations;
43 -> objects;
44 -> validManeuvers;
45 -> largeNumbers;
46 -> namedObjects;
47 -> recreationalObjectsAndActivities;
48 -> regulatoryAndWarningSigns;
49 -> smallNumbers;
50 -> states;
51 -> structures;
52 -> streetSuffixes;
53 -> mUTCDLocations;
_ -> V5@V0
end,
{V5@Int2,V5@Buf1}
end,

%% attribute subCauseCode(8) with type INTEGER
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:16,V6@Buf1/bitstring>> = Bytes9,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute affectedVehicles(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_EventInfo_affectedVehicles(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V7@V0,V7@Buf1} = case Bytes11 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes13= skipextensions(Bytes12, 1, Extensions),
Res1 = {'EventInfo',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9},
{Res1,Bytes13}.


dec_EventInfo_eventRecurrence(Bytes) ->
%% Length with constraint {{1,5},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components9(V1@V0, V1@Buf1, []).


dec_EventInfo_affectedVehicles(Bytes) ->
%% Length with constraint {{1,10},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components10(V1@V0, V1@Buf1, []).

enc_EventRecurrence(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(13, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute startTime(1) with type DTime
Enc7@element = element(2, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DTime(Enc7@element)
end
end,
begin
%% attribute endTime(2) with type DTime
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DTime(Enc9@element)
end
end,
begin
%% attribute startDate(3) with type DDate
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DDate(Enc11@element)
end
end,
begin
%% attribute endDate(4) with type DDate
Enc13@element = element(5, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_DDate(Enc13@element)
end
end,
begin
%% attribute monday(5) with type BOOLEAN
Enc15@element = element(6, Val),
%% attribute tuesday(6) with type BOOLEAN
Enc17@element = element(7, Val),
if Enc15@element =:= false ->
if Enc17@element =:= false ->
<<0:1,0:1>>;
Enc17@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc17@element}}})
end;
Enc15@element =:= true ->
if Enc17@element =:= false ->
<<1:1,0:1>>;
Enc17@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc17@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc15@element}}})
end
end,
begin
%% attribute wednesday(7) with type BOOLEAN
Enc19@element = element(8, Val),
%% attribute thursday(8) with type BOOLEAN
Enc21@element = element(9, Val),
if Enc19@element =:= false ->
if Enc21@element =:= false ->
<<0:1,0:1>>;
Enc21@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc21@element}}})
end;
Enc19@element =:= true ->
if Enc21@element =:= false ->
<<1:1,0:1>>;
Enc21@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc21@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc19@element}}})
end
end,
begin
%% attribute friday(9) with type BOOLEAN
Enc23@element = element(10, Val),
%% attribute saturday(10) with type BOOLEAN
Enc25@element = element(11, Val),
if Enc23@element =:= false ->
if Enc25@element =:= false ->
<<0:1,0:1>>;
Enc25@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc25@element}}})
end;
Enc23@element =:= true ->
if Enc25@element =:= false ->
<<1:1,0:1>>;
Enc25@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc25@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc23@element}}})
end
end|begin
%% attribute sunday(11) with type BOOLEAN
Enc27@element = element(12, Val),
%% attribute exclusion(12) with type BOOLEAN
Enc29@element = element(13, Val),
if Enc27@element =:= false ->
if Enc29@element =:= asn1_NOVALUE ->
<<0:1>>;
Enc29@element =:= false ->
<<0:1,0:1>>;
Enc29@element =:= true ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc29@element}}})
end;
Enc27@element =:= true ->
if Enc29@element =:= asn1_NOVALUE ->
<<1:1>>;
Enc29@element =:= false ->
<<1:1,0:1>>;
Enc29@element =:= true ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc29@element}}})
end;
true ->
exit({error,{asn1,{illegal_boolean,Enc27@element}}})
end
end].


dec_EventRecurrence(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute startTime(1) with type DTime
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
'Common':dec_DTime(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute endTime(2) with type DTime
{Term2,Bytes4} = case (Opt bsr 3) band 1 of
1 ->
'Common':dec_DTime(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute startDate(3) with type DDate
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
'Common':dec_DDate(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute endDate(4) with type DDate
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
'Common':dec_DDate(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute monday(5) with type BOOLEAN
{Term5,Bytes7} = begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes6,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end,

%% attribute tuesday(6) with type BOOLEAN
{Term6,Bytes8} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes7,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end,

%% attribute wednesday(7) with type BOOLEAN
{Term7,Bytes9} = begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes8,
V5@Int2 = case V5@V0 of
0 -> false;
1 -> true
end,
{V5@Int2,V5@Buf1}
end,

%% attribute thursday(8) with type BOOLEAN
{Term8,Bytes10} = begin
<<V6@V0:1,V6@Buf1/bitstring>> = Bytes9,
V6@Int2 = case V6@V0 of
0 -> false;
1 -> true
end,
{V6@Int2,V6@Buf1}
end,

%% attribute friday(9) with type BOOLEAN
{Term9,Bytes11} = begin
<<V7@V0:1,V7@Buf1/bitstring>> = Bytes10,
V7@Int2 = case V7@V0 of
0 -> false;
1 -> true
end,
{V7@Int2,V7@Buf1}
end,

%% attribute saturday(10) with type BOOLEAN
{Term10,Bytes12} = begin
<<V8@V0:1,V8@Buf1/bitstring>> = Bytes11,
V8@Int2 = case V8@V0 of
0 -> false;
1 -> true
end,
{V8@Int2,V8@Buf1}
end,

%% attribute sunday(11) with type BOOLEAN
{Term11,Bytes13} = begin
<<V9@V0:1,V9@Buf1/bitstring>> = Bytes12,
V9@Int2 = case V9@V0 of
0 -> false;
1 -> true
end,
{V9@Int2,V9@Buf1}
end,

%% attribute exclusion(12) with type BOOLEAN
{Term12,Bytes14} = case Opt band 1 of
1 ->
begin
<<V10@V0:1,V10@Buf1/bitstring>> = Bytes13,
V10@Int2 = case V10@V0 of
0 -> false;
1 -> true
end,
{V10@Int2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% Extensions
{Extensions,Bytes15} = case Ext of
0 -> {<<>>,Bytes14};
1 ->
{V11@V0,V11@Buf1} = case Bytes14 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8};
<<1:1,1:1,V11@V7:6,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
V11@Mul9 = V11@V7 * 16384,
{V11@Mul9,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V10:V11@V0/bitstring-unit:1,V11@Buf11/bitstring>> = V11@Buf1,
{V11@V10,V11@Buf11}
end,
Bytes16= skipextensions(Bytes15, 1, Extensions),
Res1 = {'EventRecurrence',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12},
{Res1,Bytes16}.

enc_LaneInfo(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute lanePosition(1) with type INTEGER
Enc3@element = element(2, Val),
Enc3@element@sub = Enc3@element - 1,
if Enc3@element@sub bsr 5 =:= 0 ->
<<Enc3@element@sub:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute laneClosed(2) with type BOOLEAN
Enc5@element = element(3, Val),
if Enc5@element =:= false ->
<<0:1>>;
Enc5@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc5@element}}})
end
end|begin
%% attribute laneCloseOffset(3) with type INTEGER
Enc7@element = element(4, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
Enc7@element bsr 15 =:= 0 ->
<<Enc7@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end].


dec_LaneInfo(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute lanePosition(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% attribute laneClosed(2) with type BOOLEAN
{Term2,Bytes4} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end,

%% attribute laneCloseOffset(3) with type INTEGER
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:15,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'LaneInfo',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_NodePointLLE(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= 'node-3Dabsolute' ->
[<<0:1,0:1>>|'Common':enc_Position3D(ChoiceVal)];
ChoiceTag =:= 'node-3Doffset' ->
[<<0:1,1:1>>|enc_Offset3D(ChoiceVal)]
end.


dec_NodePointLLE(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'Common':dec_Position3D(Bytes2)
end,
{{'node-3Dabsolute',Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_Offset3D(Bytes2)
end,
{{'node-3Doffset',Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_Obstructions(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute location(1) with type Position3D
Enc3@element = element(2, Val),
'Common':enc_Position3D(Enc3@element)
end|begin
%% attribute description(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
Enc4@element bsr 16 =:= 0 ->
<<Enc4@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_Obstructions(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute location(1) with type Position3D
{Term1,Bytes3} = 'Common':dec_Position3D(Bytes2),

%% attribute description(2) with type INTEGER
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V4@V0,V4@Buf1} = case Bytes4 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'Obstructions',Term1,Term2},
{Res1,Bytes6}.

enc_Offset3D(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute lat-offset(1) with type INTEGER
Enc3@element = element(2, Val),
Enc3@element@sub = Enc3@element - -16384,
if Enc3@element@sub bsr 15 =:= 0 ->
<<Enc3@element@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute long-offset(2) with type INTEGER
Enc5@element = element(3, Val),
Enc5@element@sub = Enc5@element - -16384,
if Enc5@element@sub bsr 15 =:= 0 ->
<<Enc5@element@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end|begin
%% attribute elev-offset(3) with type INTEGER
Enc7@element = element(4, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc7@element@sub = Enc7@element - -4096,
if Enc7@element@sub bsr 13 =:= 0 ->
<<Enc7@element@sub:13>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end
end
end].


dec_Offset3D(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute lat-offset(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -16384,
{V3@Add2,V3@Buf1}
end,

%% attribute long-offset(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:15,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -16384,
{V4@Add2,V4@Buf1}
end,

%% attribute elev-offset(3) with type INTEGER
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:13,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + -4096,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'Offset3D',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_Path(Val) ->
[begin
%% attribute pathWidth(1) with type INTEGER
Enc2@element = element(2, Val),
if 0 =< Enc2@element, Enc2@element < 1001 ->
<<0:1,Enc2@element:10>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute pathPoints(2) with type PathPoints
Enc4@element = element(3, Val),
enc_PathPoints(Enc4@element)
end].


dec_Path(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute pathWidth(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute pathPoints(2) with type PathPoints
{Term2,Bytes3} = dec_PathPoints(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'Path',Term1,Term2},
{Res1,Bytes5}.

enc_PathList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
[if 0 =< Enc1@len@sub, Enc1@len@sub < 10 ->
<<0:1,Enc1@len@sub:4>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_Path(Comp) || Comp <- Val]].



dec_PathList(Bytes) ->
%% Length with constraint {{1,10},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 1,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components11(V1@V0, V1@Buf1, []).

enc_PathPoints(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 2,
[if 0 =< Enc1@len@sub, Enc1@len@sub < 62 ->
<<0:1,Enc1@len@sub:6>>;
Enc1@len < 128 ->
[<<1:1,Enc1@len:8>>];
Enc1@len < 16384 ->
<<1:1,2:2,Enc1@len:14>>
end|[enc_NodePointLLE(Comp) || Comp <- Val]].



dec_PathPoints(Bytes) ->
%% Length with constraint {{2,63},[]}
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Add5 = V1@V3 + 2,
{V1@Add5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
{V1@V3,V1@Buf4}
end,
dec_components12(V1@V0, V1@Buf1, []).

enc_RegionInfo(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute referencePoint(1) with type Position3D
Enc7@element = element(2, Val),
'Common':enc_Position3D(Enc7@element)
end,
begin
%% attribute locationUncertainty(2) with type RegionUncertainty
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
true ->
enc_RegionUncertainty(Enc8@element)
end
end,
begin
%% attribute referencePointType(3) with type ENUMERATED
Enc10@element = element(4, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
Enc10@element =:= startOfEvent ->
<<0:1,0:1>>;
Enc10@element =:= arbitrary ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc10@element}}})
end
end,
begin
%% attribute descriptiveName(4) with type IA5String
Enc13@element = element(5, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc14@len = length(Enc13@element),
Enc14@bin = encode_chars(Enc13@element, 7),
Enc14@len@sub = Enc14@len - 1,
if 0 =< Enc14@len@sub, Enc14@len@sub < 63 ->
[<<Enc14@len@sub:6>>|Enc14@bin]
end
end
end
end,
begin
%% attribute scale(5) with type INTEGER
Enc16@element = element(6, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
Enc16@element bsr 4 =:= 0 ->
<<Enc16@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc16@element}}})
end
end|begin
%% attribute approachRegion(6) with type AreaType
Enc19@element = element(7, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
enc_AreaType(Enc19@element)
end
end].


dec_RegionInfo(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute referencePoint(1) with type Position3D
{Term1,Bytes3} = 'Common':dec_Position3D(Bytes2),

%% attribute locationUncertainty(2) with type RegionUncertainty
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
dec_RegionUncertainty(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute referencePointType(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:1,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> startOfEvent;
1 -> arbitrary
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11};
<<1:1,1:1,V3@V10:6,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
V3@Mul12 = V3@V10 * 16384,
{V3@Mul12,V3@Buf11}
end,
<<V3@V13:V3@V6/unit:8,V3@Buf14/bitstring>> = V3@Buf7,
{V3@V13,V3@Buf14}
end,
V3@Int15 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int15,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute descriptiveName(4) with type IA5String
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:6,V4@Buf1/bitstring>> = Bytes5,
V4@Add2 = V4@V0 + 1,
<<V4@V3:V4@Add2/binary-unit:7,V4@Buf4/bitstring>> = V4@Buf1,
{V4@V5,V4@Buf6}  = {decode_chars(V4@V3, 7),V4@Buf4},
{V4@V5,V4@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute scale(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes6,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute approachRegion(6) with type AreaType
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_AreaType(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V6@V0,V6@Buf1} = case Bytes8 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = {'RegionInfo',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes10}.

enc_RegionUncertainty(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= alongPath ->
[<<0:1,0:1>>|enc_Offset3D(ChoiceVal)];
ChoiceTag =:= inCoordinateFrame ->
[<<0:1,1:1>>|enc_Offset3D(ChoiceVal)]
end.


dec_RegionUncertainty(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_Offset3D(Bytes2)
end,
{{alongPath,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_Offset3D(Bytes2)
end,
{{inCoordinateFrame,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_RSMPolygon(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 3,
if 0 =< Enc1@len@sub, Enc1@len@sub < 61 ->
[<<Enc1@len@sub:6>>|[enc_NodePointLLE(Comp) || Comp <- Val]]
end.



dec_RSMPolygon(Bytes) ->
%% Length with constraint {3,63}
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 3,
dec_components13(V1@Add2, V1@Buf1, []).

enc_VisualLink(Val) ->
[begin
Enc1@element = element(2, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end|begin
%% attribute urlLink(1) with type IA5String
Enc3@element = element(2, Val),
if Enc3@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc4@len = length(Enc3@element),
Enc4@bin = encode_chars(Enc3@element, 7),
Enc4@len@sub = Enc4@len - 1,
if 0 =< Enc4@len@sub, Enc4@len@sub < 500 ->
[<<Enc4@len@sub:9>>|Enc4@bin]
end
end
end
end].


dec_VisualLink(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute urlLink(1) with type IA5String
{Term1,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:9,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'VisualLink',Term1},
{Res1,Bytes5}.

enc_Activity(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_Activity(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_LatOffset(Val) ->
Val@sub = Val - -16384,
if Val@sub bsr 15 =:= 0 ->
<<Val@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LatOffset(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -16384,
{V1@Add2,V1@Buf1}
end.

enc_LongOffset(Val) ->
Val@sub = Val - -16384,
if Val@sub bsr 15 =:= 0 ->
<<Val@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LongOffset(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -16384,
{V1@Add2,V1@Buf1}
end.

enc_ElevOffset(Val) ->
Val@sub = Val - -4096,
if Val@sub bsr 13 =:= 0 ->
<<Val@sub:13>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ElevOffset(Bytes) ->
begin
<<V1@V0:13,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -4096,
{V1@Add2,V1@Buf1}
end.

enc_BankAngle(Val) ->
Val@sub = Val - -512,
if 0 =< Val@sub, Val@sub < 1025 ->
<<Val@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_BankAngle(Bytes) ->
begin
<<V1@V0:11,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -512,
{V1@Add2,V1@Buf1}
end.

enc_HeadingDeg(Val) ->
if 0 =< Val, Val < 360 ->
<<Val:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_HeadingDeg(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_LaneClosed(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_LaneClosed(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_Radius(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Radius(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ReferencePointType(Val) ->
if Val =:= startOfEvent ->
<<0:1,0:1>>;
Val =:= arbitrary ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_ReferencePointType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:1,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> startOfEvent;
1 -> arbitrary
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_RSMLanePosition(Val) ->
Val@sub = Val - 1,
if Val@sub bsr 5 =:= 0 ->
<<Val@sub:5>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RSMLanePosition(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_ShortString(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars(Val, 7),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 20 ->
[<<Enc1@len@sub:5>>|Enc1@bin]
end.


dec_ShortString(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
<<V1@V3:V1@Add2/binary-unit:7,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V5,V1@Buf6}  = {decode_chars(V1@V3, 7),V1@Buf4},
{V1@V5,V1@Buf6}
end.

enc_Tolerance(Val) ->
if 0 =< Val, Val < 181 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Tolerance(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

typeinfo('RoadSafetyMessage') ->
  {sequence,'RoadSafetyMessage',2,[{<<99,111,109,109,111,110,67,111,110,116,97,105,110,101,114>>,{typeinfo,{'RoadSafetyMessage','CommonContainer'}},mandatory},{<<99,111,110,116,101,110,116>>,{sof,{typeinfo,{'RoadSafetyMessage','ContentContainer'}}},mandatory}]};
typeinfo('CommonContainer') ->
  {sequence,'CommonContainer',3,[{<<101,118,101,110,116,73,110,102,111>>,{typeinfo,{'RoadSafetyMessage','EventInfo'}},mandatory},{<<114,101,103,105,111,110,73,110,102,111>>,{sof,{typeinfo,{'RoadSafetyMessage','RegionInfo'}}},mandatory},{<<99,114,111,115,115,76,105,110,107,105,110,103>>,{typeinfo,{'RoadSafetyMessage','CrossLinking'}},'OPTIONAL'}]};
typeinfo('ContentContainer') ->
  {choice,#{<<99,117,114,118,101,67,111,110,116,97,105,110,101,114>> => {typeinfo,{'RoadSafetyMessage','CurveContainer'}},<<100,121,110,97,109,105,99,73,110,102,111,67,111,110,116,97,105,110,101,114>> => {typeinfo,{'RoadSafetyMessage','DynamicInfoContainer'}},<<105,110,99,105,100,101,110,116,115,67,111,110,116,97,105,110,101,114>> => {typeinfo,{'RoadSafetyMessage','IncidentsContainer'}},<<108,97,110,101,67,108,111,115,117,114,101,67,111,110,116,97,105,110,101,114>> => {typeinfo,{'RoadSafetyMessage','LaneClosureContainer'}},<<114,115,122,67,111,110,116,97,105,110,101,114>> => {typeinfo,{'RoadSafetyMessage','ReducedSpeedZoneContainer'}},<<115,105,116,117,97,116,105,111,110,97,108,67,111,110,116,97,105,110,101,114>> => {typeinfo,{'RoadSafetyMessage','SituationalContainer'}}}};
typeinfo('CurveContainer') ->
  {sequence,'CurveContainer',5,[{<<97,100,118,105,115,111,114,121,83,112,101,101,100>>,{'INTEGER',{0,500}},mandatory},{<<115,117,114,102,97,99,101,67,111,110,100,105,116,105,111,110>>,{typeinfo,{'Common','FrictionInformation'}},'OPTIONAL'},{<<109,105,110,82,97,100,105,117,115>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<98,97,110,107,65,110,103,108,101>>,{'INTEGER',{-512,512}},'OPTIONAL'},{<<99,117,114,118,101,82,101,103,105,111,110>>,{typeinfo,{'RoadSafetyMessage','RegionInfo'}},'OPTIONAL'}]};
typeinfo('DynamicInfoContainer') ->
  {sequence,'DynamicInfoContainer',3,[{<<112,114,105,111,114,105,116,121>>,{'ENUMERATED',#{critical => 3,'low-priority' => 0,'medium-priority' => 1,'high-priority' => 2}},mandatory},{<<100,109,115,83,105,103,110,83,116,114,105,110,103>>,{sof,string},mandatory},{<<97,112,112,108,105,99,97,98,108,101,82,101,103,105,111,110>>,{typeinfo,{'RoadSafetyMessage','RegionInfo'}},mandatory}]};
typeinfo('IncidentsContainer') ->
  {sequence,'IncidentsContainer',2,[{<<114,101,115,112,111,110,100,101,114,84,121,112,101>>,{sof,{'ENUMERATED_EXT',#{'emergency-vehicle-units' => 9729,'federal-law-enforcement-units' => 9730,'state-police-units' => 9731,'county-police-units' => 9732,'local-police-units' => 9733,'ambulance-units' => 9734,'rescue-units' => 9735,'fire-units' => 9736,'hAZMAT-units' => 9737,'light-tow-unit' => 9738,'heavy-tow-unit' => 9739,'freeway-service-patrols' => 9740,'transportation-response-units' => 9741,'private-contractor-response-units' => 9742}}},'OPTIONAL'},{<<105,110,99,105,100,101,110,116,76,111,99,97,116,105,111,110>>,{typeinfo,{'RoadSafetyMessage','RegionInfo'}},mandatory}]};
typeinfo('LaneClosureContainer') ->
  {sequence,'LaneClosureContainer',3,[{<<108,97,110,101,83,116,97,116,117,115>>,{sof,{typeinfo,{'RoadSafetyMessage','LaneInfo'}}},'OPTIONAL'},{<<108,97,110,101,83,116,97,116,117,115,86,97,114,105,101,115>>,'BOOLEAN','OPTIONAL'},{<<99,108,111,115,117,114,101,82,101,103,105,111,110>>,{typeinfo,{'RoadSafetyMessage','RegionInfo'}},mandatory}]};
typeinfo('ReducedSpeedZoneContainer') ->
  {sequence,'ReducedSpeedZoneContainer',2,[{<<115,112,101,101,100,76,105,109,105,116>>,{typeinfo,{'Common','RegulatorySpeedLimit'}},mandatory},{<<114,115,122,82,101,103,105,111,110>>,{typeinfo,{'RoadSafetyMessage','RegionInfo'}},mandatory}]};
typeinfo('SituationalContainer') ->
  {sequence,'SituationalContainer',5,[{<<111,98,115,116,114,117,99,116,105,111,110,115>>,{typeinfo,{'RoadSafetyMessage','Obstructions'}},'OPTIONAL'},{<<118,105,115,105,98,105,108,105,116,121>>,{'INTEGER',{0,1000001}},'OPTIONAL'},{<<112,101,111,112,108,101,80,114,101,115,101,110,116>>,'BOOLEAN','OPTIONAL'},{<<97,110,111,109,97,108,111,117,115,84,114,97,102,102,105,99>>,'BOOLEAN','OPTIONAL'},{<<97,112,112,108,105,99,97,98,108,101,82,101,103,105,111,110>>,{typeinfo,{'RoadSafetyMessage','RegionInfo'}},mandatory}]};
typeinfo('ApplicableHeading') ->
  {sequence,'ApplicableHeading',2,[{<<104,101,97,100,105,110,103>>,{'INTEGER',{0,359}},mandatory},{<<116,111,108,101,114,97,110,99,101>>,{'INTEGER',{0,180}},mandatory}]};
typeinfo('AreaType') ->
  {choice,#{<<98,114,111,97,100,82,101,103,105,111,110>> => {typeinfo,{'RoadSafetyMessage','BroadRegion'}},<<112,97,116,104,115>> => {typeinfo,{'RoadSafetyMessage','PathList'}}}};
typeinfo('AudioLink') ->
  {sequence,'AudioLink',4,[{<<97,109,67,104,97,110,110,101,108>>,{'INTEGER',{531,1710}},'OPTIONAL'},{<<102,109,67,104,97,110,110,101,108>>,{'INTEGER',{65800,108009}},'OPTIONAL'},{<<115,97,116,101,108,108,105,116,101,67,104,97,110,110,101,108>>,{'INTEGER',{1,9999}},'OPTIONAL'},{<<117,114,108,67,104,97,110,110,101,108>>,string,'OPTIONAL'}]};
typeinfo('BroadRegion') ->
  {sequence,'BroadRegion',2,[{<<97,112,112,108,105,99,97,98,108,101,72,101,97,100,105,110,103>>,{typeinfo,{'RoadSafetyMessage','ApplicableHeading'}},mandatory},{<<98,114,111,97,100,65,114,101,97>>,{typeinfo,{'RoadSafetyMessage','BroadRegionArea'}},mandatory}]};
typeinfo('BroadRegionArea') ->
  {choice,#{<<99,105,114,99,108,101>> => {typeinfo,{'TravelerInformation','Circle'}},<<112,111,108,121,103,111,110>> => {typeinfo,{'RoadSafetyMessage','RSMPolygon'}}}};
typeinfo('CrossLinking') ->
  {sequence,'CrossLinking',3,[{<<97,117,100,105,111,76,105,110,107,115>>,{sof,{typeinfo,{'RoadSafetyMessage','AudioLink'}}},'OPTIONAL'},{<<118,105,115,117,97,108,76,105,110,107>>,{sof,{typeinfo,{'RoadSafetyMessage','VisualLink'}}},'OPTIONAL'},{<<114,115,109,76,105,110,107>>,{sof,{typeinfo,{'RoadSafetyMessage','EventIdentifier'}}},'OPTIONAL'}]};
typeinfo('EventIdentifier') ->
  {sequence,'EventIdentifier',2,[{<<111,112,101,114,97,116,111,114,73,68>>,{typeinfo,{'Common','RoadAuthorityID'}},mandatory},{<<117,110,105,113,117,101,73,68>>,octet_string,mandatory}]};
typeinfo('EventInfo') ->
  {sequence,'EventInfo',9,[{<<101,118,101,110,116,73,68>>,{typeinfo,{'RoadSafetyMessage','EventIdentifier'}},mandatory},{<<101,118,101,110,116,85,112,100,97,116,101>>,{'INTEGER',{0,127}},mandatory},{<<101,118,101,110,116,67,97,110,99,101,108,108,97,116,105,111,110>>,'BOOLEAN',mandatory},{<<115,116,97,114,116,68,97,116,101,84,105,109,101>>,{typeinfo,{'Common','DDateTime'}},mandatory},{<<101,110,100,68,97,116,101,84,105,109,101>>,{typeinfo,{'Common','DDateTime'}},'OPTIONAL'},{<<101,118,101,110,116,82,101,99,117,114,114,101,110,99,101>>,{sof,{typeinfo,{'RoadSafetyMessage','EventRecurrence'}}},'OPTIONAL'},{<<99,97,117,115,101,67,111,100,101>>,{{'INTEGER_NNL',[{trafficConditions,1},{accidentsAndIncidents,2},{closures,3},{roadwork,4},{obstruction,5},{delayStatusCancellation,6},{unusualDriving,7},{mobileSituation,8},{deviceStatus,9},{restrictionClass,10},{incidentResponseStatus,11},{disasters,12},{disturbances,13},{sportingEvents,14},{specialEvents,15},{parkingInformation,16},{systemInformation,17},{weatherConditions,18},{precipitation,19},{winds,20},{visibilityAndAirQuality,21},{temperature,22},{pavementConditions,23},{winterDrivingRestrictions,24},{winterDrivingIndex,25},{suggestionAdvice,26},{warningAdvice,27},{adviceInstructionsRecommendations,28},{adviceInstructionsMandatory,29},{qualifiers,30},{genericLocations,31},{laneRoadway,32},{alternateRoute,33},{units,34},{transitMode,35},{vehicleGroupAffected,36},{travelerGroupAffected,37},{responderGroupAffected,38},{incidentResponseEquipment,39},{assetStatus,40},{roadsideAssets,41},{transitOperations,42},{objects,43},{validManeuvers,44},{largeNumbers,45},{namedObjects,46},{recreationalObjectsAndActivities,47},{regulatoryAndWarningSigns,48},{smallNumbers,49},{states,50},{structures,51},{streetSuffixes,52},{mUTCDLocations,53}]},{0,255}},mandatory},{<<115,117,98,67,97,117,115,101,67,111,100,101>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<97,102,102,101,99,116,101,100,86,101,104,105,99,108,101,115>>,{sof,{'ENUMERATED_EXT',#{'hazardous-loads' => 9236,'vehicles-with-even-numbered-license-plates' => 9242,'vehicles-with-odd-numbered-license-plates' => 9243,'high-profile-vehicles' => 9233,'heavy-vehicles' => 9226,'lPG-vehicles' => 9249,'delivery-vehicles' => 9241,'vehicles-with-parking-permits' => 9244,cars => 9220,'vehicles-with-catalytic-converters' => 9245,motorcycles => 9219,'cars-with-trailers' => 9223,trucks => 9227,'maintenance-vehicles' => 9240,'vehicles-with-double-trailers' => 9232,convoys => 9239,'vehicles-without-catalytic-converters' => 9246,'light-vehicles' => 9221,'wide-vehicles' => 9234,'gas-powered-vehicles' => 9247,bicycles => 9218,'long-vehicles' => 9235,'school-buses' => 9230,'cars-and-light-vehicles' => 9222,'abnormal-loads' => 9238,'exceptional-loads' => 9237,'military-convoys' => 9250,'vehicles-with-semi-trailers' => 9231,buses => 9228,'diesel-powered-vehicles' => 9248,'military-vehicles' => 9251,'vehicles-with-trailers' => 9225,'cars-with-recreational-trailers' => 9224,'articulated-buses' => 9229,'all-vehicles' => 9217}}},'OPTIONAL'}]};
typeinfo('EventRecurrence') ->
  {sequence,'EventRecurrence',12,[{<<115,116,97,114,116,84,105,109,101>>,{typeinfo,{'Common','DTime'}},'OPTIONAL'},{<<101,110,100,84,105,109,101>>,{typeinfo,{'Common','DTime'}},'OPTIONAL'},{<<115,116,97,114,116,68,97,116,101>>,{typeinfo,{'Common','DDate'}},'OPTIONAL'},{<<101,110,100,68,97,116,101>>,{typeinfo,{'Common','DDate'}},'OPTIONAL'},{<<109,111,110,100,97,121>>,'BOOLEAN',mandatory},{<<116,117,101,115,100,97,121>>,'BOOLEAN',mandatory},{<<119,101,100,110,101,115,100,97,121>>,'BOOLEAN',mandatory},{<<116,104,117,114,115,100,97,121>>,'BOOLEAN',mandatory},{<<102,114,105,100,97,121>>,'BOOLEAN',mandatory},{<<115,97,116,117,114,100,97,121>>,'BOOLEAN',mandatory},{<<115,117,110,100,97,121>>,'BOOLEAN',mandatory},{<<101,120,99,108,117,115,105,111,110>>,'BOOLEAN','OPTIONAL'}]};
typeinfo('LaneInfo') ->
  {sequence,'LaneInfo',3,[{<<108,97,110,101,80,111,115,105,116,105,111,110>>,{'INTEGER',{1,32}},mandatory},{<<108,97,110,101,67,108,111,115,101,100>>,'BOOLEAN',mandatory},{<<108,97,110,101,67,108,111,115,101,79,102,102,115,101,116>>,{'INTEGER',{0,32767}},'OPTIONAL'}]};
typeinfo('NodePointLLE') ->
  {choice,#{<<110,111,100,101,45,51,68,97,98,115,111,108,117,116,101>> => {typeinfo,{'Common','Position3D'}},<<110,111,100,101,45,51,68,111,102,102,115,101,116>> => {typeinfo,{'RoadSafetyMessage','Offset3D'}}}};
typeinfo('Obstructions') ->
  {sequence,'Obstructions',2,[{<<108,111,99,97,116,105,111,110>>,{typeinfo,{'Common','Position3D'}},mandatory},{<<100,101,115,99,114,105,112,116,105,111,110>>,{'INTEGER',{0,65535}},'OPTIONAL'}]};
typeinfo('Offset3D') ->
  {sequence,'Offset3D',3,[{<<108,97,116,45,111,102,102,115,101,116>>,{'INTEGER',{-16384,16383}},mandatory},{<<108,111,110,103,45,111,102,102,115,101,116>>,{'INTEGER',{-16384,16383}},mandatory},{<<101,108,101,118,45,111,102,102,115,101,116>>,{'INTEGER',{-4096,4095}},'OPTIONAL'}]};
typeinfo('Path') ->
  {sequence,'Path',2,[{<<112,97,116,104,87,105,100,116,104>>,{'INTEGER',{0,1000}},mandatory},{<<112,97,116,104,80,111,105,110,116,115>>,{typeinfo,{'RoadSafetyMessage','PathPoints'}},mandatory}]};
typeinfo('PathList') ->
  {sof,{typeinfo,{'RoadSafetyMessage','Path'}}};
typeinfo('PathPoints') ->
  {sof,{typeinfo,{'RoadSafetyMessage','NodePointLLE'}}};
typeinfo('RegionInfo') ->
  {sequence,'RegionInfo',6,[{<<114,101,102,101,114,101,110,99,101,80,111,105,110,116>>,{typeinfo,{'Common','Position3D'}},mandatory},{<<108,111,99,97,116,105,111,110,85,110,99,101,114,116,97,105,110,116,121>>,{typeinfo,{'RoadSafetyMessage','RegionUncertainty'}},'OPTIONAL'},{<<114,101,102,101,114,101,110,99,101,80,111,105,110,116,84,121,112,101>>,{'ENUMERATED_EXT',#{arbitrary => 1,startOfEvent => 0}},'OPTIONAL'},{<<100,101,115,99,114,105,112,116,105,118,101,78,97,109,101>>,string,'OPTIONAL'},{<<115,99,97,108,101>>,{'INTEGER',{0,15}},'OPTIONAL'},{<<97,112,112,114,111,97,99,104,82,101,103,105,111,110>>,{typeinfo,{'RoadSafetyMessage','AreaType'}},'OPTIONAL'}]};
typeinfo('RegionUncertainty') ->
  {choice,#{<<97,108,111,110,103,80,97,116,104>> => {typeinfo,{'RoadSafetyMessage','Offset3D'}},<<105,110,67,111,111,114,100,105,110,97,116,101,70,114,97,109,101>> => {typeinfo,{'RoadSafetyMessage','Offset3D'}}}};
typeinfo('RSMPolygon') ->
  {sof,{typeinfo,{'RoadSafetyMessage','NodePointLLE'}}};
typeinfo('VisualLink') ->
  {sequence,'VisualLink',1,[{<<117,114,108,76,105,110,107>>,string,'OPTIONAL'}]};
typeinfo('Activity') ->
  'BOOLEAN';
typeinfo('LatOffset') ->
  {'INTEGER',{-16384,16383}};
typeinfo('LongOffset') ->
  {'INTEGER',{-16384,16383}};
typeinfo('ElevOffset') ->
  {'INTEGER',{-4096,4095}};
typeinfo('BankAngle') ->
  {'INTEGER',{-512,512}};
typeinfo('HeadingDeg') ->
  {'INTEGER',{0,359}};
typeinfo('LaneClosed') ->
  'BOOLEAN';
typeinfo('Radius') ->
  {'INTEGER',{0,65535}};
typeinfo('ReferencePointType') ->
  {'ENUMERATED_EXT',#{arbitrary => 1,startOfEvent => 0}};
typeinfo('RSMLanePosition') ->
  {'INTEGER',{1,32}};
typeinfo('ShortString') ->
  string;
typeinfo('Tolerance') ->
  {'INTEGER',{0,180}};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

dec_components1(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components1(Num, Bytes, Acc) ->
{Term,Remain} = dec_ContentContainer(Bytes),
dec_components1(Num-1, Remain, [Term|Acc]).

dec_components10(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components10(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> 'all-vehicles';
1 -> bicycles;
2 -> motorcycles;
3 -> cars;
4 -> 'light-vehicles';
5 -> 'cars-and-light-vehicles';
6 -> 'cars-with-trailers';
7 -> 'cars-with-recreational-trailers';
8 -> 'vehicles-with-trailers';
9 -> 'heavy-vehicles';
10 -> trucks;
11 -> buses;
12 -> 'articulated-buses';
13 -> 'school-buses';
14 -> 'vehicles-with-semi-trailers';
15 -> 'vehicles-with-double-trailers';
16 -> 'high-profile-vehicles';
17 -> 'wide-vehicles';
18 -> 'long-vehicles';
19 -> 'hazardous-loads';
20 -> 'exceptional-loads';
21 -> 'abnormal-loads';
22 -> convoys;
23 -> 'maintenance-vehicles';
24 -> 'delivery-vehicles';
25 -> 'vehicles-with-even-numbered-license-plates';
26 -> 'vehicles-with-odd-numbered-license-plates';
27 -> 'vehicles-with-parking-permits';
28 -> 'vehicles-with-catalytic-converters';
29 -> 'vehicles-without-catalytic-converters';
30 -> 'gas-powered-vehicles';
31 -> 'diesel-powered-vehicles';
32 -> 'lPG-vehicles';
33 -> 'military-convoys';
34 -> 'military-vehicles';
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end,
dec_components10(Num-1, Remain, [Term|Acc]).

dec_components11(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components11(Num, Bytes, Acc) ->
{Term,Remain} = dec_Path(Bytes),
dec_components11(Num-1, Remain, [Term|Acc]).

dec_components12(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components12(Num, Bytes, Acc) ->
{Term,Remain} = dec_NodePointLLE(Bytes),
dec_components12(Num-1, Remain, [Term|Acc]).

dec_components13(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components13(Num, Bytes, Acc) ->
{Term,Remain} = dec_NodePointLLE(Bytes),
dec_components13(Num-1, Remain, [Term|Acc]).

dec_components2(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components2(Num, Bytes, Acc) ->
{Term,Remain} = dec_RegionInfo(Bytes),
dec_components2(Num-1, Remain, [Term|Acc]).

dec_components3(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components3(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes,
V2@Add2 = V2@V0 + 1,
<<V2@V3:V2@Add2/binary-unit:7,V2@Buf4/bitstring>> = V2@Buf1,
{V2@V5,V2@Buf6}  = {decode_chars(V2@V3, 7),V2@Buf4},
{V2@V5,V2@Buf6}
end,
dec_components3(Num-1, Remain, [Term|Acc]).

dec_components4(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components4(Num, Bytes, Acc) ->
{Term,Remain} = begin
{V3@V0,V3@Buf1} = case Bytes of
<<0:1,V3@V3:4,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> 'emergency-vehicle-units';
1 -> 'federal-law-enforcement-units';
2 -> 'state-police-units';
3 -> 'county-police-units';
4 -> 'local-police-units';
5 -> 'ambulance-units';
6 -> 'rescue-units';
7 -> 'fire-units';
8 -> 'hAZMAT-units';
9 -> 'light-tow-unit';
10 -> 'heavy-tow-unit';
11 -> 'freeway-service-patrols';
12 -> 'transportation-response-units';
13 -> 'private-contractor-response-units';
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11};
<<1:1,1:1,V3@V10:6,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
V3@Mul12 = V3@V10 * 16384,
{V3@Mul12,V3@Buf11}
end,
<<V3@V13:V3@V6/unit:8,V3@Buf14/bitstring>> = V3@Buf7,
{V3@V13,V3@Buf14}
end,
V3@Int15 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int15,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,
dec_components4(Num-1, Remain, [Term|Acc]).

dec_components5(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components5(Num, Bytes, Acc) ->
{Term,Remain} = dec_LaneInfo(Bytes),
dec_components5(Num-1, Remain, [Term|Acc]).

dec_components6(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components6(Num, Bytes, Acc) ->
{Term,Remain} = dec_AudioLink(Bytes),
dec_components6(Num-1, Remain, [Term|Acc]).

dec_components7(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components7(Num, Bytes, Acc) ->
{Term,Remain} = dec_VisualLink(Bytes),
dec_components7(Num-1, Remain, [Term|Acc]).

dec_components8(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components8(Num, Bytes, Acc) ->
{Term,Remain} = dec_EventIdentifier(Bytes),
dec_components8(Num-1, Remain, [Term|Acc]).

dec_components9(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components9(Num, Bytes, Acc) ->
{Term,Remain} = dec_EventRecurrence(Bytes),
dec_components9(Num-1, Remain, [Term|Acc]).

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_chars(Val, N) ->
    [ 
     C ||
         <<C:N>> <= Val
    ].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

encode_chars(Val, NumBits) ->
    << 
      <<C:NumBits>> ||
          C <- Val
    >>.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
