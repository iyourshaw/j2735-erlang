%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in MapData.

-module('MapData').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("MapData.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'MapData'},
            {options,[{i,"./erl"},uper,jer,verbose,{i,"./asn"},{outdir,"./erl"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_MapData/1,
enc_ConnectingLane/1,
enc_Connection/1,
enc_ConnectsToList/1,
enc_DataParameters/1,
enc_GenericLane/1,
enc_IntersectionGeometry/1,
enc_IntersectionGeometryList/1,
enc_LaneAttributes/1,
enc_LaneList/1,
enc_LaneTypeAttributes/1,
enc_OverlayLaneList/1,
enc_PreemptPriorityList/1,
enc_SignalControlZone/1,
enc_RestrictionClassAssignment/1,
enc_RestrictionClassList/1,
enc_RestrictionUserTypeList/1,
enc_RestrictionUserType/1,
enc_RoadLaneSetList/1,
enc_RoadSegmentList/1,
enc_RoadSegment/1,
enc_AllowedManeuvers/1,
'enc_LaneAttributes-Barrier'/1,
'enc_LaneAttributes-Bike'/1,
'enc_LaneAttributes-Crosswalk'/1,
'enc_LaneAttributes-Parking'/1,
'enc_LaneAttributes-Sidewalk'/1,
'enc_LaneAttributes-Striping'/1,
'enc_LaneAttributes-TrackedVehicle'/1,
'enc_LaneAttributes-Vehicle'/1,
enc_LaneDirection/1,
enc_LaneSharing/1,
enc_LayerID/1,
enc_LayerType/1,
enc_RestrictionAppliesTo/1
]).

-export([
dec_MapData/1,
dec_ConnectingLane/1,
dec_Connection/1,
dec_ConnectsToList/1,
dec_DataParameters/1,
dec_GenericLane/1,
dec_IntersectionGeometry/1,
dec_IntersectionGeometryList/1,
dec_LaneAttributes/1,
dec_LaneList/1,
dec_LaneTypeAttributes/1,
dec_OverlayLaneList/1,
dec_PreemptPriorityList/1,
dec_SignalControlZone/1,
dec_RestrictionClassAssignment/1,
dec_RestrictionClassList/1,
dec_RestrictionUserTypeList/1,
dec_RestrictionUserType/1,
dec_RoadLaneSetList/1,
dec_RoadSegmentList/1,
dec_RoadSegment/1,
dec_AllowedManeuvers/1,
'dec_LaneAttributes-Barrier'/1,
'dec_LaneAttributes-Bike'/1,
'dec_LaneAttributes-Crosswalk'/1,
'dec_LaneAttributes-Parking'/1,
'dec_LaneAttributes-Sidewalk'/1,
'dec_LaneAttributes-Striping'/1,
'dec_LaneAttributes-TrackedVehicle'/1,
'dec_LaneAttributes-Vehicle'/1,
dec_LaneDirection/1,
dec_LaneSharing/1,
dec_LayerID/1,
dec_LayerType/1,
dec_RestrictionAppliesTo/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('MapData', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('MapData', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('MapData', Data) -> enc_MapData(Data);
encode_disp('ConnectingLane', Data) -> enc_ConnectingLane(Data);
encode_disp('Connection', Data) -> enc_Connection(Data);
encode_disp('ConnectsToList', Data) -> enc_ConnectsToList(Data);
encode_disp('DataParameters', Data) -> enc_DataParameters(Data);
encode_disp('GenericLane', Data) -> enc_GenericLane(Data);
encode_disp('IntersectionGeometry', Data) -> enc_IntersectionGeometry(Data);
encode_disp('IntersectionGeometryList', Data) -> enc_IntersectionGeometryList(Data);
encode_disp('LaneAttributes', Data) -> enc_LaneAttributes(Data);
encode_disp('LaneList', Data) -> enc_LaneList(Data);
encode_disp('LaneTypeAttributes', Data) -> enc_LaneTypeAttributes(Data);
encode_disp('OverlayLaneList', Data) -> enc_OverlayLaneList(Data);
encode_disp('PreemptPriorityList', Data) -> enc_PreemptPriorityList(Data);
encode_disp('SignalControlZone', Data) -> enc_SignalControlZone(Data);
encode_disp('RestrictionClassAssignment', Data) -> enc_RestrictionClassAssignment(Data);
encode_disp('RestrictionClassList', Data) -> enc_RestrictionClassList(Data);
encode_disp('RestrictionUserTypeList', Data) -> enc_RestrictionUserTypeList(Data);
encode_disp('RestrictionUserType', Data) -> enc_RestrictionUserType(Data);
encode_disp('RoadLaneSetList', Data) -> enc_RoadLaneSetList(Data);
encode_disp('RoadSegmentList', Data) -> enc_RoadSegmentList(Data);
encode_disp('RoadSegment', Data) -> enc_RoadSegment(Data);
encode_disp('AllowedManeuvers', Data) -> enc_AllowedManeuvers(Data);
encode_disp('LaneAttributes-Barrier', Data) -> 'enc_LaneAttributes-Barrier'(Data);
encode_disp('LaneAttributes-Bike', Data) -> 'enc_LaneAttributes-Bike'(Data);
encode_disp('LaneAttributes-Crosswalk', Data) -> 'enc_LaneAttributes-Crosswalk'(Data);
encode_disp('LaneAttributes-Parking', Data) -> 'enc_LaneAttributes-Parking'(Data);
encode_disp('LaneAttributes-Sidewalk', Data) -> 'enc_LaneAttributes-Sidewalk'(Data);
encode_disp('LaneAttributes-Striping', Data) -> 'enc_LaneAttributes-Striping'(Data);
encode_disp('LaneAttributes-TrackedVehicle', Data) -> 'enc_LaneAttributes-TrackedVehicle'(Data);
encode_disp('LaneAttributes-Vehicle', Data) -> 'enc_LaneAttributes-Vehicle'(Data);
encode_disp('LaneDirection', Data) -> enc_LaneDirection(Data);
encode_disp('LaneSharing', Data) -> enc_LaneSharing(Data);
encode_disp('LayerID', Data) -> enc_LayerID(Data);
encode_disp('LayerType', Data) -> enc_LayerType(Data);
encode_disp('RestrictionAppliesTo', Data) -> enc_RestrictionAppliesTo(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('MapData', Data) -> dec_MapData(Data);
decode_disp('ConnectingLane', Data) -> dec_ConnectingLane(Data);
decode_disp('Connection', Data) -> dec_Connection(Data);
decode_disp('ConnectsToList', Data) -> dec_ConnectsToList(Data);
decode_disp('DataParameters', Data) -> dec_DataParameters(Data);
decode_disp('GenericLane', Data) -> dec_GenericLane(Data);
decode_disp('IntersectionGeometry', Data) -> dec_IntersectionGeometry(Data);
decode_disp('IntersectionGeometryList', Data) -> dec_IntersectionGeometryList(Data);
decode_disp('LaneAttributes', Data) -> dec_LaneAttributes(Data);
decode_disp('LaneList', Data) -> dec_LaneList(Data);
decode_disp('LaneTypeAttributes', Data) -> dec_LaneTypeAttributes(Data);
decode_disp('OverlayLaneList', Data) -> dec_OverlayLaneList(Data);
decode_disp('PreemptPriorityList', Data) -> dec_PreemptPriorityList(Data);
decode_disp('SignalControlZone', Data) -> dec_SignalControlZone(Data);
decode_disp('RestrictionClassAssignment', Data) -> dec_RestrictionClassAssignment(Data);
decode_disp('RestrictionClassList', Data) -> dec_RestrictionClassList(Data);
decode_disp('RestrictionUserTypeList', Data) -> dec_RestrictionUserTypeList(Data);
decode_disp('RestrictionUserType', Data) -> dec_RestrictionUserType(Data);
decode_disp('RoadLaneSetList', Data) -> dec_RoadLaneSetList(Data);
decode_disp('RoadSegmentList', Data) -> dec_RoadSegmentList(Data);
decode_disp('RoadSegment', Data) -> dec_RoadSegment(Data);
decode_disp('AllowedManeuvers', Data) -> dec_AllowedManeuvers(Data);
decode_disp('LaneAttributes-Barrier', Data) -> 'dec_LaneAttributes-Barrier'(Data);
decode_disp('LaneAttributes-Bike', Data) -> 'dec_LaneAttributes-Bike'(Data);
decode_disp('LaneAttributes-Crosswalk', Data) -> 'dec_LaneAttributes-Crosswalk'(Data);
decode_disp('LaneAttributes-Parking', Data) -> 'dec_LaneAttributes-Parking'(Data);
decode_disp('LaneAttributes-Sidewalk', Data) -> 'dec_LaneAttributes-Sidewalk'(Data);
decode_disp('LaneAttributes-Striping', Data) -> 'dec_LaneAttributes-Striping'(Data);
decode_disp('LaneAttributes-TrackedVehicle', Data) -> 'dec_LaneAttributes-TrackedVehicle'(Data);
decode_disp('LaneAttributes-Vehicle', Data) -> 'dec_LaneAttributes-Vehicle'(Data);
decode_disp('LaneDirection', Data) -> dec_LaneDirection(Data);
decode_disp('LaneSharing', Data) -> dec_LaneSharing(Data);
decode_disp('LayerID', Data) -> dec_LayerID(Data);
decode_disp('LayerType', Data) -> dec_LayerType(Data);
decode_disp('RestrictionAppliesTo', Data) -> dec_RestrictionAppliesTo(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_MapData(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(7, Val),
Enc6@element = element(8, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(9, Val),
Enc8@element = element(10, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute timeStamp(1) with type INTEGER
Enc10@element = element(2, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
0 =< Enc10@element, Enc10@element < 527041 ->
<<Enc10@element:20>>;
true ->
exit({error,{asn1,{illegal_integer,Enc10@element}}})
end
end,
begin
%% attribute msgIssueRevision(2) with type INTEGER
Enc13@element = element(3, Val),
if Enc13@element bsr 7 =:= 0 ->
<<Enc13@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc13@element}}})
end
end,
begin
%% attribute layerType(3) with type ENUMERATED
Enc15@element = element(4, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
Enc15@element =:= none ->
<<0:1,0:3>>;
Enc15@element =:= mixedContent ->
<<0:1,1:3>>;
Enc15@element =:= generalMapData ->
<<0:1,2:3>>;
Enc15@element =:= intersectionData ->
<<0:1,3:3>>;
Enc15@element =:= curveData ->
<<0:1,4:3>>;
Enc15@element =:= roadwaySectionData ->
<<0:1,5:3>>;
Enc15@element =:= parkingAreaData ->
<<0:1,6:3>>;
Enc15@element =:= sharedLaneData ->
<<0:1,7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc15@element}}})
end
end,
begin
%% attribute layerID(4) with type INTEGER
Enc18@element = element(5, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
0 =< Enc18@element, Enc18@element < 101 ->
<<Enc18@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc18@element}}})
end
end,
begin
%% attribute intersections(5) with type IntersectionGeometryList
Enc21@element = element(6, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
enc_IntersectionGeometryList(Enc21@element)
end
end,
begin
%% attribute roadSegments(6) with type RoadSegmentList
Enc23@element = element(7, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
true ->
enc_RoadSegmentList(Enc23@element)
end
end,
begin
%% attribute dataParameters(7) with type DataParameters
Enc25@element = element(8, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
true ->
enc_DataParameters(Enc25@element)
end
end,
begin
%% attribute restrictionList(8) with type RestrictionClassList
Enc27@element = element(9, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
enc_RestrictionClassList(Enc27@element)
end
end|begin
%% attribute regional(9) with type SEQUENCE OF
Enc29@element = element(10, Val),
if Enc29@element =:= asn1_NOVALUE ->
[];
true ->
enc_MapData_regional(Enc29@element)
end
end].
enc_MapData_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_MapData_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_MapData_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type1(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_MapData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeStamp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V3@V0:20,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute msgIssueRevision(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute layerType(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 6) band 1 of
1 ->
begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:3,V5@Buf4/bitstring>> ->
V5@Int5 = case V5@V3 of
0 -> none;
1 -> mixedContent;
2 -> generalMapData;
3 -> intersectionData;
4 -> curveData;
5 -> roadwaySectionData;
6 -> parkingAreaData;
7 -> sharedLaneData
end,
{V5@Int5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:6,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<1:1,V5@Buf5/bitstring>> ->
{V5@V6,V5@Buf7} = case V5@Buf5 of
<<0:1,V5@V9:7,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10};
<<1:1,0:1,V5@V10:14,V5@Buf11/bitstring>> when V5@V10 =/= 0 ->
{V5@V10,V5@Buf11};
<<1:1,1:1,V5@V10:6,V5@Buf11/bitstring>> when V5@V10 =/= 0 ->
V5@Mul12 = V5@V10 * 16384,
{V5@Mul12,V5@Buf11}
end,
<<V5@V13:V5@V6/unit:8,V5@Buf14/bitstring>> = V5@Buf7,
{V5@V13,V5@Buf14}
end,
V5@Int15 = case V5@V3 of
_ -> {asn1_enum,V5@V3}
end,
{V5@Int15,V5@Buf4}
end,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute layerID(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V6@V0:7,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute intersections(5) with type IntersectionGeometryList
{Term5,Bytes7} = case (Opt bsr 4) band 1 of
1 ->
dec_IntersectionGeometryList(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute roadSegments(6) with type RoadSegmentList
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
dec_RoadSegmentList(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute dataParameters(7) with type DataParameters
{Term7,Bytes9} = case (Opt bsr 2) band 1 of
1 ->
dec_DataParameters(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute restrictionList(8) with type RestrictionClassList
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
dec_RestrictionClassList(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute regional(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_MapData_regional(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V7@V0,V7@Buf1} = case Bytes11 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes13= skipextensions(Bytes12, 1, Extensions),
Res1 = {'MapData',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9},
{Res1,Bytes13}.


dec_MapData_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components2(V1@Add2, V1@Buf1, []).


dec_MapData_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type3(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_ConnectingLane(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute lane(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute maneuver(2) with type BIT STRING
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc5@bs = try bit_string_name2pos_4(Enc4@element) of
Enc5@positions ->
bitstring_from_positions(Enc5@positions, 12)
catch throw:invalid ->
adjust_trailing_zeroes(Enc4@element, 12)
end,
Enc5@bits = bit_size(Enc5@bs),
if Enc5@bits =:= 12 ->
Enc5@bs
end
end
end
end].


dec_ConnectingLane(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute lane(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute maneuver(2) with type BIT STRING
{Term2,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:12/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]),V3@Buf1},
{V3@V2,V3@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,
Res1 = {'ConnectingLane',Term1,Term2},
{Res1,Bytes3}.

enc_Connection(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute connectingLane(1) with type ConnectingLane
Enc5@element = element(2, Val),
enc_ConnectingLane(Enc5@element)
end,
begin
%% attribute remoteIntersection(2) with type IntersectionReferenceID
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_IntersectionReferenceID(Enc6@element)
end
end,
begin
%% attribute signalGroup(3) with type INTEGER
Enc8@element = element(4, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
Enc8@element bsr 8 =:= 0 ->
Enc8@element;
true ->
exit({error,{asn1,{illegal_integer,Enc8@element}}})
end
end,
begin
%% attribute userClass(4) with type INTEGER
Enc11@element = element(5, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
Enc11@element bsr 8 =:= 0 ->
Enc11@element;
true ->
exit({error,{asn1,{illegal_integer,Enc11@element}}})
end
end|begin
%% attribute connectionID(5) with type INTEGER
Enc14@element = element(6, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
Enc14@element bsr 8 =:= 0 ->
[Enc14@element];
true ->
exit({error,{asn1,{illegal_integer,Enc14@element}}})
end
end].


dec_Connection(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute connectingLane(1) with type ConnectingLane
{Term1,Bytes2} = dec_ConnectingLane(Bytes1),

%% attribute remoteIntersection(2) with type IntersectionReferenceID
{Term2,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
'Common':dec_IntersectionReferenceID(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute signalGroup(3) with type INTEGER
{Term3,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes3,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute userClass(4) with type INTEGER
{Term4,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes4,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute connectionID(5) with type INTEGER
{Term5,Bytes6} = case Opt band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes5,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,
Res1 = {'Connection',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes6}.

enc_ConnectsToList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_Connection(Comp) || Comp <- Val]]
end.



dec_ConnectsToList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components5(V1@Add2, V1@Buf1, []).

enc_DataParameters(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute processMethod(1) with type IA5String
Enc6@element = element(2, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc7@len = length(Enc6@element),
Enc7@bin = encode_chars(Enc6@element, 7),
Enc7@len@sub = Enc7@len - 1,
if 0 =< Enc7@len@sub, Enc7@len@sub < 255 ->
[Enc7@len@sub|Enc7@bin]
end
end
end
end,
begin
%% attribute processAgency(2) with type IA5String
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc10@len = length(Enc9@element),
Enc10@bin = encode_chars(Enc9@element, 7),
Enc10@len@sub = Enc10@len - 1,
if 0 =< Enc10@len@sub, Enc10@len@sub < 255 ->
[Enc10@len@sub|Enc10@bin]
end
end
end
end,
begin
%% attribute lastCheckedDate(3) with type IA5String
Enc12@element = element(4, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc13@len = length(Enc12@element),
Enc13@bin = encode_chars(Enc12@element, 7),
Enc13@len@sub = Enc13@len - 1,
if 0 =< Enc13@len@sub, Enc13@len@sub < 255 ->
[Enc13@len@sub|Enc13@bin]
end
end
end
end|begin
%% attribute geoidUsed(4) with type IA5String
Enc15@element = element(5, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc16@len = length(Enc15@element),
Enc16@bin = encode_chars(Enc15@element, 7),
Enc16@len@sub = Enc16@len - 1,
if 0 =< Enc16@len@sub, Enc16@len@sub < 255 ->
[Enc16@len@sub|Enc16@bin]
end
end
end
end].


dec_DataParameters(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute processMethod(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute processAgency(2) with type IA5String
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
<<V4@V3:V4@Add2/binary-unit:7,V4@Buf4/bitstring>> = V4@Buf1,
{V4@V5,V4@Buf6}  = {decode_chars(V4@V3, 7),V4@Buf4},
{V4@V5,V4@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute lastCheckedDate(3) with type IA5String
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
<<V5@V3:V5@Add2/binary-unit:7,V5@Buf4/bitstring>> = V5@Buf1,
{V5@V5,V5@Buf6}  = {decode_chars(V5@V3, 7),V5@Buf4},
{V5@V5,V5@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute geoidUsed(4) with type IA5String
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + 1,
<<V6@V3:V6@Add2/binary-unit:7,V6@Buf4/bitstring>> = V6@Buf1,
{V6@V5,V6@Buf6}  = {decode_chars(V6@V3, 7),V6@Buf4},
{V6@V5,V6@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = {'DataParameters',Term1,Term2,Term3,Term4},
{Res1,Bytes8}.

enc_GenericLane(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(7, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(9, Val),
Enc6@element = element(10, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(11, Val),
if Enc7@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute laneID(1) with type INTEGER
Enc9@element = element(2, Val),
if Enc9@element bsr 8 =:= 0 ->
Enc9@element;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end,
begin
%% attribute name(2) with type IA5String
Enc11@element = element(3, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc12@len = length(Enc11@element),
Enc12@bin = encode_chars(Enc11@element, 7),
Enc12@len@sub = Enc12@len - 1,
if 0 =< Enc12@len@sub, Enc12@len@sub < 63 ->
[<<Enc12@len@sub:6>>|Enc12@bin]
end
end
end
end,
begin
%% attribute ingressApproach(3) with type INTEGER
Enc14@element = element(4, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
Enc14@element bsr 4 =:= 0 ->
<<Enc14@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc14@element}}})
end
end,
begin
%% attribute egressApproach(4) with type INTEGER
Enc17@element = element(5, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
Enc17@element bsr 4 =:= 0 ->
<<Enc17@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc17@element}}})
end
end,
begin
%% attribute laneAttributes(5) with type LaneAttributes
Enc20@element = element(6, Val),
enc_LaneAttributes(Enc20@element)
end,
begin
%% attribute maneuvers(6) with type BIT STRING
Enc21@element = element(7, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc22@bs = try bit_string_name2pos_4(Enc21@element) of
Enc22@positions ->
bitstring_from_positions(Enc22@positions, 12)
catch throw:invalid ->
adjust_trailing_zeroes(Enc21@element, 12)
end,
Enc22@bits = bit_size(Enc22@bs),
if Enc22@bits =:= 12 ->
Enc22@bs
end
end
end
end,
begin
%% attribute nodeList(7) with type NodeListXY
Enc24@element = element(8, Val),
'Common':enc_NodeListXY(Enc24@element)
end,
begin
%% attribute connectsTo(8) with type ConnectsToList
Enc25@element = element(9, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
true ->
enc_ConnectsToList(Enc25@element)
end
end,
begin
%% attribute overlays(9) with type OverlayLaneList
Enc27@element = element(10, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
enc_OverlayLaneList(Enc27@element)
end
end|begin
%% attribute regional(10) with type SEQUENCE OF
Enc29@element = element(11, Val),
if Enc29@element =:= asn1_NOVALUE ->
[];
true ->
enc_GenericLane_regional(Enc29@element)
end
end].
enc_GenericLane_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_GenericLane_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_GenericLane_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type6(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_GenericLane(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute laneID(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute name(2) with type IA5String
{Term2,Bytes4} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V4@V0:6,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
<<V4@V3:V4@Add2/binary-unit:7,V4@Buf4/bitstring>> = V4@Buf1,
{V4@V5,V4@Buf6}  = {decode_chars(V4@V3, 7),V4@Buf4},
{V4@V5,V4@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute ingressApproach(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute egressApproach(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V6@V0:4,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute laneAttributes(5) with type LaneAttributes
{Term5,Bytes7} = dec_LaneAttributes(Bytes6),

%% attribute maneuvers(6) with type BIT STRING
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V7@V0:12/binary-unit:1,V7@Buf1/bitstring>> = Bytes7,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]),V7@Buf1},
{V7@V2,V7@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute nodeList(7) with type NodeListXY
{Term7,Bytes9} = 'Common':dec_NodeListXY(Bytes8),

%% attribute connectsTo(8) with type ConnectsToList
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
dec_ConnectsToList(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute overlays(9) with type OverlayLaneList
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
dec_OverlayLaneList(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute regional(10) with type SEQUENCE OF
{Term10,Bytes12} = case Opt band 1 of
1 ->
dec_GenericLane_regional(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V8@V0,V8@Buf1} = case Bytes12 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8};
<<1:1,1:1,V8@V7:6,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
V8@Mul9 = V8@V7 * 16384,
{V8@Mul9,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V10:V8@V0/bitstring-unit:1,V8@Buf11/bitstring>> = V8@Buf1,
{V8@V10,V8@Buf11}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = {'GenericLane',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10},
{Res1,Bytes14}.


dec_GenericLane_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components7(V1@Add2, V1@Buf1, []).


dec_GenericLane_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_IntersectionGeometry(Val) ->
Enc6@bitmap = extension_bitmap(Val, 11, 12),
Extensions = if Enc6@bitmap =:= 0 ->
[];
true ->
<<0:7,1:1>>
end,
[begin
Enc1@element = element(2, Val),
if Extensions =:= [] ->
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc1@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc2@element = element(6, Val),
Enc3@element = element(7, Val),
if Enc2@element =:= asn1_NOVALUE ->
if Enc3@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc3@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc4@element = element(9, Val),
Enc5@element = element(10, Val),
if Enc4@element =:= asn1_NOVALUE ->
if Enc5@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc5@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute name(1) with type IA5String
Enc8@element = element(2, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc9@len = length(Enc8@element),
Enc9@bin = encode_chars(Enc8@element, 7),
Enc9@len@sub = Enc9@len - 1,
if 0 =< Enc9@len@sub, Enc9@len@sub < 63 ->
[<<Enc9@len@sub:6>>|Enc9@bin]
end
end
end
end,
begin
%% attribute id(2) with type IntersectionReferenceID
Enc11@element = element(3, Val),
'Common':enc_IntersectionReferenceID(Enc11@element)
end,
begin
%% attribute revision(3) with type INTEGER
Enc12@element = element(4, Val),
if Enc12@element bsr 7 =:= 0 ->
<<Enc12@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end,
begin
%% attribute refPoint(4) with type Position3D
Enc14@element = element(5, Val),
'Common':enc_Position3D(Enc14@element)
end,
begin
%% attribute laneWidth(5) with type INTEGER
Enc15@element = element(6, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
Enc15@element bsr 15 =:= 0 ->
<<Enc15@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc15@element}}})
end
end,
begin
%% attribute speedLimits(6) with type SpeedLimitList
Enc18@element = element(7, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_SpeedLimitList(Enc18@element)
end
end,
begin
%% attribute laneSet(7) with type LaneList
Enc20@element = element(8, Val),
enc_LaneList(Enc20@element)
end,
begin
%% attribute preemptPriorityData(8) with type PreemptPriorityList
Enc21@element = element(9, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
enc_PreemptPriorityList(Enc21@element)
end
end,
begin
%% attribute regional(9) with type SEQUENCE OF
Enc23@element = element(10, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
true ->
enc_IntersectionGeometry_regional(Enc23@element)
end
end,
Extensions|begin
%% attribute roadAuthorityID(10) with type RoadAuthorityID
Enc25@element = element(11, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc26@output = 'Common':enc_RoadAuthorityID(Enc25@element),
Enc26@bin = complete(Enc26@output),
Enc26@len = byte_size(Enc26@bin),
if Enc26@len < 128 ->
[Enc26@len|Enc26@bin];
Enc26@len < 16384 ->
[<<2:2,Enc26@len:14>>|Enc26@bin];
true ->
encode_fragmented(Enc26@bin, 8)
end
end
end
end].
enc_IntersectionGeometry_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_IntersectionGeometry_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_IntersectionGeometry_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type6(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_IntersectionGeometry(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute name(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute id(2) with type IntersectionReferenceID
{Term2,Bytes4} = 'Common':dec_IntersectionReferenceID(Bytes3),

%% attribute revision(3) with type INTEGER
{Term3,Bytes5} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end,

%% attribute refPoint(4) with type Position3D
{Term4,Bytes6} = 'Common':dec_Position3D(Bytes5),

%% attribute laneWidth(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:15,V5@Buf1/bitstring>> = Bytes6,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute speedLimits(6) with type SpeedLimitList
{Term6,Bytes8} = case (Opt bsr 2) band 1 of
1 ->
'Common':dec_SpeedLimitList(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute laneSet(7) with type LaneList
{Term7,Bytes9} = dec_LaneList(Bytes8),

%% attribute preemptPriorityData(8) with type PreemptPriorityList
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
dec_PreemptPriorityList(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute regional(9) with type SEQUENCE OF
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_IntersectionGeometry_regional(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V6@V0,V6@Buf1} = case Bytes11 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,

%% attribute roadAuthorityID(10) with type RoadAuthorityID
{Term10,Bytes13} = case Extensions of
  <<_:0,1:1,_/bitstring>> ->
begin
{V7@V0,V7@Buf1} = case Bytes12 of
<<0:1,V7@V3:7,V7@V5:V7@V3/binary-unit:8,V7@Buf6/bitstring>> ->
{V7@V5,V7@Buf6};
<<1:1,0:1,V7@V4:14,V7@V6:V7@V4/binary-unit:8,V7@Buf7/bitstring>> ->
{V7@V6,V7@Buf7};
<<1:1,1:1,V7@V4:6,V7@Buf5/bitstring>> ->
{V7@V6,V7@Buf7}  = decode_fragmented(V7@V4, V7@Buf5, 8),
{V7@V6,V7@Buf7}
end,
{TmpValx10,_} = 'Common':dec_RoadAuthorityID(V7@V0),
{TmpValx10,V7@Buf1}
end;
_  ->
{asn1_NOVALUE,Bytes12}
end,
Bytes14= skipextensions(Bytes13, 2, Extensions),
Res1 = {'IntersectionGeometry',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10},
{Res1,Bytes14}.


dec_IntersectionGeometry_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components9(V1@Add2, V1@Buf1, []).


dec_IntersectionGeometry_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_IntersectionGeometryList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_IntersectionGeometry(Comp) || Comp <- Val]]
end.



dec_IntersectionGeometryList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components10(V1@Add2, V1@Buf1, []).

enc_LaneAttributes(Val) ->
[begin
Enc1@element = element(5, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute directionalUse(1) with type BIT STRING
Enc2@element = element(2, Val),
Enc3@bs = try bit_string_name2pos_11(Enc2@element) of
Enc3@positions ->
bitstring_from_positions(Enc3@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Enc2@element, 2)
end,
Enc3@bits = bit_size(Enc3@bs),
if Enc3@bits =:= 2 ->
Enc3@bs
end
end,
begin
%% attribute sharedWith(2) with type BIT STRING
Enc4@element = element(3, Val),
Enc5@bs = try bit_string_name2pos_12(Enc4@element) of
Enc5@positions ->
bitstring_from_positions(Enc5@positions, 10)
catch throw:invalid ->
adjust_trailing_zeroes(Enc4@element, 10)
end,
Enc5@bits = bit_size(Enc5@bs),
if Enc5@bits =:= 10 ->
Enc5@bs
end
end,
begin
%% attribute laneType(3) with type LaneTypeAttributes
Enc6@element = element(4, Val),
enc_LaneTypeAttributes(Enc6@element)
end|begin
%% attribute regional(4) with type SEQUENCE
Enc7@element = element(5, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
enc_LaneAttributes_regional(Enc7@element)
end
end].
enc_LaneAttributes_regional(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type6(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_LaneAttributes(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute directionalUse(1) with type BIT STRING
{Term1,Bytes2} = begin
<<V2@V0:2/binary-unit:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V2,V2@Buf3}  = {decode_named_bit_string(V2@V0, [{ingressPath,0},{egressPath,1}]),V2@Buf1},
{V2@V2,V2@Buf3}
end,

%% attribute sharedWith(2) with type BIT STRING
{Term2,Bytes3} = begin
<<V3@V0:10/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{overlappingLaneDescriptionProvided,0},{multipleLanesTreatedAsOneLane,1},{otherNonMotorizedTrafficTypes,2},{individualMotorizedVehicleTraffic,3},{busVehicleTraffic,4},{taxiVehicleTraffic,5},{pedestriansTraffic,6},{cyclistVehicleTraffic,7},{trackedVehicleTraffic,8},{reserved,9}]),V3@Buf1},
{V3@V2,V3@Buf3}
end,

%% attribute laneType(3) with type LaneTypeAttributes
{Term3,Bytes4} = dec_LaneTypeAttributes(Bytes3),

%% attribute regional(4) with type SEQUENCE
{Term4,Bytes5} = case Opt band 1 of
1 ->
dec_LaneAttributes_regional(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = {'LaneAttributes',Term1,Term2,Term3,Term4},
{Res1,Bytes5}.


dec_LaneAttributes_regional(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = {'LaneAttributes_regional',Term1,Term2},
{Res1,Bytes2}.

enc_LaneList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 255 ->
[Enc1@len@sub|[enc_GenericLane(Comp) || Comp <- Val]]
end.



dec_LaneList(Bytes) ->
%% Length with constraint {1,255}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components13(V1@Add2, V1@Buf1, []).

enc_LaneTypeAttributes(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= vehicle ->
begin
Enc2@bs = try bit_string_name2pos_14(ChoiceVal) of
Enc2@positions ->
bitstring_from_positions(Enc2@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 8)
end,
Enc2@bits = bit_size(Enc2@bs),
if Enc2@bits =:= 8 ->
[<<0:1,0:3,0:1>>|Enc2@bs];
Enc2@bits < 128 ->
[<<0:1,0:3,1:1,Enc2@bits:8>>|Enc2@bs];
Enc2@bits < 16384 ->
[<<0:1,0:3,1:1,2:2,Enc2@bits:14>>|Enc2@bs];
true ->
[<<0:1,0:3,1:1>>|encode_fragmented(Enc2@bs, 1)]
end
end;
ChoiceTag =:= crosswalk ->
begin
Enc4@bs = try bit_string_name2pos_15(ChoiceVal) of
Enc4@positions ->
bitstring_from_positions(Enc4@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc4@bits = bit_size(Enc4@bs),
if Enc4@bits =:= 16 ->
[<<0:1,1:3>>|Enc4@bs]
end
end;
ChoiceTag =:= bikeLane ->
begin
Enc6@bs = try bit_string_name2pos_16(ChoiceVal) of
Enc6@positions ->
bitstring_from_positions(Enc6@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc6@bits = bit_size(Enc6@bs),
if Enc6@bits =:= 16 ->
[<<0:1,2:3>>|Enc6@bs]
end
end;
ChoiceTag =:= sidewalk ->
begin
Enc8@bs = try bit_string_name2pos_17(ChoiceVal) of
Enc8@positions ->
bitstring_from_positions(Enc8@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc8@bits = bit_size(Enc8@bs),
if Enc8@bits =:= 16 ->
[<<0:1,3:3>>|Enc8@bs]
end
end;
ChoiceTag =:= median ->
begin
Enc10@bs = try bit_string_name2pos_18(ChoiceVal) of
Enc10@positions ->
bitstring_from_positions(Enc10@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc10@bits = bit_size(Enc10@bs),
if Enc10@bits =:= 16 ->
[<<0:1,4:3>>|Enc10@bs]
end
end;
ChoiceTag =:= striping ->
begin
Enc12@bs = try bit_string_name2pos_19(ChoiceVal) of
Enc12@positions ->
bitstring_from_positions(Enc12@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc12@bits = bit_size(Enc12@bs),
if Enc12@bits =:= 16 ->
[<<0:1,5:3>>|Enc12@bs]
end
end;
ChoiceTag =:= trackedVehicle ->
begin
Enc14@bs = try bit_string_name2pos_20(ChoiceVal) of
Enc14@positions ->
bitstring_from_positions(Enc14@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc14@bits = bit_size(Enc14@bs),
if Enc14@bits =:= 16 ->
[<<0:1,6:3>>|Enc14@bs]
end
end;
ChoiceTag =:= parking ->
begin
Enc16@bs = try bit_string_name2pos_21(ChoiceVal) of
Enc16@positions ->
bitstring_from_positions(Enc16@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(ChoiceVal, 16)
end,
Enc16@bits = bit_size(Enc16@bs),
if Enc16@bits =:= 16 ->
[<<0:1,7:3>>|Enc16@bs]
end
end
end.


dec_LaneTypeAttributes(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:8/binary-unit:1,V2@Buf4/bitstring>> ->
{V2@V3,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@V8:V2@V6/binary-unit:1,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<1:1,0:1,V2@V7:14,V2@V9:V2@V7/binary-unit:1,V2@Buf10/bitstring>> ->
{V2@V9,V2@Buf10};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> ->
{V2@V9,V2@Buf10}  = decode_fragmented(V2@V7, V2@Buf8, 1),
{V2@V9,V2@Buf10}
end,
{V2@V3,V2@Buf4}
end,
{V2@V11,V2@Buf12}  = {decode_named_bit_string(V2@V0, [{isVehicleRevocableLane,0},{isVehicleFlyOverLane,1},{hovLaneUseOnly,2},{restrictedToBusUse,3},{restrictedToTaxiUse,4},{restrictedFromPublicUse,5},{hasIRbeaconCoverage,6},{permissionOnRequest,7}]),V2@Buf1},
{V2@V11,V2@Buf12}
end
end,
{{vehicle,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:16/binary-unit:1,V3@Buf1/bitstring>> = Bytes2,
{V3@V2,V3@Buf3}  = {decode_named_bit_string(V3@V0, [{crosswalkRevocableLane,0},{bicyleUseAllowed,1},{isXwalkFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{hasPushToWalkButton,5},{audioSupport,6},{rfSignalRequestPresent,7},{unsignalizedSegmentsPresent,8}]),V3@Buf1},
{V3@V2,V3@Buf3}
end
end,
{{crosswalk,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
<<V4@V0:16/binary-unit:1,V4@Buf1/bitstring>> = Bytes2,
{V4@V2,V4@Buf3}  = {decode_named_bit_string(V4@V0, [{bikeRevocableLane,0},{pedestrianUseAllowed,1},{isBikeFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{isolatedByBarrier,5},{unsignalizedSegmentsPresent,6}]),V4@Buf1},
{V4@V2,V4@Buf3}
end
end,
{{bikeLane,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
begin
<<V5@V0:16/binary-unit:1,V5@Buf1/bitstring>> = Bytes2,
{V5@V2,V5@Buf3}  = {decode_named_bit_string(V5@V0, [{'sidewalk-RevocableLane',0},{bicyleUseAllowed,1},{isSidewalkFlyOverLane,2},{walkBikes,3}]),V5@Buf1},
{V5@V2,V5@Buf3}
end
end,
{{sidewalk,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
begin
<<V6@V0:16/binary-unit:1,V6@Buf1/bitstring>> = Bytes2,
{V6@V2,V6@Buf3}  = {decode_named_bit_string(V6@V0, [{'median-RevocableLane',0},{median,1},{whiteLineHashing,2},{stripedLines,3},{doubleStripedLines,4},{trafficCones,5},{constructionBarrier,6},{trafficChannels,7},{lowCurbs,8},{highCurbs,9}]),V6@Buf1},
{V6@V2,V6@Buf3}
end
end,
{{median,Val},NewBytes};
5 ->
{Val,NewBytes} = begin
begin
<<V7@V0:16/binary-unit:1,V7@Buf1/bitstring>> = Bytes2,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{stripeToConnectingLanesRevocableLane,0},{stripeDrawOnLeft,1},{stripeDrawOnRight,2},{stripeToConnectingLanesLeft,3},{stripeToConnectingLanesRight,4},{stripeToConnectingLanesAhead,5}]),V7@Buf1},
{V7@V2,V7@Buf3}
end
end,
{{striping,Val},NewBytes};
6 ->
{Val,NewBytes} = begin
begin
<<V8@V0:16/binary-unit:1,V8@Buf1/bitstring>> = Bytes2,
{V8@V2,V8@Buf3}  = {decode_named_bit_string(V8@V0, [{'spec-RevocableLane',0},{'spec-commuterRailRoadTrack',1},{'spec-lightRailRoadTrack',2},{'spec-heavyRailRoadTrack',3},{'spec-otherRailType',4}]),V8@Buf1},
{V8@V2,V8@Buf3}
end
end,
{{trackedVehicle,Val},NewBytes};
7 ->
{Val,NewBytes} = begin
begin
<<V9@V0:16/binary-unit:1,V9@Buf1/bitstring>> = Bytes2,
{V9@V2,V9@Buf3}  = {decode_named_bit_string(V9@V0, [{parkingRevocableLane,0},{parallelParkingInUse,1},{headInParkingInUse,2},{doNotParkZone,3},{parkingForBusUse,4},{parkingForTaxiUse,5},{noPublicParkingUse,6}]),V9@Buf1},
{V9@V2,V9@Buf3}
end
end,
{{parking,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
enc_OverlayLaneList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 5 ->
[<<Enc2@len@sub:3>>|[if Comp bsr 8 =:= 0 ->
[Comp];
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.



dec_OverlayLaneList(Bytes) ->
%% Length with constraint {1,5}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components22(V1@Add2, V1@Buf1, []).

enc_PreemptPriorityList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_SignalControlZone(Comp) || Comp <- Val]]
end.



dec_PreemptPriorityList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components23(V1@Add2, V1@Buf1, []).

enc_SignalControlZone(Val) ->
[<<0:1>>|begin
%% attribute zone(1) with type SEQUENCE
Enc2@element = element(2, Val),
enc_SignalControlZone_zone(Enc2@element)
end].
enc_SignalControlZone_zone(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type6(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_SignalControlZone(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute zone(1) with type SEQUENCE
{Term1,Bytes2} = dec_SignalControlZone_zone(Bytes1),

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = {'SignalControlZone',Term1},
{Res1,Bytes4}.


dec_SignalControlZone_zone(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = {'SignalControlZone_zone',Term1,Term2},
{Res1,Bytes2}.

enc_RestrictionClassAssignment(Val) ->
[begin
%% attribute id(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 8 =:= 0 ->
Enc1@element;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute users(2) with type RestrictionUserTypeList
Enc3@element = element(3, Val),
enc_RestrictionUserTypeList(Enc3@element)
end].


dec_RestrictionClassAssignment(Bytes) ->

%% attribute id(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute users(2) with type RestrictionUserTypeList
{Term2,Bytes2} = dec_RestrictionUserTypeList(Bytes1),
Res1 = {'RestrictionClassAssignment',Term1,Term2},
{Res1,Bytes2}.

enc_RestrictionClassList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 254 ->
[Enc1@len@sub|[enc_RestrictionClassAssignment(Comp) || Comp <- Val]]
end.



dec_RestrictionClassList(Bytes) ->
%% Length with constraint {1,254}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components24(V1@Add2, V1@Buf1, []).

enc_RestrictionUserTypeList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 4 =:= 0 ->
[<<Enc1@len@sub:4>>|[enc_RestrictionUserType(Comp) || Comp <- Val]]
end.



dec_RestrictionUserTypeList(Bytes) ->
%% Length with constraint {1,16}
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components25(V1@Add2, V1@Buf1, []).

enc_RestrictionUserType(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= basicType ->
if ChoiceVal =:= none ->
<<0:1,0:1,0:1,0:4>>;
ChoiceVal =:= equippedTransit ->
<<0:1,0:1,0:1,1:4>>;
ChoiceVal =:= equippedTaxis ->
<<0:1,0:1,0:1,2:4>>;
ChoiceVal =:= equippedOther ->
<<0:1,0:1,0:1,3:4>>;
ChoiceVal =:= emissionCompliant ->
<<0:1,0:1,0:1,4:4>>;
ChoiceVal =:= equippedBicycle ->
<<0:1,0:1,0:1,5:4>>;
ChoiceVal =:= weightCompliant ->
<<0:1,0:1,0:1,6:4>>;
ChoiceVal =:= heightCompliant ->
<<0:1,0:1,0:1,7:4>>;
ChoiceVal =:= pedestrians ->
<<0:1,0:1,0:1,8:4>>;
ChoiceVal =:= slowMovingPersons ->
<<0:1,0:1,0:1,9:4>>;
ChoiceVal =:= wheelchairUsers ->
<<0:1,0:1,0:1,10:4>>;
ChoiceVal =:= visualDisabilities ->
<<0:1,0:1,0:1,11:4>>;
ChoiceVal =:= audioDisabilities ->
<<0:1,0:1,0:1,12:4>>;
ChoiceVal =:= otherUnknownDisabilities ->
<<0:1,0:1,0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,ChoiceVal}}})
end;
ChoiceTag =:= regional ->
[<<0:1,1:1>>|enc_RestrictionUserType_regional(ChoiceVal)]
end.
enc_RestrictionUserType_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_RestrictionUserType_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_RestrictionUserType_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type26(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_RestrictionUserType(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:4,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> none;
1 -> equippedTransit;
2 -> equippedTaxis;
3 -> equippedOther;
4 -> emissionCompliant;
5 -> equippedBicycle;
6 -> weightCompliant;
7 -> heightCompliant;
8 -> pedestrians;
9 -> slowMovingPersons;
10 -> wheelchairUsers;
11 -> visualDisabilities;
12 -> audioDisabilities;
13 -> otherUnknownDisabilities;
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11};
<<1:1,1:1,V2@V10:6,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
V2@Mul12 = V2@V10 * 16384,
{V2@Mul12,V2@Buf11}
end,
<<V2@V13:V2@V6/unit:8,V2@Buf14/bitstring>> = V2@Buf7,
{V2@V13,V2@Buf14}
end,
V2@Int15 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int15,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end
end,
{{basicType,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_RestrictionUserType_regional(Bytes2)
end,
{{regional,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.

dec_RestrictionUserType_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components27(V1@Add2, V1@Buf1, []).


dec_RestrictionUserType_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type28(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_RoadLaneSetList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 255 ->
[Enc1@len@sub|[enc_GenericLane(Comp) || Comp <- Val]]
end.



dec_RoadLaneSetList(Bytes) ->
%% Length with constraint {1,255}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components29(V1@Add2, V1@Buf1, []).

enc_RoadSegmentList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 5 =:= 0 ->
[<<Enc1@len@sub:5>>|[enc_RoadSegment(Comp) || Comp <- Val]]
end.



dec_RoadSegmentList(Bytes) ->
%% Length with constraint {1,32}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components30(V1@Add2, V1@Buf1, []).

enc_RoadSegment(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(6, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(7, Val),
Enc4@element = element(9, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute name(1) with type IA5String
Enc6@element = element(2, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc7@len = length(Enc6@element),
Enc7@bin = encode_chars(Enc6@element, 7),
Enc7@len@sub = Enc7@len - 1,
if 0 =< Enc7@len@sub, Enc7@len@sub < 63 ->
[<<Enc7@len@sub:6>>|Enc7@bin]
end
end
end
end,
begin
%% attribute id(2) with type RoadSegmentReferenceID
Enc9@element = element(3, Val),
'Common':enc_RoadSegmentReferenceID(Enc9@element)
end,
begin
%% attribute revision(3) with type INTEGER
Enc10@element = element(4, Val),
if Enc10@element bsr 7 =:= 0 ->
<<Enc10@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc10@element}}})
end
end,
begin
%% attribute refPoint(4) with type Position3D
Enc12@element = element(5, Val),
'Common':enc_Position3D(Enc12@element)
end,
begin
%% attribute laneWidth(5) with type INTEGER
Enc13@element = element(6, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
Enc13@element bsr 15 =:= 0 ->
<<Enc13@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc13@element}}})
end
end,
begin
%% attribute speedLimits(6) with type SpeedLimitList
Enc16@element = element(7, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_SpeedLimitList(Enc16@element)
end
end,
begin
%% attribute roadLaneSet(7) with type RoadLaneSetList
Enc18@element = element(8, Val),
enc_RoadLaneSetList(Enc18@element)
end|begin
%% attribute regional(8) with type SEQUENCE OF
Enc19@element = element(9, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
enc_RoadSegment_regional(Enc19@element)
end
end].
enc_RoadSegment_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_RoadSegment_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_RoadSegment_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type6(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_RoadSegment(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute name(1) with type IA5String
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:6,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:7,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {decode_chars(V3@V3, 7),V3@Buf4},
{V3@V5,V3@Buf6}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute id(2) with type RoadSegmentReferenceID
{Term2,Bytes4} = 'Common':dec_RoadSegmentReferenceID(Bytes3),

%% attribute revision(3) with type INTEGER
{Term3,Bytes5} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end,

%% attribute refPoint(4) with type Position3D
{Term4,Bytes6} = 'Common':dec_Position3D(Bytes5),

%% attribute laneWidth(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:15,V5@Buf1/bitstring>> = Bytes6,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute speedLimits(6) with type SpeedLimitList
{Term6,Bytes8} = case (Opt bsr 1) band 1 of
1 ->
'Common':dec_SpeedLimitList(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute roadLaneSet(7) with type RoadLaneSetList
{Term7,Bytes9} = dec_RoadLaneSetList(Bytes8),

%% attribute regional(8) with type SEQUENCE OF
{Term8,Bytes10} = case Opt band 1 of
1 ->
dec_RoadSegment_regional(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% Extensions
{Extensions,Bytes11} = case Ext of
0 -> {<<>>,Bytes10};
1 ->
{V6@V0,V6@Buf1} = case Bytes10 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes12= skipextensions(Bytes11, 1, Extensions),
Res1 = {'RoadSegment',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8},
{Res1,Bytes12}.


dec_RoadSegment_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components31(V1@Add2, V1@Buf1, []).


dec_RoadSegment_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type8(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_AllowedManeuvers(Val) ->
Enc1@bs = try bit_string_name2pos_4(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 12)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 12)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 12 ->
Enc1@bs
end.


dec_AllowedManeuvers(Bytes) ->
begin
<<V1@V0:12/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Barrier'(Val) ->
Enc1@bs = try bit_string_name2pos_18(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Barrier'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{'median-RevocableLane',0},{median,1},{whiteLineHashing,2},{stripedLines,3},{doubleStripedLines,4},{trafficCones,5},{constructionBarrier,6},{trafficChannels,7},{lowCurbs,8},{highCurbs,9}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Bike'(Val) ->
Enc1@bs = try bit_string_name2pos_16(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Bike'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{bikeRevocableLane,0},{pedestrianUseAllowed,1},{isBikeFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{isolatedByBarrier,5},{unsignalizedSegmentsPresent,6}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Crosswalk'(Val) ->
Enc1@bs = try bit_string_name2pos_15(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Crosswalk'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{crosswalkRevocableLane,0},{bicyleUseAllowed,1},{isXwalkFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{hasPushToWalkButton,5},{audioSupport,6},{rfSignalRequestPresent,7},{unsignalizedSegmentsPresent,8}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Parking'(Val) ->
Enc1@bs = try bit_string_name2pos_21(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Parking'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{parkingRevocableLane,0},{parallelParkingInUse,1},{headInParkingInUse,2},{doNotParkZone,3},{parkingForBusUse,4},{parkingForTaxiUse,5},{noPublicParkingUse,6}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Sidewalk'(Val) ->
Enc1@bs = try bit_string_name2pos_17(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Sidewalk'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{'sidewalk-RevocableLane',0},{bicyleUseAllowed,1},{isSidewalkFlyOverLane,2},{walkBikes,3}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Striping'(Val) ->
Enc1@bs = try bit_string_name2pos_19(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-Striping'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{stripeToConnectingLanesRevocableLane,0},{stripeDrawOnLeft,1},{stripeDrawOnRight,2},{stripeToConnectingLanesLeft,3},{stripeToConnectingLanesRight,4},{stripeToConnectingLanesAhead,5}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-TrackedVehicle'(Val) ->
Enc1@bs = try bit_string_name2pos_20(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 16)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 16 ->
Enc1@bs
end.


'dec_LaneAttributes-TrackedVehicle'(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{'spec-RevocableLane',0},{'spec-commuterRailRoadTrack',1},{'spec-lightRailRoadTrack',2},{'spec-heavyRailRoadTrack',3},{'spec-otherRailType',4}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

'enc_LaneAttributes-Vehicle'(Val) ->
Enc1@bs = try bit_string_name2pos_14(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 8)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 8)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 8 ->
[<<0:1>>|Enc1@bs];
Enc1@bits < 128 ->
[<<1:1,Enc1@bits:8>>|Enc1@bs];
Enc1@bits < 16384 ->
[<<1:1,2:2,Enc1@bits:14>>|Enc1@bs];
true ->
[<<1:1>>|encode_fragmented(Enc1@bs, 1)]
end.


'dec_LaneAttributes-Vehicle'(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:8/binary-unit:1,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@V8:V1@V6/binary-unit:1,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<1:1,0:1,V1@V7:14,V1@V9:V1@V7/binary-unit:1,V1@Buf10/bitstring>> ->
{V1@V9,V1@Buf10};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> ->
{V1@V9,V1@Buf10}  = decode_fragmented(V1@V7, V1@Buf8, 1),
{V1@V9,V1@Buf10}
end,
{V1@V3,V1@Buf4}
end,
{V1@V11,V1@Buf12}  = {decode_named_bit_string(V1@V0, [{isVehicleRevocableLane,0},{isVehicleFlyOverLane,1},{hovLaneUseOnly,2},{restrictedToBusUse,3},{restrictedToTaxiUse,4},{restrictedFromPublicUse,5},{hasIRbeaconCoverage,6},{permissionOnRequest,7}]),V1@Buf1},
{V1@V11,V1@Buf12}
end.

enc_LaneDirection(Val) ->
Enc1@bs = try bit_string_name2pos_11(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 2)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 2 ->
Enc1@bs
end.


dec_LaneDirection(Bytes) ->
begin
<<V1@V0:2/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{ingressPath,0},{egressPath,1}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_LaneSharing(Val) ->
Enc1@bs = try bit_string_name2pos_12(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 10)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 10)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 10 ->
Enc1@bs
end.


dec_LaneSharing(Bytes) ->
begin
<<V1@V0:10/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{overlappingLaneDescriptionProvided,0},{multipleLanesTreatedAsOneLane,1},{otherNonMotorizedTrafficTypes,2},{individualMotorizedVehicleTraffic,3},{busVehicleTraffic,4},{taxiVehicleTraffic,5},{pedestriansTraffic,6},{cyclistVehicleTraffic,7},{trackedVehicleTraffic,8},{reserved,9}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_LayerID(Val) ->
if 0 =< Val, Val < 101 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LayerID(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_LayerType(Val) ->
if Val =:= none ->
<<0:1,0:3>>;
Val =:= mixedContent ->
<<0:1,1:3>>;
Val =:= generalMapData ->
<<0:1,2:3>>;
Val =:= intersectionData ->
<<0:1,3:3>>;
Val =:= curveData ->
<<0:1,4:3>>;
Val =:= roadwaySectionData ->
<<0:1,5:3>>;
Val =:= parkingAreaData ->
<<0:1,6:3>>;
Val =:= sharedLaneData ->
<<0:1,7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_LayerType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:3,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> none;
1 -> mixedContent;
2 -> generalMapData;
3 -> intersectionData;
4 -> curveData;
5 -> roadwaySectionData;
6 -> parkingAreaData;
7 -> sharedLaneData
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_RestrictionAppliesTo(Val) ->
if Val =:= none ->
<<0:1,0:4>>;
Val =:= equippedTransit ->
<<0:1,1:4>>;
Val =:= equippedTaxis ->
<<0:1,2:4>>;
Val =:= equippedOther ->
<<0:1,3:4>>;
Val =:= emissionCompliant ->
<<0:1,4:4>>;
Val =:= equippedBicycle ->
<<0:1,5:4>>;
Val =:= weightCompliant ->
<<0:1,6:4>>;
Val =:= heightCompliant ->
<<0:1,7:4>>;
Val =:= pedestrians ->
<<0:1,8:4>>;
Val =:= slowMovingPersons ->
<<0:1,9:4>>;
Val =:= wheelchairUsers ->
<<0:1,10:4>>;
Val =:= visualDisabilities ->
<<0:1,11:4>>;
Val =:= audioDisabilities ->
<<0:1,12:4>>;
Val =:= otherUnknownDisabilities ->
<<0:1,13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_RestrictionAppliesTo(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:4,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> none;
1 -> equippedTransit;
2 -> equippedTaxis;
3 -> equippedOther;
4 -> emissionCompliant;
5 -> equippedBicycle;
6 -> weightCompliant;
7 -> heightCompliant;
8 -> pedestrians;
9 -> slowMovingPersons;
10 -> wheelchairUsers;
11 -> visualDisabilities;
12 -> audioDisabilities;
13 -> otherUnknownDisabilities;
_ -> exit({error,{asn1,{decode_enumerated,V1@V3}}})
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

typeinfo('MapData') ->
  {sequence,'MapData',9,[{<<116,105,109,101,83,116,97,109,112>>,{'INTEGER',{0,527040}},'OPTIONAL'},{<<109,115,103,73,115,115,117,101,82,101,118,105,115,105,111,110>>,{'INTEGER',{0,127}},mandatory},{<<108,97,121,101,114,84,121,112,101>>,{'ENUMERATED_EXT',#{none => 0,mixedContent => 1,generalMapData => 2,intersectionData => 3,curveData => 4,roadwaySectionData => 5,parkingAreaData => 6,sharedLaneData => 7}},'OPTIONAL'},{<<108,97,121,101,114,73,68>>,{'INTEGER',{0,100}},'OPTIONAL'},{<<105,110,116,101,114,115,101,99,116,105,111,110,115>>,{typeinfo,{'MapData','IntersectionGeometryList'}},'OPTIONAL'},{<<114,111,97,100,83,101,103,109,101,110,116,115>>,{typeinfo,{'MapData','RoadSegmentList'}},'OPTIONAL'},{<<100,97,116,97,80,97,114,97,109,101,116,101,114,115>>,{typeinfo,{'MapData','DataParameters'}},'OPTIONAL'},{<<114,101,115,116,114,105,99,116,105,111,110,76,105,115,116>>,{typeinfo,{'MapData','RestrictionClassList'}},'OPTIONAL'},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'MapData_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'MapData',internal_object_set_argument_7}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('ConnectingLane') ->
  {sequence,'ConnectingLane',2,[{<<108,97,110,101>>,{'INTEGER',{0,255}},mandatory},{<<109,97,110,101,117,118,101,114>>,{{bit_string_nnl,[{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]},12},'OPTIONAL'}]};
typeinfo('Connection') ->
  {sequence,'Connection',5,[{<<99,111,110,110,101,99,116,105,110,103,76,97,110,101>>,{typeinfo,{'MapData','ConnectingLane'}},mandatory},{<<114,101,109,111,116,101,73,110,116,101,114,115,101,99,116,105,111,110>>,{typeinfo,{'Common','IntersectionReferenceID'}},'OPTIONAL'},{<<115,105,103,110,97,108,71,114,111,117,112>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<117,115,101,114,67,108,97,115,115>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<99,111,110,110,101,99,116,105,111,110,73,68>>,{'INTEGER',{0,255}},'OPTIONAL'}]};
typeinfo('ConnectsToList') ->
  {sof,{typeinfo,{'MapData','Connection'}}};
typeinfo('DataParameters') ->
  {sequence,'DataParameters',4,[{<<112,114,111,99,101,115,115,77,101,116,104,111,100>>,string,'OPTIONAL'},{<<112,114,111,99,101,115,115,65,103,101,110,99,121>>,string,'OPTIONAL'},{<<108,97,115,116,67,104,101,99,107,101,100,68,97,116,101>>,string,'OPTIONAL'},{<<103,101,111,105,100,85,115,101,100>>,string,'OPTIONAL'}]};
typeinfo('GenericLane') ->
  {sequence,'GenericLane',10,[{<<108,97,110,101,73,68>>,{'INTEGER',{0,255}},mandatory},{<<110,97,109,101>>,string,'OPTIONAL'},{<<105,110,103,114,101,115,115,65,112,112,114,111,97,99,104>>,{'INTEGER',{0,15}},'OPTIONAL'},{<<101,103,114,101,115,115,65,112,112,114,111,97,99,104>>,{'INTEGER',{0,15}},'OPTIONAL'},{<<108,97,110,101,65,116,116,114,105,98,117,116,101,115>>,{typeinfo,{'MapData','LaneAttributes'}},mandatory},{<<109,97,110,101,117,118,101,114,115>>,{{bit_string_nnl,[{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]},12},'OPTIONAL'},{<<110,111,100,101,76,105,115,116>>,{typeinfo,{'Common','NodeListXY'}},mandatory},{<<99,111,110,110,101,99,116,115,84,111>>,{typeinfo,{'MapData','ConnectsToList'}},'OPTIONAL'},{<<111,118,101,114,108,97,121,115>>,{typeinfo,{'MapData','OverlayLaneList'}},'OPTIONAL'},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'GenericLane_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'MapData',internal_object_set_argument_2}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('IntersectionGeometry') ->
  {sequence,'IntersectionGeometry',10,[{<<110,97,109,101>>,string,'OPTIONAL'},{<<105,100>>,{typeinfo,{'Common','IntersectionReferenceID'}},mandatory},{<<114,101,118,105,115,105,111,110>>,{'INTEGER',{0,127}},mandatory},{<<114,101,102,80,111,105,110,116>>,{typeinfo,{'Common','Position3D'}},mandatory},{<<108,97,110,101,87,105,100,116,104>>,{'INTEGER',{0,32767}},'OPTIONAL'},{<<115,112,101,101,100,76,105,109,105,116,115>>,{typeinfo,{'Common','SpeedLimitList'}},'OPTIONAL'},{<<108,97,110,101,83,101,116>>,{typeinfo,{'MapData','LaneList'}},mandatory},{<<112,114,101,101,109,112,116,80,114,105,111,114,105,116,121,68,97,116,97>>,{typeinfo,{'MapData','PreemptPriorityList'}},'OPTIONAL'},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'IntersectionGeometry_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'MapData',internal_object_set_argument_4}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'},{<<114,111,97,100,65,117,116,104,111,114,105,116,121,73,68>>,{typeinfo,{'Common','RoadAuthorityID'}},'OPTIONAL'}]};
typeinfo('IntersectionGeometryList') ->
  {sof,{typeinfo,{'MapData','IntersectionGeometry'}}};
typeinfo('LaneAttributes') ->
  {sequence,'LaneAttributes',4,[{<<100,105,114,101,99,116,105,111,110,97,108,85,115,101>>,{{bit_string_nnl,[{ingressPath,0},{egressPath,1}]},2},mandatory},{<<115,104,97,114,101,100,87,105,116,104>>,{{bit_string_nnl,[{overlappingLaneDescriptionProvided,0},{multipleLanesTreatedAsOneLane,1},{otherNonMotorizedTrafficTypes,2},{individualMotorizedVehicleTraffic,3},{busVehicleTraffic,4},{taxiVehicleTraffic,5},{pedestriansTraffic,6},{cyclistVehicleTraffic,7},{trackedVehicleTraffic,8},{reserved,9}]},10},mandatory},{<<108,97,110,101,84,121,112,101>>,{typeinfo,{'MapData','LaneTypeAttributes'}},mandatory},{<<114,101,103,105,111,110,97,108>>,{sequence,'LaneAttributes_regional',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'MapData',internal_object_set_argument_1}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]},'OPTIONAL'}]};
typeinfo('LaneList') ->
  {sof,{typeinfo,{'MapData','GenericLane'}}};
typeinfo('LaneTypeAttributes') ->
  {choice,#{<<98,105,107,101,76,97,110,101>> => {{bit_string_nnl,[{bikeRevocableLane,0},{pedestrianUseAllowed,1},{isBikeFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{isolatedByBarrier,5},{unsignalizedSegmentsPresent,6}]},16},<<99,114,111,115,115,119,97,108,107>> => {{bit_string_nnl,[{crosswalkRevocableLane,0},{bicyleUseAllowed,1},{isXwalkFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{hasPushToWalkButton,5},{audioSupport,6},{rfSignalRequestPresent,7},{unsignalizedSegmentsPresent,8}]},16},<<109,101,100,105,97,110>> => {{bit_string_nnl,[{'median-RevocableLane',0},{median,1},{whiteLineHashing,2},{stripedLines,3},{doubleStripedLines,4},{trafficCones,5},{constructionBarrier,6},{trafficChannels,7},{lowCurbs,8},{highCurbs,9}]},16},<<112,97,114,107,105,110,103>> => {{bit_string_nnl,[{parkingRevocableLane,0},{parallelParkingInUse,1},{headInParkingInUse,2},{doNotParkZone,3},{parkingForBusUse,4},{parkingForTaxiUse,5},{noPublicParkingUse,6}]},16},<<115,105,100,101,119,97,108,107>> => {{bit_string_nnl,[{'sidewalk-RevocableLane',0},{bicyleUseAllowed,1},{isSidewalkFlyOverLane,2},{walkBikes,3}]},16},<<115,116,114,105,112,105,110,103>> => {{bit_string_nnl,[{stripeToConnectingLanesRevocableLane,0},{stripeDrawOnLeft,1},{stripeDrawOnRight,2},{stripeToConnectingLanesLeft,3},{stripeToConnectingLanesRight,4},{stripeToConnectingLanesAhead,5}]},16},<<116,114,97,99,107,101,100,86,101,104,105,99,108,101>> => {{bit_string_nnl,[{'spec-RevocableLane',0},{'spec-commuterRailRoadTrack',1},{'spec-lightRailRoadTrack',2},{'spec-heavyRailRoadTrack',3},{'spec-otherRailType',4}]},16},<<118,101,104,105,99,108,101>> => {bit_string_nnl,[{isVehicleRevocableLane,0},{isVehicleFlyOverLane,1},{hovLaneUseOnly,2},{restrictedToBusUse,3},{restrictedToTaxiUse,4},{restrictedFromPublicUse,5},{hasIRbeaconCoverage,6},{permissionOnRequest,7}]}}};
typeinfo('OverlayLaneList') ->
  {sof,{'INTEGER',{0,255}}};
typeinfo('PreemptPriorityList') ->
  {sof,{typeinfo,{'MapData','SignalControlZone'}}};
typeinfo('SignalControlZone') ->
  {sequence,'SignalControlZone',1,[{<<122,111,110,101>>,{sequence,'SignalControlZone_zone',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'MapData',internal_object_set_argument_3}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]},mandatory}]};
typeinfo('RestrictionClassAssignment') ->
  {sequence,'RestrictionClassAssignment',2,[{<<105,100>>,{'INTEGER',{0,255}},mandatory},{<<117,115,101,114,115>>,{typeinfo,{'MapData','RestrictionUserTypeList'}},mandatory}]};
typeinfo('RestrictionClassList') ->
  {sof,{typeinfo,{'MapData','RestrictionClassAssignment'}}};
typeinfo('RestrictionUserTypeList') ->
  {sof,{typeinfo,{'MapData','RestrictionUserType'}}};
typeinfo('RestrictionUserType') ->
  {choice,#{<<98,97,115,105,99,84,121,112,101>> => {'ENUMERATED_EXT',#{none => 0,pedestrians => 8,equippedTransit => 1,equippedTaxis => 2,equippedOther => 3,emissionCompliant => 4,equippedBicycle => 5,weightCompliant => 6,heightCompliant => 7,slowMovingPersons => 9,wheelchairUsers => 10,visualDisabilities => 11,audioDisabilities => 12,otherUnknownDisabilities => 13}},<<114,101,103,105,111,110,97,108>> => {sof,{sequence,'RestrictionUserType_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'MapData',internal_object_set_argument_6}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}}}};
typeinfo('RoadLaneSetList') ->
  {sof,{typeinfo,{'MapData','GenericLane'}}};
typeinfo('RoadSegmentList') ->
  {sof,{typeinfo,{'MapData','RoadSegment'}}};
typeinfo('RoadSegment') ->
  {sequence,'RoadSegment',8,[{<<110,97,109,101>>,string,'OPTIONAL'},{<<105,100>>,{typeinfo,{'Common','RoadSegmentReferenceID'}},mandatory},{<<114,101,118,105,115,105,111,110>>,{'INTEGER',{0,127}},mandatory},{<<114,101,102,80,111,105,110,116>>,{typeinfo,{'Common','Position3D'}},mandatory},{<<108,97,110,101,87,105,100,116,104>>,{'INTEGER',{0,32767}},'OPTIONAL'},{<<115,112,101,101,100,76,105,109,105,116,115>>,{typeinfo,{'Common','SpeedLimitList'}},'OPTIONAL'},{<<114,111,97,100,76,97,110,101,83,101,116>>,{typeinfo,{'MapData','RoadLaneSetList'}},mandatory},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'RoadSegment_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,134,{'Externaltypereference',undefined,'MapData',internal_object_set_argument_5}},[{outermost,[{'Externalvaluereference',134,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('AllowedManeuvers') ->
  {{bit_string_nnl,[{maneuverStraightAllowed,0},{maneuverLeftAllowed,1},{maneuverRightAllowed,2},{maneuverUTurnAllowed,3},{maneuverLeftTurnOnRedAllowed,4},{maneuverRightTurnOnRedAllowed,5},{maneuverLaneChangeAllowed,6},{maneuverNoStoppingAllowed,7},{yieldAllwaysRequired,8},{goWithHalt,9},{caution,10},{reserved1,11}]},12};
typeinfo('LaneAttributes-Barrier') ->
  {{bit_string_nnl,[{'median-RevocableLane',0},{median,1},{whiteLineHashing,2},{stripedLines,3},{doubleStripedLines,4},{trafficCones,5},{constructionBarrier,6},{trafficChannels,7},{lowCurbs,8},{highCurbs,9}]},16};
typeinfo('LaneAttributes-Bike') ->
  {{bit_string_nnl,[{bikeRevocableLane,0},{pedestrianUseAllowed,1},{isBikeFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{isolatedByBarrier,5},{unsignalizedSegmentsPresent,6}]},16};
typeinfo('LaneAttributes-Crosswalk') ->
  {{bit_string_nnl,[{crosswalkRevocableLane,0},{bicyleUseAllowed,1},{isXwalkFlyOverLane,2},{fixedCycleTime,3},{biDirectionalCycleTimes,4},{hasPushToWalkButton,5},{audioSupport,6},{rfSignalRequestPresent,7},{unsignalizedSegmentsPresent,8}]},16};
typeinfo('LaneAttributes-Parking') ->
  {{bit_string_nnl,[{parkingRevocableLane,0},{parallelParkingInUse,1},{headInParkingInUse,2},{doNotParkZone,3},{parkingForBusUse,4},{parkingForTaxiUse,5},{noPublicParkingUse,6}]},16};
typeinfo('LaneAttributes-Sidewalk') ->
  {{bit_string_nnl,[{'sidewalk-RevocableLane',0},{bicyleUseAllowed,1},{isSidewalkFlyOverLane,2},{walkBikes,3}]},16};
typeinfo('LaneAttributes-Striping') ->
  {{bit_string_nnl,[{stripeToConnectingLanesRevocableLane,0},{stripeDrawOnLeft,1},{stripeDrawOnRight,2},{stripeToConnectingLanesLeft,3},{stripeToConnectingLanesRight,4},{stripeToConnectingLanesAhead,5}]},16};
typeinfo('LaneAttributes-TrackedVehicle') ->
  {{bit_string_nnl,[{'spec-RevocableLane',0},{'spec-commuterRailRoadTrack',1},{'spec-lightRailRoadTrack',2},{'spec-heavyRailRoadTrack',3},{'spec-otherRailType',4}]},16};
typeinfo('LaneAttributes-Vehicle') ->
  {bit_string_nnl,[{isVehicleRevocableLane,0},{isVehicleFlyOverLane,1},{hovLaneUseOnly,2},{restrictedToBusUse,3},{restrictedToTaxiUse,4},{restrictedFromPublicUse,5},{hasIRbeaconCoverage,6},{permissionOnRequest,7}]};
typeinfo('LaneDirection') ->
  {{bit_string_nnl,[{ingressPath,0},{egressPath,1}]},2};
typeinfo('LaneSharing') ->
  {{bit_string_nnl,[{overlappingLaneDescriptionProvided,0},{multipleLanesTreatedAsOneLane,1},{otherNonMotorizedTrafficTypes,2},{individualMotorizedVehicleTraffic,3},{busVehicleTraffic,4},{taxiVehicleTraffic,5},{pedestriansTraffic,6},{cyclistVehicleTraffic,7},{trackedVehicleTraffic,8},{reserved,9}]},10};
typeinfo('LayerID') ->
  {'INTEGER',{0,100}};
typeinfo('LayerType') ->
  {'ENUMERATED_EXT',#{none => 0,mixedContent => 1,generalMapData => 2,intersectionData => 3,curveData => 4,roadwaySectionData => 5,parkingAreaData => 6,sharedLaneData => 7}};
typeinfo('RestrictionAppliesTo') ->
  {'ENUMERATED_EXT',#{none => 0,pedestrians => 8,equippedTransit => 1,equippedTaxis => 2,equippedOther => 3,emissionCompliant => 4,equippedBicycle => 5,weightCompliant => 6,heightCompliant => 7,slowMovingPersons => 9,wheelchairUsers => 10,visualDisabilities => 11,audioDisabilities => 12,otherUnknownDisabilities => 13}};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

bit_string_name2pos_11([ingressPath | T]) ->
    [0 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([egressPath | T]) ->
    [1 | bit_string_name2pos_11(T)];
bit_string_name2pos_11([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_11(T)];
bit_string_name2pos_11([]) ->
    [];
bit_string_name2pos_11(_) ->
    throw(invalid).

bit_string_name2pos_12([overlappingLaneDescriptionProvided | T]) ->
    [0 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([multipleLanesTreatedAsOneLane | T]) ->
    [1 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([otherNonMotorizedTrafficTypes | T]) ->
    [2 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([individualMotorizedVehicleTraffic | T]) ->
    [3 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([busVehicleTraffic | T]) ->
    [4 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([taxiVehicleTraffic | T]) ->
    [5 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([pedestriansTraffic | T]) ->
    [6 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([cyclistVehicleTraffic | T]) ->
    [7 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([trackedVehicleTraffic | T]) ->
    [8 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([reserved | T]) ->
    [9 | bit_string_name2pos_12(T)];
bit_string_name2pos_12([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_12(T)];
bit_string_name2pos_12([]) ->
    [];
bit_string_name2pos_12(_) ->
    throw(invalid).

bit_string_name2pos_14([isVehicleRevocableLane | T]) ->
    [0 | bit_string_name2pos_14(T)];
bit_string_name2pos_14([isVehicleFlyOverLane | T]) ->
    [1 | bit_string_name2pos_14(T)];
bit_string_name2pos_14([hovLaneUseOnly | T]) ->
    [2 | bit_string_name2pos_14(T)];
bit_string_name2pos_14([restrictedToBusUse | T]) ->
    [3 | bit_string_name2pos_14(T)];
bit_string_name2pos_14([restrictedToTaxiUse | T]) ->
    [4 | bit_string_name2pos_14(T)];
bit_string_name2pos_14([restrictedFromPublicUse | T]) ->
    [5 | bit_string_name2pos_14(T)];
bit_string_name2pos_14([hasIRbeaconCoverage | T]) ->
    [6 | bit_string_name2pos_14(T)];
bit_string_name2pos_14([permissionOnRequest | T]) ->
    [7 | bit_string_name2pos_14(T)];
bit_string_name2pos_14([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_14(T)];
bit_string_name2pos_14([]) ->
    [];
bit_string_name2pos_14(_) ->
    throw(invalid).

bit_string_name2pos_15([crosswalkRevocableLane | T]) ->
    [0 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([bicyleUseAllowed | T]) ->
    [1 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([isXwalkFlyOverLane | T]) ->
    [2 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([fixedCycleTime | T]) ->
    [3 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([biDirectionalCycleTimes | T]) ->
    [4 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([hasPushToWalkButton | T]) ->
    [5 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([audioSupport | T]) ->
    [6 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([rfSignalRequestPresent | T]) ->
    [7 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([unsignalizedSegmentsPresent | T]) ->
    [8 | bit_string_name2pos_15(T)];
bit_string_name2pos_15([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_15(T)];
bit_string_name2pos_15([]) ->
    [];
bit_string_name2pos_15(_) ->
    throw(invalid).

bit_string_name2pos_16([bikeRevocableLane | T]) ->
    [0 | bit_string_name2pos_16(T)];
bit_string_name2pos_16([pedestrianUseAllowed | T]) ->
    [1 | bit_string_name2pos_16(T)];
bit_string_name2pos_16([isBikeFlyOverLane | T]) ->
    [2 | bit_string_name2pos_16(T)];
bit_string_name2pos_16([fixedCycleTime | T]) ->
    [3 | bit_string_name2pos_16(T)];
bit_string_name2pos_16([biDirectionalCycleTimes | T]) ->
    [4 | bit_string_name2pos_16(T)];
bit_string_name2pos_16([isolatedByBarrier | T]) ->
    [5 | bit_string_name2pos_16(T)];
bit_string_name2pos_16([unsignalizedSegmentsPresent | T]) ->
    [6 | bit_string_name2pos_16(T)];
bit_string_name2pos_16([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_16(T)];
bit_string_name2pos_16([]) ->
    [];
bit_string_name2pos_16(_) ->
    throw(invalid).

bit_string_name2pos_17(['sidewalk-RevocableLane' | T]) ->
    [0 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([bicyleUseAllowed | T]) ->
    [1 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([isSidewalkFlyOverLane | T]) ->
    [2 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([walkBikes | T]) ->
    [3 | bit_string_name2pos_17(T)];
bit_string_name2pos_17([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_17(T)];
bit_string_name2pos_17([]) ->
    [];
bit_string_name2pos_17(_) ->
    throw(invalid).

bit_string_name2pos_18(['median-RevocableLane' | T]) ->
    [0 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([median | T]) ->
    [1 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([whiteLineHashing | T]) ->
    [2 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([stripedLines | T]) ->
    [3 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([doubleStripedLines | T]) ->
    [4 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([trafficCones | T]) ->
    [5 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([constructionBarrier | T]) ->
    [6 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([trafficChannels | T]) ->
    [7 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([lowCurbs | T]) ->
    [8 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([highCurbs | T]) ->
    [9 | bit_string_name2pos_18(T)];
bit_string_name2pos_18([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_18(T)];
bit_string_name2pos_18([]) ->
    [];
bit_string_name2pos_18(_) ->
    throw(invalid).

bit_string_name2pos_19([stripeToConnectingLanesRevocableLane | T]) ->
    [0 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([stripeDrawOnLeft | T]) ->
    [1 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([stripeDrawOnRight | T]) ->
    [2 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([stripeToConnectingLanesLeft | T]) ->
    [3 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([stripeToConnectingLanesRight | T]) ->
    [4 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([stripeToConnectingLanesAhead | T]) ->
    [5 | bit_string_name2pos_19(T)];
bit_string_name2pos_19([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_19(T)];
bit_string_name2pos_19([]) ->
    [];
bit_string_name2pos_19(_) ->
    throw(invalid).

bit_string_name2pos_20(['spec-RevocableLane' | T]) ->
    [0 | bit_string_name2pos_20(T)];
bit_string_name2pos_20(['spec-commuterRailRoadTrack' | T]) ->
    [1 | bit_string_name2pos_20(T)];
bit_string_name2pos_20(['spec-lightRailRoadTrack' | T]) ->
    [2 | bit_string_name2pos_20(T)];
bit_string_name2pos_20(['spec-heavyRailRoadTrack' | T]) ->
    [3 | bit_string_name2pos_20(T)];
bit_string_name2pos_20(['spec-otherRailType' | T]) ->
    [4 | bit_string_name2pos_20(T)];
bit_string_name2pos_20([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_20(T)];
bit_string_name2pos_20([]) ->
    [];
bit_string_name2pos_20(_) ->
    throw(invalid).

bit_string_name2pos_21([parkingRevocableLane | T]) ->
    [0 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([parallelParkingInUse | T]) ->
    [1 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([headInParkingInUse | T]) ->
    [2 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([doNotParkZone | T]) ->
    [3 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([parkingForBusUse | T]) ->
    [4 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([parkingForTaxiUse | T]) ->
    [5 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([noPublicParkingUse | T]) ->
    [6 | bit_string_name2pos_21(T)];
bit_string_name2pos_21([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_21(T)];
bit_string_name2pos_21([]) ->
    [];
bit_string_name2pos_21(_) ->
    throw(invalid).

bit_string_name2pos_4([maneuverStraightAllowed | T]) ->
    [0 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([maneuverLeftAllowed | T]) ->
    [1 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([maneuverRightAllowed | T]) ->
    [2 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([maneuverUTurnAllowed | T]) ->
    [3 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([maneuverLeftTurnOnRedAllowed | T]) ->
    [4 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([maneuverRightTurnOnRedAllowed | T]) ->
    [5 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([maneuverLaneChangeAllowed | T]) ->
    [6 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([maneuverNoStoppingAllowed | T]) ->
    [7 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([yieldAllwaysRequired | T]) ->
    [8 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([goWithHalt | T]) ->
    [9 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([caution | T]) ->
    [10 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([reserved1 | T]) ->
    [11 | bit_string_name2pos_4(T)];
bit_string_name2pos_4([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_4(T)];
bit_string_name2pos_4([]) ->
    [];
bit_string_name2pos_4(_) ->
    throw(invalid).

dec_components10(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components10(Num, Bytes, Acc) ->
{Term,Remain} = dec_IntersectionGeometry(Bytes),
dec_components10(Num-1, Remain, [Term|Acc]).

dec_components13(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components13(Num, Bytes, Acc) ->
{Term,Remain} = dec_GenericLane(Bytes),
dec_components13(Num-1, Remain, [Term|Acc]).

dec_components2(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components2(Num, Bytes, Acc) ->
{Term,Remain} = dec_MapData_regional_RegionalExtension(Bytes),
dec_components2(Num-1, Remain, [Term|Acc]).

dec_components22(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components22(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
dec_components22(Num-1, Remain, [Term|Acc]).

dec_components23(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components23(Num, Bytes, Acc) ->
{Term,Remain} = dec_SignalControlZone(Bytes),
dec_components23(Num-1, Remain, [Term|Acc]).

dec_components24(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components24(Num, Bytes, Acc) ->
{Term,Remain} = dec_RestrictionClassAssignment(Bytes),
dec_components24(Num-1, Remain, [Term|Acc]).

dec_components25(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components25(Num, Bytes, Acc) ->
{Term,Remain} = dec_RestrictionUserType(Bytes),
dec_components25(Num-1, Remain, [Term|Acc]).

dec_components27(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components27(Num, Bytes, Acc) ->
{Term,Remain} = dec_RestrictionUserType_regional_RegionalExtension(Bytes),
dec_components27(Num-1, Remain, [Term|Acc]).

dec_components29(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components29(Num, Bytes, Acc) ->
{Term,Remain} = dec_GenericLane(Bytes),
dec_components29(Num-1, Remain, [Term|Acc]).

dec_components30(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components30(Num, Bytes, Acc) ->
{Term,Remain} = dec_RoadSegment(Bytes),
dec_components30(Num-1, Remain, [Term|Acc]).

dec_components31(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components31(Num, Bytes, Acc) ->
{Term,Remain} = dec_RoadSegment_regional_RegionalExtension(Bytes),
dec_components31(Num-1, Remain, [Term|Acc]).

dec_components5(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components5(Num, Bytes, Acc) ->
{Term,Remain} = dec_Connection(Bytes),
dec_components5(Num-1, Remain, [Term|Acc]).

dec_components7(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components7(Num, Bytes, Acc) ->
{Term,Remain} = dec_GenericLane_regional_RegionalExtension(Bytes),
dec_components7(Num-1, Remain, [Term|Acc]).

dec_components9(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components9(Num, Bytes, Acc) ->
{Term,Remain} = dec_IntersectionGeometry_regional_RegionalExtension(Bytes),
dec_components9(Num-1, Remain, [Term|Acc]).

dec_os_Type28(Bytes, Id) when Id =:= 3 ->
{Term,_} = 'AddGrpC':'dec_RestrictionUserType-addGrpC'(Bytes),
Term;
dec_os_Type28(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type3(Bytes, Id) when Id =:= 3 ->
{Term,_} = 'AddGrpC':'dec_MapData-addGrpC'(Bytes),
Term;
dec_os_Type3(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type8(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


enc_os_Type1(Val, Id) ->
if Id =:= 3 ->
'AddGrpC':'enc_MapData-addGrpC'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type26(Val, Id) ->
if Id =:= 3 ->
'AddGrpC':'enc_RestrictionUserType-addGrpC'(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type6(Val, Id) ->
open_type_to_binary(Val).

adjust_trailing_zeroes(Bs0, Lb) ->
    case bit_size(Bs0) of
        Sz when Sz < Lb ->
            <<Bs0:Sz/bits,0:(Lb - Sz)>>;
        Lb ->
            Bs0;
        _ ->
            <<_:Lb/bits,Tail/bits>> = Bs0,
            Sz = Lb + bit_size(bs_drop_trailing_zeroes(Tail)),
            <<Bs:Sz/bits,_/bits>> = Bs0,
            Bs
    end.

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

bitstring_from_positions(L0, Lb) ->
    L1 = lists:sort(L0),
    L = diff(L1, -1, Lb - 1),
    << 
      <<B:(N + 0)>> ||
          {B, N} <- L
    >>.

bs_drop_trailing_zeroes(Bs) ->
    bs_drop_trailing_zeroes(Bs, bit_size(Bs)).

bs_drop_trailing_zeroes(Bs, 0) ->
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) when Sz0 < 8 ->
    <<Byte:Sz0>> = Bs0,
    Sz = Sz0 - ntz(Byte),
    <<Bs:Sz/bits,_/bits>> = Bs0,
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) ->
    Sz1 = Sz0 - 8,
    <<Bs1:Sz1/bits,Byte:8>> = Bs0,
    case ntz(Byte) of
        8 ->
            bs_drop_trailing_zeroes(Bs1, Sz1);
        Ntz ->
            Sz = Sz0 - Ntz,
            <<Bs:Sz/bits,_:Ntz/bits>> = Bs0,
            Bs
    end.

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_chars(Val, N) ->
    [ 
     C ||
         <<C:N>> <= Val
    ].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

decode_named_bit_string(Val, NNL) ->
    Bits =
        [ 
         B ||
             <<B:1>> <= Val
        ],
    decode_named_bit_string_1(0, Bits, NNL, []).

decode_named_bit_string_1(Pos, [0 | Bt], Names, Acc) ->
    decode_named_bit_string_1(Pos + 1, Bt, Names, Acc);
decode_named_bit_string_1(Pos, [1 | Bt], Names, Acc) ->
    case lists:keyfind(Pos, 2, Names) of
        {Name, _} ->
            decode_named_bit_string_1(Pos + 1, Bt, Names, [Name | Acc]);
        false ->
            decode_named_bit_string_1(Pos + 1,
                                      Bt, Names,
                                      [{bit, Pos} | Acc])
    end;
decode_named_bit_string_1(_Pos, [], _Names, Acc) ->
    lists:reverse(Acc).

diff([H | T], Prev, Last) ->
    [{1, H - Prev} | diff(T, H, Last)];
diff([], Prev, Last) when Last >= Prev ->
    [{0, Last - Prev}];
diff([], _, _) ->
    [].

encode_chars(Val, NumBits) ->
    << 
      <<C:NumBits>> ||
          C <- Val
    >>.

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

extension_bitmap(Val, Pos, Limit) ->
    extension_bitmap(Val, Pos, Limit, 0).

extension_bitmap(_Val, Pos, Limit, Acc) when Pos >= Limit ->
    Acc;
extension_bitmap(Val, Pos, Limit, Acc) ->
    Bit =
        case element(Pos, Val) of
            asn1_NOVALUE ->
                0;
            asn1_DEFAULT ->
                0;
            _ ->
                1
        end,
    extension_bitmap(Val, Pos + 1, Limit, Acc bsl 1 bor Bit).

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

ntz(Byte) ->
    T = {8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2,
         0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0,
         1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1,
         0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
         2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3,
         0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
         1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1,
         0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
         3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
         0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0,
         1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1,
         0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
         2, 0, 1, 0},
    element(Byte + 1, T).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

open_type_to_binary({asn1_OPENTYPE, Bin}) when is_binary(Bin) ->
    Bin.

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
