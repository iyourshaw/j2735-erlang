%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in EfcDataDictionary.

-module('EfcDataDictionary').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("EfcDataDictionary.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'EfcDataDictionary'},
            {options,[{i,"./erl"},uper,jer,verbose,{i,"./asn"},{outdir,"./erl"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_Int1Unsigned/1,
enc_Int1Signed/1,
enc_Int2Unsigned/1,
enc_Int2Signed/1,
enc_Int3Unsigned/1,
enc_Int4Unsigned/1,
enc_Int4Signed/1,
enc_Int8Unsigned/1,
enc_Int8Signed/1,
enc_AccountStatus/1,
enc_ActualNumberOfPassengers/1,
enc_Altitude/1,
enc_CO2EmissionValue/1,
enc_ContractAuthenticator/1,
enc_ContractSerialNumber/1,
enc_CopValue/1,
enc_CountryCode/1,
enc_DescriptiveCharacteristics/1,
enc_DetectionMode/1,
enc_EmissionUnit/1,
enc_EngineCharacteristics/1,
enc_EquipmentIccId/1,
enc_EquipmentObuId/1,
enc_EquipmentStatus/1,
enc_EuroValue/1,
enc_FutureCharacteristics/1,
enc_IssuerIdentifier/1,
enc_Latitude/1,
enc_DistanceUnit/1,
enc_LocalVehicleClassId/1,
enc_LocationClassId/1,
enc_Longitude/1,
enc_PaymentSecurityData/1,
enc_PayUnit/1,
enc_PersonalAccountNumber/1,
enc_ReceiptAuthenticator/1,
enc_ReceiptDistance/1,
enc_ResultFin/1,
enc_ReceiptIccId/1,
enc_ReceiptObuId/1,
enc_ResultOp/1,
enc_ReceiptServiceSerialNumber/1,
enc_ReceiptText/1,
enc_StationType/1,
enc_TariffClassId/1,
enc_Time/1,
enc_TimeClassId/1,
enc_TimeUnit/1,
enc_TrailerType/1,
enc_TyreConfiguration/1,
enc_UserClassId/1,
enc_VehicleAuthenticator/1,
enc_VehicleClass/1,
enc_VehicleCurrentMaxTrainWeight/1,
enc_VehicleTotalDistance/1,
enc_VehicleWeightLaden/1,
enc_Weekday/1,
enc_AbsolutePosition2d/1,
enc_AbsolutePosition3d/1,
enc_AxleWeightLimit/1,
enc_AxleWeightLimits/1,
enc_DateCompact/1,
enc_DieselEmissionValues/1,
enc_DriverCharacteristics/1,
enc_Distance/1,
enc_Duration/1,
enc_EngineDetails/1,
enc_ExhaustEmissionValues/1,
enc_NumberOfAxles/1,
enc_ObeId/1,
enc_Particulate/1,
enc_PassengerCapacity/1,
enc_PaymentFee/1,
enc_Period/1,
enc_Provider/1,
enc_RelativePosition3d/1,
enc_SessionClass/1,
enc_SessionLocation/1,
enc_SignedValue/1,
enc_SoundLevel/1,
enc_TimeCompact/1,
enc_TrailerDetails/1,
enc_AxlesWeightLimits/1,
enc_ChargeObjectId/1,
enc_ContractValidity/1,
enc_DateAndTime/1,
enc_EnvironmentalCharacteristics/1,
enc_Lpn/1,
enc_PaymentMeans/1,
enc_PaymentMeansBalance/1,
enc_Point/1,
enc_PurseBalance/1,
enc_TrailerCharacteristics/1,
enc_ValidityOfContract/1,
enc_VehicleAxlesNumber/1,
enc_VehicleDimensions/1,
enc_VehicleWeightLimits/1,
enc_EfcContextMark/1,
enc_ReceiptContract/1,
enc_ReceiptData/1,
enc_ReceiptFinancialPart/1,
enc_ReceiptServicePart/1,
enc_UserId/1,
enc_VehicleAxles/1,
enc_VehicleSpecificCharacteristics/1,
enc_AggregatedSingleTariffClassSession/1,
enc_DetectedChargeObject/1,
enc_TariffClassDescription/1,
enc_VehicleDescription/1
]).

-export([
dec_Int1Unsigned/1,
dec_Int1Signed/1,
dec_Int2Unsigned/1,
dec_Int2Signed/1,
dec_Int3Unsigned/1,
dec_Int4Unsigned/1,
dec_Int4Signed/1,
dec_Int8Unsigned/1,
dec_Int8Signed/1,
dec_AccountStatus/1,
dec_ActualNumberOfPassengers/1,
dec_Altitude/1,
dec_CO2EmissionValue/1,
dec_ContractAuthenticator/1,
dec_ContractSerialNumber/1,
dec_CopValue/1,
dec_CountryCode/1,
dec_DescriptiveCharacteristics/1,
dec_DetectionMode/1,
dec_EmissionUnit/1,
dec_EngineCharacteristics/1,
dec_EquipmentIccId/1,
dec_EquipmentObuId/1,
dec_EquipmentStatus/1,
dec_EuroValue/1,
dec_FutureCharacteristics/1,
dec_IssuerIdentifier/1,
dec_Latitude/1,
dec_DistanceUnit/1,
dec_LocalVehicleClassId/1,
dec_LocationClassId/1,
dec_Longitude/1,
dec_PaymentSecurityData/1,
dec_PayUnit/1,
dec_PersonalAccountNumber/1,
dec_ReceiptAuthenticator/1,
dec_ReceiptDistance/1,
dec_ResultFin/1,
dec_ReceiptIccId/1,
dec_ReceiptObuId/1,
dec_ResultOp/1,
dec_ReceiptServiceSerialNumber/1,
dec_ReceiptText/1,
dec_StationType/1,
dec_TariffClassId/1,
dec_Time/1,
dec_TimeClassId/1,
dec_TimeUnit/1,
dec_TrailerType/1,
dec_TyreConfiguration/1,
dec_UserClassId/1,
dec_VehicleAuthenticator/1,
dec_VehicleClass/1,
dec_VehicleCurrentMaxTrainWeight/1,
dec_VehicleTotalDistance/1,
dec_VehicleWeightLaden/1,
dec_Weekday/1,
dec_AbsolutePosition2d/1,
dec_AbsolutePosition3d/1,
dec_AxleWeightLimit/1,
dec_AxleWeightLimits/1,
dec_DateCompact/1,
dec_DieselEmissionValues/1,
dec_DriverCharacteristics/1,
dec_Distance/1,
dec_Duration/1,
dec_EngineDetails/1,
dec_ExhaustEmissionValues/1,
dec_NumberOfAxles/1,
dec_ObeId/1,
dec_Particulate/1,
dec_PassengerCapacity/1,
dec_PaymentFee/1,
dec_Period/1,
dec_Provider/1,
dec_RelativePosition3d/1,
dec_SessionClass/1,
dec_SessionLocation/1,
dec_SignedValue/1,
dec_SoundLevel/1,
dec_TimeCompact/1,
dec_TrailerDetails/1,
dec_AxlesWeightLimits/1,
dec_ChargeObjectId/1,
dec_ContractValidity/1,
dec_DateAndTime/1,
dec_EnvironmentalCharacteristics/1,
dec_Lpn/1,
dec_PaymentMeans/1,
dec_PaymentMeansBalance/1,
dec_Point/1,
dec_PurseBalance/1,
dec_TrailerCharacteristics/1,
dec_ValidityOfContract/1,
dec_VehicleAxlesNumber/1,
dec_VehicleDimensions/1,
dec_VehicleWeightLimits/1,
dec_EfcContextMark/1,
dec_ReceiptContract/1,
dec_ReceiptData/1,
dec_ReceiptFinancialPart/1,
dec_ReceiptServicePart/1,
dec_UserId/1,
dec_VehicleAxles/1,
dec_VehicleSpecificCharacteristics/1,
dec_AggregatedSingleTariffClassSession/1,
dec_DetectedChargeObject/1,
dec_TariffClassDescription/1,
dec_VehicleDescription/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('EfcDataDictionary', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('EfcDataDictionary', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('Int1Unsigned', Data) -> enc_Int1Unsigned(Data);
encode_disp('Int1Signed', Data) -> enc_Int1Signed(Data);
encode_disp('Int2Unsigned', Data) -> enc_Int2Unsigned(Data);
encode_disp('Int2Signed', Data) -> enc_Int2Signed(Data);
encode_disp('Int3Unsigned', Data) -> enc_Int3Unsigned(Data);
encode_disp('Int4Unsigned', Data) -> enc_Int4Unsigned(Data);
encode_disp('Int4Signed', Data) -> enc_Int4Signed(Data);
encode_disp('Int8Unsigned', Data) -> enc_Int8Unsigned(Data);
encode_disp('Int8Signed', Data) -> enc_Int8Signed(Data);
encode_disp('AccountStatus', Data) -> enc_AccountStatus(Data);
encode_disp('ActualNumberOfPassengers', Data) -> enc_ActualNumberOfPassengers(Data);
encode_disp('Altitude', Data) -> enc_Altitude(Data);
encode_disp('CO2EmissionValue', Data) -> enc_CO2EmissionValue(Data);
encode_disp('ContractAuthenticator', Data) -> enc_ContractAuthenticator(Data);
encode_disp('ContractSerialNumber', Data) -> enc_ContractSerialNumber(Data);
encode_disp('CopValue', Data) -> enc_CopValue(Data);
encode_disp('CountryCode', Data) -> enc_CountryCode(Data);
encode_disp('DescriptiveCharacteristics', Data) -> enc_DescriptiveCharacteristics(Data);
encode_disp('DetectionMode', Data) -> enc_DetectionMode(Data);
encode_disp('EmissionUnit', Data) -> enc_EmissionUnit(Data);
encode_disp('EngineCharacteristics', Data) -> enc_EngineCharacteristics(Data);
encode_disp('EquipmentIccId', Data) -> enc_EquipmentIccId(Data);
encode_disp('EquipmentObuId', Data) -> enc_EquipmentObuId(Data);
encode_disp('EquipmentStatus', Data) -> enc_EquipmentStatus(Data);
encode_disp('EuroValue', Data) -> enc_EuroValue(Data);
encode_disp('FutureCharacteristics', Data) -> enc_FutureCharacteristics(Data);
encode_disp('IssuerIdentifier', Data) -> enc_IssuerIdentifier(Data);
encode_disp('Latitude', Data) -> enc_Latitude(Data);
encode_disp('DistanceUnit', Data) -> enc_DistanceUnit(Data);
encode_disp('LocalVehicleClassId', Data) -> enc_LocalVehicleClassId(Data);
encode_disp('LocationClassId', Data) -> enc_LocationClassId(Data);
encode_disp('Longitude', Data) -> enc_Longitude(Data);
encode_disp('PaymentSecurityData', Data) -> enc_PaymentSecurityData(Data);
encode_disp('PayUnit', Data) -> enc_PayUnit(Data);
encode_disp('PersonalAccountNumber', Data) -> enc_PersonalAccountNumber(Data);
encode_disp('ReceiptAuthenticator', Data) -> enc_ReceiptAuthenticator(Data);
encode_disp('ReceiptDistance', Data) -> enc_ReceiptDistance(Data);
encode_disp('ResultFin', Data) -> enc_ResultFin(Data);
encode_disp('ReceiptIccId', Data) -> enc_ReceiptIccId(Data);
encode_disp('ReceiptObuId', Data) -> enc_ReceiptObuId(Data);
encode_disp('ResultOp', Data) -> enc_ResultOp(Data);
encode_disp('ReceiptServiceSerialNumber', Data) -> enc_ReceiptServiceSerialNumber(Data);
encode_disp('ReceiptText', Data) -> enc_ReceiptText(Data);
encode_disp('StationType', Data) -> enc_StationType(Data);
encode_disp('TariffClassId', Data) -> enc_TariffClassId(Data);
encode_disp('Time', Data) -> enc_Time(Data);
encode_disp('TimeClassId', Data) -> enc_TimeClassId(Data);
encode_disp('TimeUnit', Data) -> enc_TimeUnit(Data);
encode_disp('TrailerType', Data) -> enc_TrailerType(Data);
encode_disp('TyreConfiguration', Data) -> enc_TyreConfiguration(Data);
encode_disp('UserClassId', Data) -> enc_UserClassId(Data);
encode_disp('VehicleAuthenticator', Data) -> enc_VehicleAuthenticator(Data);
encode_disp('VehicleClass', Data) -> enc_VehicleClass(Data);
encode_disp('VehicleCurrentMaxTrainWeight', Data) -> enc_VehicleCurrentMaxTrainWeight(Data);
encode_disp('VehicleTotalDistance', Data) -> enc_VehicleTotalDistance(Data);
encode_disp('VehicleWeightLaden', Data) -> enc_VehicleWeightLaden(Data);
encode_disp('Weekday', Data) -> enc_Weekday(Data);
encode_disp('AbsolutePosition2d', Data) -> enc_AbsolutePosition2d(Data);
encode_disp('AbsolutePosition3d', Data) -> enc_AbsolutePosition3d(Data);
encode_disp('AxleWeightLimit', Data) -> enc_AxleWeightLimit(Data);
encode_disp('AxleWeightLimits', Data) -> enc_AxleWeightLimits(Data);
encode_disp('DateCompact', Data) -> enc_DateCompact(Data);
encode_disp('DieselEmissionValues', Data) -> enc_DieselEmissionValues(Data);
encode_disp('DriverCharacteristics', Data) -> enc_DriverCharacteristics(Data);
encode_disp('Distance', Data) -> enc_Distance(Data);
encode_disp('Duration', Data) -> enc_Duration(Data);
encode_disp('EngineDetails', Data) -> enc_EngineDetails(Data);
encode_disp('ExhaustEmissionValues', Data) -> enc_ExhaustEmissionValues(Data);
encode_disp('NumberOfAxles', Data) -> enc_NumberOfAxles(Data);
encode_disp('ObeId', Data) -> enc_ObeId(Data);
encode_disp('Particulate', Data) -> enc_Particulate(Data);
encode_disp('PassengerCapacity', Data) -> enc_PassengerCapacity(Data);
encode_disp('PaymentFee', Data) -> enc_PaymentFee(Data);
encode_disp('Period', Data) -> enc_Period(Data);
encode_disp('Provider', Data) -> enc_Provider(Data);
encode_disp('RelativePosition3d', Data) -> enc_RelativePosition3d(Data);
encode_disp('SessionClass', Data) -> enc_SessionClass(Data);
encode_disp('SessionLocation', Data) -> enc_SessionLocation(Data);
encode_disp('SignedValue', Data) -> enc_SignedValue(Data);
encode_disp('SoundLevel', Data) -> enc_SoundLevel(Data);
encode_disp('TimeCompact', Data) -> enc_TimeCompact(Data);
encode_disp('TrailerDetails', Data) -> enc_TrailerDetails(Data);
encode_disp('AxlesWeightLimits', Data) -> enc_AxlesWeightLimits(Data);
encode_disp('ChargeObjectId', Data) -> enc_ChargeObjectId(Data);
encode_disp('ContractValidity', Data) -> enc_ContractValidity(Data);
encode_disp('DateAndTime', Data) -> enc_DateAndTime(Data);
encode_disp('EnvironmentalCharacteristics', Data) -> enc_EnvironmentalCharacteristics(Data);
encode_disp('Lpn', Data) -> enc_Lpn(Data);
encode_disp('PaymentMeans', Data) -> enc_PaymentMeans(Data);
encode_disp('PaymentMeansBalance', Data) -> enc_PaymentMeansBalance(Data);
encode_disp('Point', Data) -> enc_Point(Data);
encode_disp('PurseBalance', Data) -> enc_PurseBalance(Data);
encode_disp('TrailerCharacteristics', Data) -> enc_TrailerCharacteristics(Data);
encode_disp('ValidityOfContract', Data) -> enc_ValidityOfContract(Data);
encode_disp('VehicleAxlesNumber', Data) -> enc_VehicleAxlesNumber(Data);
encode_disp('VehicleDimensions', Data) -> enc_VehicleDimensions(Data);
encode_disp('VehicleWeightLimits', Data) -> enc_VehicleWeightLimits(Data);
encode_disp('EfcContextMark', Data) -> enc_EfcContextMark(Data);
encode_disp('ReceiptContract', Data) -> enc_ReceiptContract(Data);
encode_disp('ReceiptData', Data) -> enc_ReceiptData(Data);
encode_disp('ReceiptFinancialPart', Data) -> enc_ReceiptFinancialPart(Data);
encode_disp('ReceiptServicePart', Data) -> enc_ReceiptServicePart(Data);
encode_disp('UserId', Data) -> enc_UserId(Data);
encode_disp('VehicleAxles', Data) -> enc_VehicleAxles(Data);
encode_disp('VehicleSpecificCharacteristics', Data) -> enc_VehicleSpecificCharacteristics(Data);
encode_disp('AggregatedSingleTariffClassSession', Data) -> enc_AggregatedSingleTariffClassSession(Data);
encode_disp('DetectedChargeObject', Data) -> enc_DetectedChargeObject(Data);
encode_disp('TariffClassDescription', Data) -> enc_TariffClassDescription(Data);
encode_disp('VehicleDescription', Data) -> enc_VehicleDescription(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('Int1Unsigned', Data) -> dec_Int1Unsigned(Data);
decode_disp('Int1Signed', Data) -> dec_Int1Signed(Data);
decode_disp('Int2Unsigned', Data) -> dec_Int2Unsigned(Data);
decode_disp('Int2Signed', Data) -> dec_Int2Signed(Data);
decode_disp('Int3Unsigned', Data) -> dec_Int3Unsigned(Data);
decode_disp('Int4Unsigned', Data) -> dec_Int4Unsigned(Data);
decode_disp('Int4Signed', Data) -> dec_Int4Signed(Data);
decode_disp('Int8Unsigned', Data) -> dec_Int8Unsigned(Data);
decode_disp('Int8Signed', Data) -> dec_Int8Signed(Data);
decode_disp('AccountStatus', Data) -> dec_AccountStatus(Data);
decode_disp('ActualNumberOfPassengers', Data) -> dec_ActualNumberOfPassengers(Data);
decode_disp('Altitude', Data) -> dec_Altitude(Data);
decode_disp('CO2EmissionValue', Data) -> dec_CO2EmissionValue(Data);
decode_disp('ContractAuthenticator', Data) -> dec_ContractAuthenticator(Data);
decode_disp('ContractSerialNumber', Data) -> dec_ContractSerialNumber(Data);
decode_disp('CopValue', Data) -> dec_CopValue(Data);
decode_disp('CountryCode', Data) -> dec_CountryCode(Data);
decode_disp('DescriptiveCharacteristics', Data) -> dec_DescriptiveCharacteristics(Data);
decode_disp('DetectionMode', Data) -> dec_DetectionMode(Data);
decode_disp('EmissionUnit', Data) -> dec_EmissionUnit(Data);
decode_disp('EngineCharacteristics', Data) -> dec_EngineCharacteristics(Data);
decode_disp('EquipmentIccId', Data) -> dec_EquipmentIccId(Data);
decode_disp('EquipmentObuId', Data) -> dec_EquipmentObuId(Data);
decode_disp('EquipmentStatus', Data) -> dec_EquipmentStatus(Data);
decode_disp('EuroValue', Data) -> dec_EuroValue(Data);
decode_disp('FutureCharacteristics', Data) -> dec_FutureCharacteristics(Data);
decode_disp('IssuerIdentifier', Data) -> dec_IssuerIdentifier(Data);
decode_disp('Latitude', Data) -> dec_Latitude(Data);
decode_disp('DistanceUnit', Data) -> dec_DistanceUnit(Data);
decode_disp('LocalVehicleClassId', Data) -> dec_LocalVehicleClassId(Data);
decode_disp('LocationClassId', Data) -> dec_LocationClassId(Data);
decode_disp('Longitude', Data) -> dec_Longitude(Data);
decode_disp('PaymentSecurityData', Data) -> dec_PaymentSecurityData(Data);
decode_disp('PayUnit', Data) -> dec_PayUnit(Data);
decode_disp('PersonalAccountNumber', Data) -> dec_PersonalAccountNumber(Data);
decode_disp('ReceiptAuthenticator', Data) -> dec_ReceiptAuthenticator(Data);
decode_disp('ReceiptDistance', Data) -> dec_ReceiptDistance(Data);
decode_disp('ResultFin', Data) -> dec_ResultFin(Data);
decode_disp('ReceiptIccId', Data) -> dec_ReceiptIccId(Data);
decode_disp('ReceiptObuId', Data) -> dec_ReceiptObuId(Data);
decode_disp('ResultOp', Data) -> dec_ResultOp(Data);
decode_disp('ReceiptServiceSerialNumber', Data) -> dec_ReceiptServiceSerialNumber(Data);
decode_disp('ReceiptText', Data) -> dec_ReceiptText(Data);
decode_disp('StationType', Data) -> dec_StationType(Data);
decode_disp('TariffClassId', Data) -> dec_TariffClassId(Data);
decode_disp('Time', Data) -> dec_Time(Data);
decode_disp('TimeClassId', Data) -> dec_TimeClassId(Data);
decode_disp('TimeUnit', Data) -> dec_TimeUnit(Data);
decode_disp('TrailerType', Data) -> dec_TrailerType(Data);
decode_disp('TyreConfiguration', Data) -> dec_TyreConfiguration(Data);
decode_disp('UserClassId', Data) -> dec_UserClassId(Data);
decode_disp('VehicleAuthenticator', Data) -> dec_VehicleAuthenticator(Data);
decode_disp('VehicleClass', Data) -> dec_VehicleClass(Data);
decode_disp('VehicleCurrentMaxTrainWeight', Data) -> dec_VehicleCurrentMaxTrainWeight(Data);
decode_disp('VehicleTotalDistance', Data) -> dec_VehicleTotalDistance(Data);
decode_disp('VehicleWeightLaden', Data) -> dec_VehicleWeightLaden(Data);
decode_disp('Weekday', Data) -> dec_Weekday(Data);
decode_disp('AbsolutePosition2d', Data) -> dec_AbsolutePosition2d(Data);
decode_disp('AbsolutePosition3d', Data) -> dec_AbsolutePosition3d(Data);
decode_disp('AxleWeightLimit', Data) -> dec_AxleWeightLimit(Data);
decode_disp('AxleWeightLimits', Data) -> dec_AxleWeightLimits(Data);
decode_disp('DateCompact', Data) -> dec_DateCompact(Data);
decode_disp('DieselEmissionValues', Data) -> dec_DieselEmissionValues(Data);
decode_disp('DriverCharacteristics', Data) -> dec_DriverCharacteristics(Data);
decode_disp('Distance', Data) -> dec_Distance(Data);
decode_disp('Duration', Data) -> dec_Duration(Data);
decode_disp('EngineDetails', Data) -> dec_EngineDetails(Data);
decode_disp('ExhaustEmissionValues', Data) -> dec_ExhaustEmissionValues(Data);
decode_disp('NumberOfAxles', Data) -> dec_NumberOfAxles(Data);
decode_disp('ObeId', Data) -> dec_ObeId(Data);
decode_disp('Particulate', Data) -> dec_Particulate(Data);
decode_disp('PassengerCapacity', Data) -> dec_PassengerCapacity(Data);
decode_disp('PaymentFee', Data) -> dec_PaymentFee(Data);
decode_disp('Period', Data) -> dec_Period(Data);
decode_disp('Provider', Data) -> dec_Provider(Data);
decode_disp('RelativePosition3d', Data) -> dec_RelativePosition3d(Data);
decode_disp('SessionClass', Data) -> dec_SessionClass(Data);
decode_disp('SessionLocation', Data) -> dec_SessionLocation(Data);
decode_disp('SignedValue', Data) -> dec_SignedValue(Data);
decode_disp('SoundLevel', Data) -> dec_SoundLevel(Data);
decode_disp('TimeCompact', Data) -> dec_TimeCompact(Data);
decode_disp('TrailerDetails', Data) -> dec_TrailerDetails(Data);
decode_disp('AxlesWeightLimits', Data) -> dec_AxlesWeightLimits(Data);
decode_disp('ChargeObjectId', Data) -> dec_ChargeObjectId(Data);
decode_disp('ContractValidity', Data) -> dec_ContractValidity(Data);
decode_disp('DateAndTime', Data) -> dec_DateAndTime(Data);
decode_disp('EnvironmentalCharacteristics', Data) -> dec_EnvironmentalCharacteristics(Data);
decode_disp('Lpn', Data) -> dec_Lpn(Data);
decode_disp('PaymentMeans', Data) -> dec_PaymentMeans(Data);
decode_disp('PaymentMeansBalance', Data) -> dec_PaymentMeansBalance(Data);
decode_disp('Point', Data) -> dec_Point(Data);
decode_disp('PurseBalance', Data) -> dec_PurseBalance(Data);
decode_disp('TrailerCharacteristics', Data) -> dec_TrailerCharacteristics(Data);
decode_disp('ValidityOfContract', Data) -> dec_ValidityOfContract(Data);
decode_disp('VehicleAxlesNumber', Data) -> dec_VehicleAxlesNumber(Data);
decode_disp('VehicleDimensions', Data) -> dec_VehicleDimensions(Data);
decode_disp('VehicleWeightLimits', Data) -> dec_VehicleWeightLimits(Data);
decode_disp('EfcContextMark', Data) -> dec_EfcContextMark(Data);
decode_disp('ReceiptContract', Data) -> dec_ReceiptContract(Data);
decode_disp('ReceiptData', Data) -> dec_ReceiptData(Data);
decode_disp('ReceiptFinancialPart', Data) -> dec_ReceiptFinancialPart(Data);
decode_disp('ReceiptServicePart', Data) -> dec_ReceiptServicePart(Data);
decode_disp('UserId', Data) -> dec_UserId(Data);
decode_disp('VehicleAxles', Data) -> dec_VehicleAxles(Data);
decode_disp('VehicleSpecificCharacteristics', Data) -> dec_VehicleSpecificCharacteristics(Data);
decode_disp('AggregatedSingleTariffClassSession', Data) -> dec_AggregatedSingleTariffClassSession(Data);
decode_disp('DetectedChargeObject', Data) -> dec_DetectedChargeObject(Data);
decode_disp('TariffClassDescription', Data) -> dec_TariffClassDescription(Data);
decode_disp('VehicleDescription', Data) -> dec_VehicleDescription(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_Int1Unsigned(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int1Unsigned(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Int1Signed(Val) ->
Val@sub = Val - -128,
if Val@sub bsr 8 =:= 0 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int1Signed(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -128,
{V1@Add2,V1@Buf1}
end.

enc_Int2Unsigned(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int2Unsigned(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Int2Signed(Val) ->
Val@sub = Val - -32768,
if Val@sub bsr 16 =:= 0 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int2Signed(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end.

enc_Int3Unsigned(Val) ->
if Val bsr 24 =:= 0 ->
<<Val:24>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int3Unsigned(Bytes) ->
begin
<<V1@V0:24,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Int4Unsigned(Val) ->
if Val bsr 32 =:= 0 ->
<<Val:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int4Unsigned(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Int4Signed(Val) ->
Val@sub = Val - -2147483648,
if Val@sub bsr 32 =:= 0 ->
<<Val@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int4Signed(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2147483648,
{V1@Add2,V1@Buf1}
end.

enc_Int8Unsigned(Val) ->
if Val bsr 63 =:= 0 ->
<<Val:63>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int8Unsigned(Bytes) ->
begin
<<V1@V0:63,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Int8Signed(Val) ->
Val@sub = Val - -9223372036854775808,
if Val@sub bsr 64 =:= 0 ->
<<Val@sub:64>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Int8Signed(Bytes) ->
begin
<<V1@V0:64,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -9223372036854775808,
{V1@Add2,V1@Buf1}
end.

enc_AccountStatus(Val) ->
if Val =:= ok ->
[0];
Val =:= low ->
[1];
Val =:= empty ->
[2];
Val =:= negative ->
[3];
Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_AccountStatus(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> ok;
1 -> low;
2 -> empty;
3 -> negative;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_ActualNumberOfPassengers(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ActualNumberOfPassengers(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Altitude(Val) ->
Val@sub = Val - -32768,
if Val@sub bsr 16 =:= 0 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Altitude(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end.

enc_CO2EmissionValue(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_CO2EmissionValue(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ContractAuthenticator(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_ContractAuthenticator(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_ContractSerialNumber(Val) ->
if Val bsr 32 =:= 0 ->
<<Val:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ContractSerialNumber(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_CopValue(Val) ->
if Val =:= noEntry ->
<<0:4>>;
Val =:= co2class1 ->
<<1:4>>;
Val =:= co2class2 ->
<<2:4>>;
Val =:= co2class3 ->
<<3:4>>;
Val =:= co2class4 ->
<<4:4>>;
Val =:= co2class5 ->
<<5:4>>;
Val =:= co2class6 ->
<<6:4>>;
Val =:= co2class7 ->
<<7:4>>;
Val bsr 4 =:= 0 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_CopValue(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> noEntry;
1 -> co2class1;
2 -> co2class2;
3 -> co2class3;
4 -> co2class4;
5 -> co2class5;
6 -> co2class6;
7 -> co2class7;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_CountryCode(Val) ->
Enc1@bits = bit_size(Val),
if Enc1@bits =:= 10 ->
Val
end.


dec_CountryCode(Bytes) ->
begin
<<V1@V0:10/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {list_to_bitstring([V1@V0]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_DescriptiveCharacteristics(Val) ->
if Val =:= noEntry ->
[0];
Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DescriptiveCharacteristics(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> noEntry;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_DetectionMode(Val) ->
if Val =:= measured ->
[0];
Val =:= inferred ->
[1];
Val =:= lac ->
[2];
Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DetectionMode(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> measured;
1 -> inferred;
2 -> lac;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_EmissionUnit(Val) ->
if Val =:= mgPerKm ->
<<0:1>>;
Val =:= mgPerKwh ->
<<1:1>>;
Val bsr 1 =:= 0 ->
<<Val:1>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_EmissionUnit(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> mgPerKm;
1 -> mgPerKwh
end,
{V1@Int2,V1@Buf1}
end.

enc_EngineCharacteristics(Val) ->
if Val =:= noEntry ->
[0];
Val =:= noEngine ->
[1];
Val =:= petrolUnleaded ->
[2];
Val =:= petrolLeaded ->
[3];
Val =:= diesel ->
[4];
Val =:= lpg ->
[5];
Val =:= battery ->
[6];
Val =:= solar ->
[7];
Val =:= hybrid ->
[8];
Val =:= hydrogen ->
[9];
Val =:= multiFuel ->
[10];
Val =:= bivalentPetrolLpg ->
[11];
Val =:= bivalentPetrolCng ->
[12];
Val =:= combinedPetrolElectric ->
[13];
Val =:= cng ->
[14];
Val =:= lng ->
[15];
Val =:= combinedDieselElectric ->
[16];
Val =:= combinedHydrogenElectric ->
[17];
Val =:= bivalentHydrogenPetrol ->
[18];
Val =:= bivalentHydrogenPetrolElectricEngine ->
[19];
Val =:= fuelCellHydrogen ->
[20];
Val =:= fuelCellPetrol ->
[21];
Val =:= fuelCellMethanol ->
[22];
Val =:= fuelCellEthanol ->
[23];
Val =:= fuelCellDiesel ->
[24];
Val =:= combinedMultiFuelElectricEngine ->
[25];
Val =:= combinedCngElectricEngine ->
[26];
Val =:= combinedLngElectricEngine ->
[27];
Val =:= petrolEthanol ->
[28];
Val =:= combinedLpgElectricEngine ->
[29];
Val =:= hybridPetrolExternalBattery ->
[30];
Val =:= hybridDieselExternalBattery ->
[31];
Val =:= hybridLpgExternalBattery ->
[32];
Val =:= hybridHydrogenExternalBattery ->
[33];
Val =:= hybridMultiFuelExternalBattery ->
[34];
Val =:= hybridCngExternalBattery ->
[35];
Val =:= hybridLngExternalBattery ->
[36];
Val =:= hybridBivalentHydrogenPetrolExternalBattery ->
[37];
Val =:= hydrogenCng ->
[38];
Val =:= hydrogenLng ->
[39];
Val =:= hybridHydrogenCngExternalBattery ->
[40];
Val =:= hybridHydrogenLngExternalBattery ->
[41];
Val =:= ethanol ->
[42];
Val =:= hybridFuelCellHydrogen ->
[43];
Val =:= hybridFuelCellHydrogenExternalBattery ->
[44];
Val =:= dualFuelLngDiesel ->
[45];
Val =:= electricExternal ->
[46];
Val =:= biogas ->
[47];
Val =:= bioDiesel ->
[48];
Val =:= bioPetrol ->
[49];
Val =:= bivalentPetrolBiogas ->
[50];
Val =:= combinedBiogasElectricEngine ->
[51];
Val =:= dualFuelCngDiesel ->
[52];
Val =:= other ->
[255];
Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_EngineCharacteristics(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> noEntry;
1 -> noEngine;
2 -> petrolUnleaded;
3 -> petrolLeaded;
4 -> diesel;
5 -> lpg;
6 -> battery;
7 -> solar;
8 -> hybrid;
9 -> hydrogen;
10 -> multiFuel;
11 -> bivalentPetrolLpg;
12 -> bivalentPetrolCng;
13 -> combinedPetrolElectric;
14 -> cng;
15 -> lng;
16 -> combinedDieselElectric;
17 -> combinedHydrogenElectric;
18 -> bivalentHydrogenPetrol;
19 -> bivalentHydrogenPetrolElectricEngine;
20 -> fuelCellHydrogen;
21 -> fuelCellPetrol;
22 -> fuelCellMethanol;
23 -> fuelCellEthanol;
24 -> fuelCellDiesel;
25 -> combinedMultiFuelElectricEngine;
26 -> combinedCngElectricEngine;
27 -> combinedLngElectricEngine;
28 -> petrolEthanol;
29 -> combinedLpgElectricEngine;
30 -> hybridPetrolExternalBattery;
31 -> hybridDieselExternalBattery;
32 -> hybridLpgExternalBattery;
33 -> hybridHydrogenExternalBattery;
34 -> hybridMultiFuelExternalBattery;
35 -> hybridCngExternalBattery;
36 -> hybridLngExternalBattery;
37 -> hybridBivalentHydrogenPetrolExternalBattery;
38 -> hydrogenCng;
39 -> hydrogenLng;
40 -> hybridHydrogenCngExternalBattery;
41 -> hybridHydrogenLngExternalBattery;
42 -> ethanol;
43 -> hybridFuelCellHydrogen;
44 -> hybridFuelCellHydrogenExternalBattery;
45 -> dualFuelLngDiesel;
46 -> electricExternal;
47 -> biogas;
48 -> bioDiesel;
49 -> bioPetrol;
50 -> bivalentPetrolBiogas;
51 -> combinedBiogasElectricEngine;
52 -> dualFuelCngDiesel;
255 -> other;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_EquipmentIccId(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_EquipmentIccId(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_EquipmentObuId(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_EquipmentObuId(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_EquipmentStatus(Val) ->
Enc1@bits = bit_size(Val),
if Enc1@bits =:= 16 ->
Val
end.


dec_EquipmentStatus(Bytes) ->
begin
<<V1@V0:16/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {list_to_bitstring([V1@V0]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_EuroValue(Val) ->
if Val =:= noEntry ->
<<0:4>>;
Val =:= euro1 ->
<<1:4>>;
Val =:= euro2 ->
<<2:4>>;
Val =:= euro3 ->
<<3:4>>;
Val =:= euro4 ->
<<4:4>>;
Val =:= euro5 ->
<<5:4>>;
Val =:= euro6 ->
<<6:4>>;
Val =:= euro7 ->
<<7:4>>;
Val =:= eev ->
<<15:4>>;
Val bsr 4 =:= 0 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_EuroValue(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> noEntry;
1 -> euro1;
2 -> euro2;
3 -> euro3;
4 -> euro4;
5 -> euro5;
6 -> euro6;
7 -> euro7;
15 -> eev;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_FutureCharacteristics(Val) ->
if Val =:= noEntry ->
[0];
Val =:= airSuspension ->
[1];
Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_FutureCharacteristics(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> noEntry;
1 -> airSuspension;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_IssuerIdentifier(Val) ->
if Val bsr 14 =:= 0 ->
<<Val:14>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_IssuerIdentifier(Bytes) ->
begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Latitude(Val) ->
Val@sub = Val - -2147483648,
if Val@sub bsr 32 =:= 0 ->
<<Val@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Latitude(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2147483648,
{V1@Add2,V1@Buf1}
end.

enc_DistanceUnit(Val) ->
if Val =:= kilometres ->
[0];
Val =:= miles ->
[1];
Val =:= metres ->
[2];
Val =:= yards ->
[3];
Val =:= feet ->
[4];
Val =:= decimetres ->
[5];
Val =:= quartermetres ->
[6];
Val =:= centimeters ->
[7];
Val =:= millimeters ->
[8];
Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DistanceUnit(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> kilometres;
1 -> miles;
2 -> metres;
3 -> yards;
4 -> feet;
5 -> decimetres;
6 -> quartermetres;
7 -> centimeters;
8 -> millimeters;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_LocalVehicleClassId(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LocalVehicleClassId(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_LocationClassId(Val) ->
if Val bsr 32 =:= 0 ->
<<Val:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LocationClassId(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Longitude(Val) ->
Val@sub = Val - -2147483648,
if Val@sub bsr 32 =:= 0 ->
<<Val@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Longitude(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2147483648,
{V1@Add2,V1@Buf1}
end.

enc_PaymentSecurityData(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_PaymentSecurityData(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_PayUnit(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 2 ->
Val
end.


dec_PayUnit(Bytes) ->
begin
<<V1@V0:2/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_PersonalAccountNumber(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 10 ->
Val
end.


dec_PersonalAccountNumber(Bytes) ->
begin
<<V1@V0:10/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_ReceiptAuthenticator(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_ReceiptAuthenticator(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_ReceiptDistance(Val) ->
if Val bsr 24 =:= 0 ->
<<Val:24>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ReceiptDistance(Bytes) ->
begin
<<V1@V0:24,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ResultFin(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 1 ->
Val
end.


dec_ResultFin(Bytes) ->
begin
<<V1@V0:1/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_ReceiptIccId(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_ReceiptIccId(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_ReceiptObuId(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_ReceiptObuId(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_ResultOp(Val) ->
if Val =:= correctTransaction ->
[0];
Val =:= obeStatusNotAccepted ->
[1];
Val =:= equipmentStatusNotAccepted ->
[2];
Val =:= contractNotInWhiteList ->
[3];
Val =:= contractIdentifierInBlackList ->
[4];
Val =:= contractIdentifierNotCorrect ->
[5];
Val =:= expiredContract ->
[6];
Val =:= contractRestrictionsNotFulfilled ->
[7];
Val =:= claimedVehicleCharacteristicsNotValid ->
[8];
Val =:= vehicleClassAuthenticationFailed ->
[9];
Val =:= entryVehicleClassDifferentFromExitVehicleClass ->
[10];
Val =:= entryReceiptMissing ->
[11];
Val =:= entryReceiptNotValid ->
[12];
Val =:= entryTollStationNotValid ->
[13];
Val =:= equipmentNotCertified ->
[14];
Val =:= timeDifference ->
[15];
Val =:= accessCredentialsNotAccepted ->
[16];
Val =:= contractAuthenticatorNotAccepted ->
[17];
Val =:= receiptAuthenticatorNotAccepted ->
[18];
Val =:= claimedVehicleCharacteristicsMissing ->
[19];
Val =:= paymentMeansNotAccepted ->
[20];
Val =:= paymentAuthenticatorNotAccepted ->
[21];
Val =:= paymentMeansInBlackList ->
[22];
Val =:= paymentMeansNotCorrect ->
[23];
Val =:= expiredPaymentMeans ->
[24];
Val =:= paymentMeansRestrictionsNotFulfilled ->
[25];
Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ResultOp(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> correctTransaction;
1 -> obeStatusNotAccepted;
2 -> equipmentStatusNotAccepted;
3 -> contractNotInWhiteList;
4 -> contractIdentifierInBlackList;
5 -> contractIdentifierNotCorrect;
6 -> expiredContract;
7 -> contractRestrictionsNotFulfilled;
8 -> claimedVehicleCharacteristicsNotValid;
9 -> vehicleClassAuthenticationFailed;
10 -> entryVehicleClassDifferentFromExitVehicleClass;
11 -> entryReceiptMissing;
12 -> entryReceiptNotValid;
13 -> entryTollStationNotValid;
14 -> equipmentNotCertified;
15 -> timeDifference;
16 -> accessCredentialsNotAccepted;
17 -> contractAuthenticatorNotAccepted;
18 -> receiptAuthenticatorNotAccepted;
19 -> claimedVehicleCharacteristicsMissing;
20 -> paymentMeansNotAccepted;
21 -> paymentAuthenticatorNotAccepted;
22 -> paymentMeansInBlackList;
23 -> paymentMeansNotCorrect;
24 -> expiredPaymentMeans;
25 -> paymentMeansRestrictionsNotFulfilled;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_ReceiptServiceSerialNumber(Val) ->
if Val bsr 24 =:= 0 ->
<<Val:24>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ReceiptServiceSerialNumber(Bytes) ->
begin
<<V1@V0:24,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ReceiptText(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_ReceiptText(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_StationType(Val) ->
if Val =:= unspecified ->
<<0:4>>;
Val =:= closedEntryWithPayment ->
<<1:4>>;
Val =:= closedEntryWithoutPayment ->
<<2:4>>;
Val =:= closedTransit ->
<<3:4>>;
Val =:= closedExit ->
<<4:4>>;
Val =:= closedCredit ->
<<5:4>>;
Val =:= mixed ->
<<6:4>>;
Val =:= passage ->
<<7:4>>;
Val =:= checkpoint ->
<<8:4>>;
Val =:= reload ->
<<9:4>>;
Val =:= reservedForFutureCENUse1 ->
<<10:4>>;
Val =:= reservedForFutureCENUse2 ->
<<11:4>>;
Val =:= reservedForFutureCENUse3 ->
<<12:4>>;
Val =:= reservedForFutureCENUse4 ->
<<13:4>>;
Val =:= privateUse5 ->
<<14:4>>;
Val =:= privateUse6 ->
<<15:4>>;
Val bsr 4 =:= 0 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_StationType(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unspecified;
1 -> closedEntryWithPayment;
2 -> closedEntryWithoutPayment;
3 -> closedTransit;
4 -> closedExit;
5 -> closedCredit;
6 -> mixed;
7 -> passage;
8 -> checkpoint;
9 -> reload;
10 -> reservedForFutureCENUse1;
11 -> reservedForFutureCENUse2;
12 -> reservedForFutureCENUse3;
13 -> reservedForFutureCENUse4;
14 -> privateUse5;
15 -> privateUse6
end,
{V1@Int2,V1@Buf1}
end.

enc_TariffClassId(Val) ->
if Val bsr 32 =:= 0 ->
<<Val:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TariffClassId(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Time(Val) ->
if Val bsr 32 =:= 0 ->
<<Val:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Time(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TimeClassId(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TimeClassId(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TimeUnit(Val) ->
if Val =:= seconds ->
[0];
Val =:= minutes ->
[1];
Val =:= hours ->
[2];
Val =:= days ->
[3];
Val =:= months ->
[4];
Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TimeUnit(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> seconds;
1 -> minutes;
2 -> hours;
3 -> days;
4 -> months;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_TrailerType(Val) ->
if Val =:= notPresent ->
<<0:5>>;
Val =:= trailer ->
<<1:5>>;
Val =:= semitrailer ->
<<2:5>>;
Val bsr 5 =:= 0 ->
<<Val:5>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TrailerType(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> notPresent;
1 -> trailer;
2 -> semitrailer;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end.

enc_TyreConfiguration(Val) ->
if Val =:= notSpecified ->
<<0:2>>;
Val =:= singleTyre ->
<<1:2>>;
Val =:= dualTyres ->
<<2:2>>;
Val =:= reservedForUse ->
<<3:2>>;
Val bsr 2 =:= 0 ->
<<Val:2>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TyreConfiguration(Bytes) ->
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> notSpecified;
1 -> singleTyre;
2 -> dualTyres;
3 -> reservedForUse
end,
{V1@Int2,V1@Buf1}
end.

enc_UserClassId(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_UserClassId(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_VehicleAuthenticator(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len < 128 ->
[Enc1@len|Val];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|Val];
true ->
encode_fragmented(Val, 8)
end.


dec_VehicleAuthenticator(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:8,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:8,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 8),
{V1@V6,V1@Buf7}
end,
V1@Conv8 = binary:copy(V1@V0),
{V1@Conv8,V1@Buf1}
end.

enc_VehicleClass(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VehicleClass(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_VehicleCurrentMaxTrainWeight(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VehicleCurrentMaxTrainWeight(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_VehicleTotalDistance(Val) ->
if Val bsr 32 =:= 0 ->
<<Val:32>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VehicleTotalDistance(Bytes) ->
begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_VehicleWeightLaden(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_VehicleWeightLaden(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Weekday(Val) ->
if Val =:= reserved ->
<<0:3>>;
Val =:= monday ->
<<1:3>>;
Val =:= tuesday ->
<<2:3>>;
Val =:= wednesday ->
<<3:3>>;
Val =:= thursday ->
<<4:3>>;
Val =:= friday ->
<<5:3>>;
Val =:= saturday ->
<<6:3>>;
Val =:= sunday ->
<<7:3>>;
Val bsr 3 =:= 0 ->
<<Val:3>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Weekday(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> reserved;
1 -> monday;
2 -> tuesday;
3 -> wednesday;
4 -> thursday;
5 -> friday;
6 -> saturday;
7 -> sunday
end,
{V1@Int2,V1@Buf1}
end.

enc_AbsolutePosition2d(Val) ->
[begin
%% attribute gnssLon(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -2147483648,
if Enc1@element@sub bsr 32 =:= 0 ->
<<Enc1@element@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute gnssLat(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -2147483648,
if Enc3@element@sub bsr 32 =:= 0 ->
<<Enc3@element@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_AbsolutePosition2d(Bytes) ->

%% attribute gnssLon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:32,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -2147483648,
{V1@Add2,V1@Buf1}
end,

%% attribute gnssLat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2147483648,
{V2@Add2,V2@Buf1}
end,
Res1 = {'AbsolutePosition2d',Term1,Term2},
{Res1,Bytes2}.

enc_AbsolutePosition3d(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute longitude(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - -2147483648,
if Enc2@element@sub bsr 32 =:= 0 ->
<<Enc2@element@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute latitude(2) with type INTEGER
Enc4@element = element(3, Val),
Enc4@element@sub = Enc4@element - -2147483648,
if Enc4@element@sub bsr 32 =:= 0 ->
<<Enc4@element@sub:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end|begin
%% attribute altitude(3) with type INTEGER
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc6@element@sub = Enc6@element - -32768,
if Enc6@element@sub bsr 16 =:= 0 ->
<<Enc6@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end
end
end].


dec_AbsolutePosition3d(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute longitude(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -2147483648,
{V2@Add2,V2@Buf1}
end,

%% attribute latitude(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:32,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -2147483648,
{V3@Add2,V3@Buf1}
end,

%% attribute altitude(3) with type INTEGER
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -32768,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = {'AbsolutePosition3d',Term1,Term2,Term3},
{Res1,Bytes4}.

enc_AxleWeightLimit(Val) ->
[begin
%% attribute axleNumber(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 8 =:= 0 ->
Enc1@element;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute maxLadenWeightOnAxle(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_AxleWeightLimit(Bytes) ->

%% attribute axleNumber(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute maxLadenWeightOnAxle(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'AxleWeightLimit',Term1,Term2},
{Res1,Bytes2}.

enc_AxleWeightLimits(Val) ->
[begin
%% attribute maxLadenweightOnAxle1(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute maxLadenweightOnAxle2(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute maxLadenweightOnAxle3(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 16 =:= 0 ->
<<Enc5@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end,
begin
%% attribute maxLadenweightOnAxle4(4) with type INTEGER
Enc7@element = element(5, Val),
if Enc7@element bsr 16 =:= 0 ->
<<Enc7@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end|begin
%% attribute maxLadenweightOnAxle5(5) with type INTEGER
Enc9@element = element(6, Val),
if Enc9@element bsr 16 =:= 0 ->
<<Enc9@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end].


dec_AxleWeightLimits(Bytes) ->

%% attribute maxLadenweightOnAxle1(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute maxLadenweightOnAxle2(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute maxLadenweightOnAxle3(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute maxLadenweightOnAxle4(4) with type INTEGER
{Term4,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute maxLadenweightOnAxle5(5) with type INTEGER
{Term5,Bytes5} = begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end,
Res1 = {'AxleWeightLimits',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes5}.

enc_DateCompact(Val) ->
[begin
%% attribute year(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - 1990,
if Enc1@element@sub bsr 7 =:= 0 ->
<<Enc1@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute month(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 12 ->
<<Enc3@element@sub:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute day(3) with type INTEGER
Enc5@element = element(4, Val),
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 31 ->
<<Enc5@element@sub:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_DateCompact(Bytes) ->

%% attribute year(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1990,
{V1@Add2,V1@Buf1}
end,

%% attribute month(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,

%% attribute day(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,
Res1 = {'DateCompact',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_DieselEmissionValues(Val) ->
[begin
%% attribute particulate(1) with type Particulate
Enc1@element = element(2, Val),
enc_Particulate(Enc1@element)
end|begin
%% attribute absorptionCoeff(2) with type INTEGER
Enc2@element = element(3, Val),
if Enc2@element bsr 16 =:= 0 ->
<<Enc2@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end].


dec_DieselEmissionValues(Bytes) ->

%% attribute particulate(1) with type Particulate
{Term1,Bytes1} = dec_Particulate(Bytes),

%% attribute absorptionCoeff(2) with type INTEGER
{Term2,Bytes2} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
Res1 = {'DieselEmissionValues',Term1,Term2},
{Res1,Bytes2}.

enc_DriverCharacteristics(Val) ->
[begin
%% attribute driverClass(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 8 =:= 0 ->
Enc1@element;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute tripPurpose(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 8 =:= 0 ->
[Enc3@element];
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_DriverCharacteristics(Bytes) ->

%% attribute driverClass(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tripPurpose(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'DriverCharacteristics',Term1,Term2},
{Res1,Bytes2}.

enc_Distance(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_DEFAULT ->
<<0:1>>;
Enc1@element =:= 0 ->
<<0:1>>;
Enc1@element =:= kilometres ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute distanceValue(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 32 =:= 0 ->
<<Enc2@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute distanceUnit(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_DEFAULT ->
[];
Enc4@element =:= 0 ->
[];
Enc4@element =:= kilometres ->
[];
Enc4@element =:= miles ->
[1];
Enc4@element =:= metres ->
[2];
Enc4@element =:= yards ->
[3];
Enc4@element =:= feet ->
[4];
Enc4@element =:= decimetres ->
[5];
Enc4@element =:= quartermetres ->
[6];
Enc4@element =:= centimeters ->
[7];
Enc4@element =:= millimeters ->
[8];
Enc4@element bsr 8 =:= 0 ->
[Enc4@element];
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_Distance(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute distanceValue(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute distanceUnit(2) with type INTEGER
{Term2,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> kilometres;
1 -> miles;
2 -> metres;
3 -> yards;
4 -> feet;
5 -> decimetres;
6 -> quartermetres;
7 -> centimeters;
8 -> millimeters;
_ -> V3@V0
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{0,Bytes2}
end,
Res1 = {'Distance',Term1,Term2},
{Res1,Bytes3}.

enc_Duration(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_DEFAULT ->
<<0:1>>;
Enc1@element =:= 0 ->
<<0:1>>;
Enc1@element =:= seconds ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute durationValue(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 32 =:= 0 ->
<<Enc2@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute timeUnit(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_DEFAULT ->
[];
Enc4@element =:= 0 ->
[];
Enc4@element =:= seconds ->
[];
Enc4@element =:= minutes ->
[1];
Enc4@element =:= hours ->
[2];
Enc4@element =:= days ->
[3];
Enc4@element =:= months ->
[4];
Enc4@element bsr 8 =:= 0 ->
[Enc4@element];
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_Duration(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute durationValue(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timeUnit(2) with type INTEGER
{Term2,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> seconds;
1 -> minutes;
2 -> hours;
3 -> days;
4 -> months;
_ -> V3@V0
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{0,Bytes2}
end,
Res1 = {'Duration',Term1,Term2},
{Res1,Bytes3}.

enc_EngineDetails(Val) ->
[begin
%% attribute engineCapacity(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute enginePower(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_EngineDetails(Bytes) ->

%% attribute engineCapacity(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute enginePower(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'EngineDetails',Term1,Term2},
{Res1,Bytes2}.

enc_ExhaustEmissionValues(Val) ->
[begin
%% attribute unitType(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element =:= mgPerKm ->
<<0:1>>;
Enc1@element =:= mgPerKwh ->
<<1:1>>;
Enc1@element bsr 1 =:= 0 ->
<<Enc1@element:1>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute emissionCo(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 15 =:= 0 ->
<<Enc3@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute emissionHc(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 16 =:= 0 ->
<<Enc5@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end,
begin
%% attribute emissionNox(4) with type INTEGER
Enc7@element = element(5, Val),
if Enc7@element bsr 16 =:= 0 ->
<<Enc7@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end|begin
%% attribute emissionHcNox(5) with type INTEGER
Enc9@element = element(6, Val),
if Enc9@element bsr 16 =:= 0 ->
<<Enc9@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end].


dec_ExhaustEmissionValues(Bytes) ->

%% attribute unitType(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> mgPerKm;
1 -> mgPerKwh
end,
{V1@Int2,V1@Buf1}
end,

%% attribute emissionCo(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:15,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute emissionHc(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute emissionNox(4) with type INTEGER
{Term4,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute emissionHcNox(5) with type INTEGER
{Term5,Bytes5} = begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end,
Res1 = {'ExhaustEmissionValues',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes5}.

enc_NumberOfAxles(Val) ->
[begin
%% attribute trailerAxles(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 3 =:= 0 ->
<<Enc1@element:3>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute tractorAxles(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 3 =:= 0 ->
<<Enc3@element:3>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_NumberOfAxles(Bytes) ->

%% attribute trailerAxles(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tractorAxles(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'NumberOfAxles',Term1,Term2},
{Res1,Bytes2}.

enc_ObeId(Val) ->
[begin
%% attribute manufacturerId(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute equipmentObuId(2) with type OCTET STRING
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len < 128 ->
[Enc4@len|Enc3@element];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc3@element];
true ->
encode_fragmented(Enc3@element, 8)
end
end].


dec_ObeId(Bytes) ->

%% attribute manufacturerId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute equipmentObuId(2) with type OCTET STRING
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
V2@Conv8 = binary:copy(V2@V0),
{V2@Conv8,V2@Buf1}
end,
Res1 = {'ObeId',Term1,Term2},
{Res1,Bytes2}.

enc_Particulate(Val) ->
[begin
%% attribute unitType(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element =:= mgPerKm ->
<<0:1>>;
Enc1@element =:= mgPerKwh ->
<<1:1>>;
Enc1@element bsr 1 =:= 0 ->
<<Enc1@element:1>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute value(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 15 =:= 0 ->
<<Enc3@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_Particulate(Bytes) ->

%% attribute unitType(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> mgPerKm;
1 -> mgPerKwh
end,
{V1@Int2,V1@Buf1}
end,

%% attribute value(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:15,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'Particulate',Term1,Term2},
{Res1,Bytes2}.

enc_PassengerCapacity(Val) ->
[begin
%% attribute numberOfSeats(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 8 =:= 0 ->
Enc1@element;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute numberOfStandingPlaces(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 8 =:= 0 ->
[Enc3@element];
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_PassengerCapacity(Bytes) ->

%% attribute numberOfSeats(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute numberOfStandingPlaces(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'PassengerCapacity',Term1,Term2},
{Res1,Bytes2}.

enc_PaymentFee(Val) ->
[begin
%% attribute paymentFeeAmount(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute paymentFeeUnit(2) with type OCTET STRING
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len =:= 2 ->
Enc3@element
end
end].


dec_PaymentFee(Bytes) ->

%% attribute paymentFeeAmount(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute paymentFeeUnit(2) with type OCTET STRING
{Term2,Bytes2} = begin
<<V2@V0:2/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end,
Res1 = {'PaymentFee',Term1,Term2},
{Res1,Bytes2}.

enc_Period(Val) ->
[begin
%% attribute beginOfPeriod(1) with type GeneralizedTime
Enc1@element = element(2, Val),
Enc2@len = length(Enc1@element),
Enc2@bin = encode_chars(Enc1@element, 7),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 7)
end
end|begin
%% attribute endOfPeriod(2) with type GeneralizedTime
Enc3@element = element(3, Val),
Enc4@len = length(Enc3@element),
Enc4@bin = encode_chars(Enc3@element, 7),
if Enc4@len < 128 ->
[Enc4@len|Enc4@bin];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc4@bin];
true ->
encode_fragmented(Enc4@bin, 7)
end
end].


dec_Period(Bytes) ->

%% attribute beginOfPeriod(1) with type GeneralizedTime
{Term1,Bytes1} = begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@V5:V1@V3/binary-unit:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<1:1,0:1,V1@V4:14,V1@V6:V1@V4/binary-unit:7,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7}  = decode_fragmented(V1@V4, V1@Buf5, 7),
{V1@V6,V1@Buf7}
end,
{V1@V8,V1@Buf9}  = {decode_chars(V1@V0, 7),V1@Buf1},
{V1@V8,V1@Buf9}
end,

%% attribute endOfPeriod(2) with type GeneralizedTime
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:7,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:7,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 7),
{V2@V6,V2@Buf7}
end,
{V2@V8,V2@Buf9}  = {decode_chars(V2@V0, 7),V2@Buf1},
{V2@V8,V2@Buf9}
end,
Res1 = {'Period',Term1,Term2},
{Res1,Bytes2}.

enc_Provider(Val) ->
[begin
%% attribute countryCode(1) with type BIT STRING
Enc1@element = element(2, Val),
Enc2@bits = bit_size(Enc1@element),
if Enc2@bits =:= 10 ->
Enc1@element
end
end|begin
%% attribute providerIdentifier(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 14 =:= 0 ->
<<Enc3@element:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_Provider(Bytes) ->

%% attribute countryCode(1) with type BIT STRING
{Term1,Bytes1} = begin
<<V1@V0:10/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {list_to_bitstring([V1@V0]),V1@Buf1},
{V1@V2,V1@Buf3}
end,

%% attribute providerIdentifier(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:14,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'Provider',Term1,Term2},
{Res1,Bytes2}.

enc_RelativePosition3d(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute longitude(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - -32768,
if Enc2@element@sub bsr 16 =:= 0 ->
<<Enc2@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute latitude(2) with type INTEGER
Enc4@element = element(3, Val),
Enc4@element@sub = Enc4@element - -32768,
if Enc4@element@sub bsr 16 =:= 0 ->
<<Enc4@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end|begin
%% attribute altitude(3) with type INTEGER
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc6@element@sub = Enc6@element - -32768,
if Enc6@element@sub bsr 16 =:= 0 ->
<<Enc6@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end
end
end].


dec_RelativePosition3d(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute longitude(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32768,
{V2@Add2,V2@Buf1}
end,

%% attribute latitude(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -32768,
{V3@Add2,V3@Buf1}
end,

%% attribute altitude(3) with type INTEGER
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -32768,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = {'RelativePosition3d',Term1,Term2,Term3},
{Res1,Bytes4}.

enc_SessionClass(Val) ->
[begin
%% attribute sessionTariffClass(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 8 =:= 0 ->
Enc1@element;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute sessionClaimedClass(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 8 =:= 0 ->
[Enc3@element];
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_SessionClass(Bytes) ->

%% attribute sessionTariffClass(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute sessionClaimedClass(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'SessionClass',Term1,Term2},
{Res1,Bytes2}.

enc_SessionLocation(Val) ->
[begin
%% attribute ascendingKilometrage(1) with type BOOLEAN
Enc1@element = element(2, Val),
if Enc1@element =:= false ->
<<0:1>>;
Enc1@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc1@element}}})
end
end|begin
%% attribute laneCodeNumber(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 7 =:= 0 ->
<<Enc3@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_SessionLocation(Bytes) ->

%% attribute ascendingKilometrage(1) with type BOOLEAN
{Term1,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end,

%% attribute laneCodeNumber(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'SessionLocation',Term1,Term2},
{Res1,Bytes2}.

enc_SignedValue(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= positive ->
if ChoiceVal bsr 23 =:= 0 ->
<<0:1,ChoiceVal:23>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= negative ->
begin
ChoiceVal@sub = ChoiceVal - -8388608,
if ChoiceVal@sub bsr 23 =:= 0 ->
<<1:1,ChoiceVal@sub:23>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end
end
end.


dec_SignedValue(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:23,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{positive,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
<<V3@V0:23,V3@Buf1/bitstring>> = Bytes1,
V3@Add2 = V3@V0 + -8388608,
{V3@Add2,V3@Buf1}
end
end,
{{negative,Val},NewBytes}
end.
enc_SoundLevel(Val) ->
[begin
%% attribute soundStationary(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 8 =:= 0 ->
Enc1@element;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute soundDriveBy(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 8 =:= 0 ->
[Enc3@element];
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_SoundLevel(Bytes) ->

%% attribute soundStationary(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute soundDriveBy(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'SoundLevel',Term1,Term2},
{Res1,Bytes2}.

enc_TimeCompact(Val) ->
[begin
%% attribute hours(1) with type INTEGER
Enc1@element = element(2, Val),
if 0 =< Enc1@element, Enc1@element < 24 ->
<<Enc1@element:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute mins(2) with type INTEGER
Enc3@element = element(3, Val),
if 0 =< Enc3@element, Enc3@element < 60 ->
<<Enc3@element:6>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute doubleSecs(3) with type INTEGER
Enc5@element = element(4, Val),
if 0 =< Enc5@element, Enc5@element < 31 ->
<<Enc5@element:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_TimeCompact(Bytes) ->

%% attribute hours(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute mins(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute doubleSecs(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:5,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = {'TimeCompact',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_TrailerDetails(Val) ->
[begin
%% attribute trailerType(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element =:= notPresent ->
<<0:5>>;
Enc1@element =:= trailer ->
<<1:5>>;
Enc1@element =:= semitrailer ->
<<2:5>>;
Enc1@element bsr 5 =:= 0 ->
<<Enc1@element:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute trailerAxles(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 3 =:= 0 ->
<<Enc3@element:3>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_TrailerDetails(Bytes) ->

%% attribute trailerType(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> notPresent;
1 -> trailer;
2 -> semitrailer;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end,

%% attribute trailerAxles(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'TrailerDetails',Term1,Term2},
{Res1,Bytes2}.

enc_AxlesWeightLimits(Val) ->
Enc1@len = length(Val),
if Enc1@len < 128 ->
[Enc1@len|[enc_AxleWeightLimit(Comp) || Comp <- Val]];
Enc1@len < 16384 ->
[<<2:2,Enc1@len:14>>|[enc_AxleWeightLimit(Comp) || Comp <- Val]];
true ->
begin
Enc1@fn = fun(Comp) -> enc_AxleWeightLimit(Comp) end,
encode_fragmented_sof(Enc1@fn, Val, Enc1@len)
end
end.



dec_AxlesWeightLimits(Bytes) ->
dec_components1(Bytes, []).

enc_ChargeObjectId(Val) ->
[begin
Enc1@element = element(2, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute chargeObjectOperator(1) with type Provider
Enc2@element = element(2, Val),
if Enc2@element =:= asn1_NOVALUE ->
[];
true ->
enc_Provider(Enc2@element)
end
end|begin
%% attribute chargeObjectDesignation(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element bsr 32 =:= 0 ->
<<Enc4@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_ChargeObjectId(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute chargeObjectOperator(1) with type Provider
{Term1,Bytes2} = case Opt band 1 of
1 ->
dec_Provider(Bytes1);
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute chargeObjectDesignation(2) with type INTEGER
{Term2,Bytes3} = begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes2,
{V2@V0,V2@Buf1}
end,
Res1 = {'ChargeObjectId',Term1,Term2},
{Res1,Bytes3}.

enc_ContractValidity(Val) ->
[begin
%% attribute contractRestrictions(1) with type OCTET STRING
Enc1@element = element(2, Val),
Enc2@len = byte_size(Enc1@element),
if Enc2@len =:= 4 ->
Enc1@element
end
end|begin
%% attribute contractExpiryDate(2) with type DateCompact
Enc3@element = element(3, Val),
enc_DateCompact(Enc3@element)
end].


dec_ContractValidity(Bytes) ->

%% attribute contractRestrictions(1) with type OCTET STRING
{Term1,Bytes1} = begin
<<V1@V0:4/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end,

%% attribute contractExpiryDate(2) with type DateCompact
{Term2,Bytes2} = dec_DateCompact(Bytes1),
Res1 = {'ContractValidity',Term1,Term2},
{Res1,Bytes2}.

enc_DateAndTime(Val) ->
[begin
%% attribute timeDate(1) with type DateCompact
Enc1@element = element(2, Val),
enc_DateCompact(Enc1@element)
end|begin
%% attribute timeCompact(2) with type TimeCompact
Enc2@element = element(3, Val),
enc_TimeCompact(Enc2@element)
end].


dec_DateAndTime(Bytes) ->

%% attribute timeDate(1) with type DateCompact
{Term1,Bytes1} = dec_DateCompact(Bytes),

%% attribute timeCompact(2) with type TimeCompact
{Term2,Bytes2} = dec_TimeCompact(Bytes1),
Res1 = {'DateAndTime',Term1,Term2},
{Res1,Bytes2}.

enc_EnvironmentalCharacteristics(Val) ->
[begin
%% attribute euroValue(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element =:= noEntry ->
<<0:4>>;
Enc1@element =:= euro1 ->
<<1:4>>;
Enc1@element =:= euro2 ->
<<2:4>>;
Enc1@element =:= euro3 ->
<<3:4>>;
Enc1@element =:= euro4 ->
<<4:4>>;
Enc1@element =:= euro5 ->
<<5:4>>;
Enc1@element =:= euro6 ->
<<6:4>>;
Enc1@element =:= euro7 ->
<<7:4>>;
Enc1@element =:= eev ->
<<15:4>>;
Enc1@element bsr 4 =:= 0 ->
<<Enc1@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute copValue(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element =:= noEntry ->
<<0:4>>;
Enc3@element =:= co2class1 ->
<<1:4>>;
Enc3@element =:= co2class2 ->
<<2:4>>;
Enc3@element =:= co2class3 ->
<<3:4>>;
Enc3@element =:= co2class4 ->
<<4:4>>;
Enc3@element =:= co2class5 ->
<<5:4>>;
Enc3@element =:= co2class6 ->
<<6:4>>;
Enc3@element =:= co2class7 ->
<<7:4>>;
Enc3@element bsr 4 =:= 0 ->
<<Enc3@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_EnvironmentalCharacteristics(Bytes) ->

%% attribute euroValue(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> noEntry;
1 -> euro1;
2 -> euro2;
3 -> euro3;
4 -> euro4;
5 -> euro5;
6 -> euro6;
7 -> euro7;
15 -> eev;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end,

%% attribute copValue(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> noEntry;
1 -> co2class1;
2 -> co2class2;
3 -> co2class3;
4 -> co2class4;
5 -> co2class5;
6 -> co2class6;
7 -> co2class7;
_ -> V2@V0
end,
{V2@Int2,V2@Buf1}
end,
Res1 = {'EnvironmentalCharacteristics',Term1,Term2},
{Res1,Bytes2}.

enc_Lpn(Val) ->
[begin
%% attribute countryCode(1) with type BIT STRING
Enc1@element = element(2, Val),
Enc2@bits = bit_size(Enc1@element),
if Enc2@bits =:= 10 ->
Enc1@element
end
end,
begin
%% attribute alphabetIndicator(2) with type ENUMERATED
Enc3@element = element(3, Val),
if Enc3@element =:= latinAlphabetNo1 ->
<<0:6>>;
Enc3@element =:= latinAlphabetNo2 ->
<<1:6>>;
Enc3@element =:= latinAlphabetNo3 ->
<<2:6>>;
Enc3@element =:= latinAlphabetNo4 ->
<<3:6>>;
Enc3@element =:= latinCyrillicAlphabet ->
<<4:6>>;
Enc3@element =:= latinArabicAlphabet ->
<<5:6>>;
Enc3@element =:= latinGreekAlphabet ->
<<6:6>>;
Enc3@element =:= latinHebrewAlphabet ->
<<7:6>>;
Enc3@element =:= latinAlphabetNo5 ->
<<8:6>>;
Enc3@element =:= latinAlphabetNo6 ->
<<9:6>>;
Enc3@element =:= twoOctetBMP ->
<<10:6>>;
Enc3@element =:= fourOctetCanonical ->
<<11:6>>;
Enc3@element =:= reservedForUse1 ->
<<12:6>>;
Enc3@element =:= reservedForUse2 ->
<<13:6>>;
Enc3@element =:= reservedForUse3 ->
<<14:6>>;
Enc3@element =:= reservedForUse4 ->
<<15:6>>;
Enc3@element =:= reservedForUse5 ->
<<16:6>>;
Enc3@element =:= reservedForUse6 ->
<<17:6>>;
Enc3@element =:= reservedForUse7 ->
<<18:6>>;
Enc3@element =:= reservedForUse8 ->
<<19:6>>;
Enc3@element =:= reservedForUse9 ->
<<20:6>>;
Enc3@element =:= reservedForUse10 ->
<<21:6>>;
Enc3@element =:= reservedForUse11 ->
<<22:6>>;
Enc3@element =:= reservedForUse12 ->
<<23:6>>;
Enc3@element =:= reservedForUse13 ->
<<24:6>>;
Enc3@element =:= reservedForUse14 ->
<<25:6>>;
Enc3@element =:= reservedForUse15 ->
<<26:6>>;
Enc3@element =:= reservedForUse16 ->
<<27:6>>;
Enc3@element =:= reservedForUse17 ->
<<28:6>>;
Enc3@element =:= reservedForUse18 ->
<<29:6>>;
Enc3@element =:= reservedForUse19 ->
<<30:6>>;
Enc3@element =:= reservedForUse20 ->
<<31:6>>;
Enc3@element =:= reservedForUse21 ->
<<32:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc3@element}}})
end
end|begin
%% attribute licencePlateNumber(3) with type OCTET STRING
Enc5@element = element(4, Val),
Enc6@len = byte_size(Enc5@element),
if Enc6@len < 128 ->
[Enc6@len|Enc5@element];
Enc6@len < 16384 ->
[<<2:2,Enc6@len:14>>|Enc5@element];
true ->
encode_fragmented(Enc5@element, 8)
end
end].


dec_Lpn(Bytes) ->

%% attribute countryCode(1) with type BIT STRING
{Term1,Bytes1} = begin
<<V1@V0:10/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {list_to_bitstring([V1@V0]),V1@Buf1},
{V1@V2,V1@Buf3}
end,

%% attribute alphabetIndicator(2) with type ENUMERATED
{Term2,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> latinAlphabetNo1;
1 -> latinAlphabetNo2;
2 -> latinAlphabetNo3;
3 -> latinAlphabetNo4;
4 -> latinCyrillicAlphabet;
5 -> latinArabicAlphabet;
6 -> latinGreekAlphabet;
7 -> latinHebrewAlphabet;
8 -> latinAlphabetNo5;
9 -> latinAlphabetNo6;
10 -> twoOctetBMP;
11 -> fourOctetCanonical;
12 -> reservedForUse1;
13 -> reservedForUse2;
14 -> reservedForUse3;
15 -> reservedForUse4;
16 -> reservedForUse5;
17 -> reservedForUse6;
18 -> reservedForUse7;
19 -> reservedForUse8;
20 -> reservedForUse9;
21 -> reservedForUse10;
22 -> reservedForUse11;
23 -> reservedForUse12;
24 -> reservedForUse13;
25 -> reservedForUse14;
26 -> reservedForUse15;
27 -> reservedForUse16;
28 -> reservedForUse17;
29 -> reservedForUse18;
30 -> reservedForUse19;
31 -> reservedForUse20;
32 -> reservedForUse21;
_ -> exit({error,{asn1,{decode_enumerated,V2@V0}}})
end,
{V2@Int2,V2@Buf1}
end,

%% attribute licencePlateNumber(3) with type OCTET STRING
{Term3,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@V5:V3@V3/binary-unit:8,V3@Buf6/bitstring>> ->
{V3@V5,V3@Buf6};
<<1:1,0:1,V3@V4:14,V3@V6:V3@V4/binary-unit:8,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,1:1,V3@V4:6,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7}  = decode_fragmented(V3@V4, V3@Buf5, 8),
{V3@V6,V3@Buf7}
end,
V3@Conv8 = binary:copy(V3@V0),
{V3@Conv8,V3@Buf1}
end,
Res1 = {'Lpn',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_PaymentMeans(Val) ->
[begin
%% attribute personalAccountNumber(1) with type OCTET STRING
Enc1@element = element(2, Val),
Enc2@len = byte_size(Enc1@element),
if Enc2@len =:= 10 ->
Enc1@element
end
end,
begin
%% attribute paymentMeansExpiryDate(2) with type DateCompact
Enc3@element = element(3, Val),
enc_DateCompact(Enc3@element)
end|begin
%% attribute pamentMeansUsageControl(3) with type OCTET STRING
Enc4@element = element(4, Val),
Enc5@len = byte_size(Enc4@element),
if Enc5@len =:= 2 ->
Enc4@element
end
end].


dec_PaymentMeans(Bytes) ->

%% attribute personalAccountNumber(1) with type OCTET STRING
{Term1,Bytes1} = begin
<<V1@V0:10/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end,

%% attribute paymentMeansExpiryDate(2) with type DateCompact
{Term2,Bytes2} = dec_DateCompact(Bytes1),

%% attribute pamentMeansUsageControl(3) with type OCTET STRING
{Term3,Bytes3} = begin
<<V2@V0:2/binary-unit:8,V2@Buf1/bitstring>> = Bytes2,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end,
Res1 = {'PaymentMeans',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_PaymentMeansBalance(Val) ->
enc_SignedValue(Val).


dec_PaymentMeansBalance(Bytes) ->
dec_SignedValue(Bytes).

enc_Point(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= pointIdentifier ->
if ChoiceVal bsr 32 =:= 0 ->
<<0:2,ChoiceVal:32>>;
true ->
exit({error,{asn1,{illegal_integer,ChoiceVal}}})
end;
ChoiceTag =:= absolutePointCoordinates ->
[<<1:2>>|enc_AbsolutePosition3d(ChoiceVal)];
ChoiceTag =:= relativePointCoordinates ->
[<<2:2>>|enc_RelativePosition3d(ChoiceVal)]
end.


dec_Point(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end
end,
{{pointIdentifier,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_AbsolutePosition3d(Bytes1)
end,
{{absolutePointCoordinates,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_RelativePosition3d(Bytes1)
end,
{{relativePointCoordinates,Val},NewBytes}
end.
enc_PurseBalance(Val) ->
[begin
%% attribute purseValue(1) with type SignedValue
Enc1@element = element(2, Val),
enc_SignedValue(Enc1@element)
end|begin
%% attribute purseUnit(2) with type OCTET STRING
Enc2@element = element(3, Val),
Enc3@len = byte_size(Enc2@element),
if Enc3@len =:= 2 ->
Enc2@element
end
end].


dec_PurseBalance(Bytes) ->

%% attribute purseValue(1) with type SignedValue
{Term1,Bytes1} = dec_SignedValue(Bytes),

%% attribute purseUnit(2) with type OCTET STRING
{Term2,Bytes2} = begin
<<V1@V0:2/binary-unit:8,V1@Buf1/bitstring>> = Bytes1,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end,
Res1 = {'PurseBalance',Term1,Term2},
{Res1,Bytes2}.

enc_TrailerCharacteristics(Val) ->
[begin
%% attribute trailerDetails(1) with type TrailerDetails
Enc1@element = element(2, Val),
enc_TrailerDetails(Enc1@element)
end,
begin
%% attribute trailerMaxLadenWeight(2) with type INTEGER
Enc2@element = element(3, Val),
if Enc2@element bsr 16 =:= 0 ->
<<Enc2@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute trailerWeightUnladen(3) with type INTEGER
Enc4@element = element(4, Val),
if Enc4@element bsr 16 =:= 0 ->
<<Enc4@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_TrailerCharacteristics(Bytes) ->

%% attribute trailerDetails(1) with type TrailerDetails
{Term1,Bytes1} = dec_TrailerDetails(Bytes),

%% attribute trailerMaxLadenWeight(2) with type INTEGER
{Term2,Bytes2} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,

%% attribute trailerWeightUnladen(3) with type INTEGER
{Term3,Bytes3} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes2,
{V2@V0,V2@Buf1}
end,
Res1 = {'TrailerCharacteristics',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_ValidityOfContract(Val) ->
[begin
%% attribute issuerRestrictions(1) with type OCTET STRING
Enc1@element = element(2, Val),
Enc2@len = byte_size(Enc1@element),
if Enc2@len =:= 2 ->
Enc1@element
end
end|begin
%% attribute contractExpiryDate(2) with type DateCompact
Enc3@element = element(3, Val),
enc_DateCompact(Enc3@element)
end].


dec_ValidityOfContract(Bytes) ->

%% attribute issuerRestrictions(1) with type OCTET STRING
{Term1,Bytes1} = begin
<<V1@V0:2/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end,

%% attribute contractExpiryDate(2) with type DateCompact
{Term2,Bytes2} = dec_DateCompact(Bytes1),
Res1 = {'ValidityOfContract',Term1,Term2},
{Res1,Bytes2}.

enc_VehicleAxlesNumber(Val) ->
[begin
%% attribute tyreConfiguration(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element =:= notSpecified ->
<<0:2>>;
Enc1@element =:= singleTyre ->
<<1:2>>;
Enc1@element =:= dualTyres ->
<<2:2>>;
Enc1@element =:= reservedForUse ->
<<3:2>>;
Enc1@element bsr 2 =:= 0 ->
<<Enc1@element:2>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute numberOfAxles(2) with type NumberOfAxles
Enc3@element = element(3, Val),
enc_NumberOfAxles(Enc3@element)
end].


dec_VehicleAxlesNumber(Bytes) ->

%% attribute tyreConfiguration(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> notSpecified;
1 -> singleTyre;
2 -> dualTyres;
3 -> reservedForUse
end,
{V1@Int2,V1@Buf1}
end,

%% attribute numberOfAxles(2) with type NumberOfAxles
{Term2,Bytes2} = dec_NumberOfAxles(Bytes1),
Res1 = {'VehicleAxlesNumber',Term1,Term2},
{Res1,Bytes2}.

enc_VehicleDimensions(Val) ->
[begin
%% attribute vehicleLengthOverall(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 8 =:= 0 ->
Enc1@element;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute vehicleHeigthOverall(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 8 =:= 0 ->
Enc3@element;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute vehicleWidthOverall(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 8 =:= 0 ->
[Enc5@element];
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_VehicleDimensions(Bytes) ->

%% attribute vehicleLengthOverall(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute vehicleHeigthOverall(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute vehicleWidthOverall(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = {'VehicleDimensions',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_VehicleWeightLimits(Val) ->
[begin
%% attribute vehicleMaxLadenWeight(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute vehicleTrainMaximumWeight(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute vehicleWeightUnladen(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 16 =:= 0 ->
<<Enc5@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_VehicleWeightLimits(Bytes) ->

%% attribute vehicleMaxLadenWeight(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute vehicleTrainMaximumWeight(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute vehicleWeightUnladen(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = {'VehicleWeightLimits',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_EfcContextMark(Val) ->
[begin
%% attribute contractProvider(1) with type Provider
Enc1@element = element(2, Val),
enc_Provider(Enc1@element)
end,
begin
%% attribute typeOfContract(2) with type OCTET STRING
Enc2@element = element(3, Val),
Enc3@len = byte_size(Enc2@element),
if Enc3@len =:= 2 ->
Enc2@element
end
end|begin
%% attribute contextVersion(3) with type INTEGER
Enc4@element = element(4, Val),
if Enc4@element bsr 7 =:= 0 ->
<<0:1,Enc4@element:7>>;
true ->
[<<1:1>>|encode_unconstrained_number(Enc4@element)]
end
end].


dec_EfcContextMark(Bytes) ->

%% attribute contractProvider(1) with type Provider
{Term1,Bytes1} = dec_Provider(Bytes),

%% attribute typeOfContract(2) with type OCTET STRING
{Term2,Bytes2} = begin
<<V1@V0:2/binary-unit:8,V1@Buf1/bitstring>> = Bytes1,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end,

%% attribute contextVersion(3) with type INTEGER
{Term3,Bytes3} = begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@Buf4/bitstring>> ->
{V2@V3,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
<<V2@V10:V2@V3/signed-unit:8,V2@Buf11/bitstring>> = V2@Buf4,
{V2@V10,V2@Buf11}
end,
{V2@V0,V2@Buf1}
end,
Res1 = {'EfcContextMark',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_ReceiptContract(Val) ->
[begin
%% attribute sessionContractProvider(1) with type Provider
Enc1@element = element(2, Val),
enc_Provider(Enc1@element)
end,
begin
%% attribute sessionTypeOfContract(2) with type OCTET STRING
Enc2@element = element(3, Val),
Enc3@len = byte_size(Enc2@element),
if Enc3@len =:= 2 ->
Enc2@element
end
end|begin
%% attribute sessionContractSerialNumber(3) with type INTEGER
Enc4@element = element(4, Val),
if Enc4@element bsr 32 =:= 0 ->
<<Enc4@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_ReceiptContract(Bytes) ->

%% attribute sessionContractProvider(1) with type Provider
{Term1,Bytes1} = dec_Provider(Bytes),

%% attribute sessionTypeOfContract(2) with type OCTET STRING
{Term2,Bytes2} = begin
<<V1@V0:2/binary-unit:8,V1@Buf1/bitstring>> = Bytes1,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end,

%% attribute sessionContractSerialNumber(3) with type INTEGER
{Term3,Bytes3} = begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes2,
{V2@V0,V2@Buf1}
end,
Res1 = {'ReceiptContract',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_ReceiptData(Val) ->
[begin
%% attribute sessionTime(1) with type DateAndTime
Enc1@element = element(2, Val),
enc_DateAndTime(Enc1@element)
end,
begin
%% attribute sessionServiceProvider(2) with type Provider
Enc2@element = element(3, Val),
enc_Provider(Enc2@element)
end,
begin
%% attribute locationOfStation(3) with type INTEGER
Enc3@element = element(4, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute sessionLocation(4) with type SessionLocation
Enc5@element = element(5, Val),
enc_SessionLocation(Enc5@element)
end,
begin
%% attribute sessionType(5) with type INTEGER
Enc6@element = element(6, Val),
if Enc6@element bsr 8 =:= 0 ->
Enc6@element;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end,
begin
%% attribute sessionResult(6) with type INTEGER
Enc8@element = element(7, Val),
if Enc8@element =:= correctTransaction ->
0;
Enc8@element =:= obeStatusNotAccepted ->
1;
Enc8@element =:= equipmentStatusNotAccepted ->
2;
Enc8@element =:= contractNotInWhiteList ->
3;
Enc8@element =:= contractIdentifierInBlackList ->
4;
Enc8@element =:= contractIdentifierNotCorrect ->
5;
Enc8@element =:= expiredContract ->
6;
Enc8@element =:= contractRestrictionsNotFulfilled ->
7;
Enc8@element =:= claimedVehicleCharacteristicsNotValid ->
8;
Enc8@element =:= vehicleClassAuthenticationFailed ->
9;
Enc8@element =:= entryVehicleClassDifferentFromExitVehicleClass ->
10;
Enc8@element =:= entryReceiptMissing ->
11;
Enc8@element =:= entryReceiptNotValid ->
12;
Enc8@element =:= entryTollStationNotValid ->
13;
Enc8@element =:= equipmentNotCertified ->
14;
Enc8@element =:= timeDifference ->
15;
Enc8@element =:= accessCredentialsNotAccepted ->
16;
Enc8@element =:= contractAuthenticatorNotAccepted ->
17;
Enc8@element =:= receiptAuthenticatorNotAccepted ->
18;
Enc8@element =:= claimedVehicleCharacteristicsMissing ->
19;
Enc8@element =:= paymentMeansNotAccepted ->
20;
Enc8@element =:= paymentAuthenticatorNotAccepted ->
21;
Enc8@element =:= paymentMeansInBlackList ->
22;
Enc8@element =:= paymentMeansNotCorrect ->
23;
Enc8@element =:= expiredPaymentMeans ->
24;
Enc8@element =:= paymentMeansRestrictionsNotFulfilled ->
25;
Enc8@element bsr 8 =:= 0 ->
Enc8@element;
true ->
exit({error,{asn1,{illegal_integer,Enc8@element}}})
end
end,
begin
%% attribute sessionTariffClass(7) with type INTEGER
Enc10@element = element(8, Val),
if Enc10@element bsr 8 =:= 0 ->
Enc10@element;
true ->
exit({error,{asn1,{illegal_integer,Enc10@element}}})
end
end,
begin
%% attribute sessionClaimedClass(8) with type INTEGER
Enc12@element = element(9, Val),
if Enc12@element bsr 8 =:= 0 ->
Enc12@element;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end,
begin
%% attribute sessionFee(9) with type PaymentFee
Enc14@element = element(10, Val),
enc_PaymentFee(Enc14@element)
end,
begin
%% attribute sessionContractProvider(10) with type Provider
Enc15@element = element(11, Val),
enc_Provider(Enc15@element)
end,
begin
%% attribute sessionTypeOfContract(11) with type OCTET STRING
Enc16@element = element(12, Val),
Enc17@len = byte_size(Enc16@element),
if Enc17@len =:= 2 ->
Enc16@element
end
end,
begin
%% attribute sessionContextVersion(12) with type INTEGER
Enc18@element = element(13, Val),
if Enc18@element bsr 7 =:= 0 ->
<<0:1,Enc18@element:7>>;
true ->
[<<1:1>>|encode_unconstrained_number(Enc18@element)]
end
end|begin
%% attribute receiptDataAuthenticator(13) with type OCTET STRING
Enc20@element = element(14, Val),
Enc21@len = byte_size(Enc20@element),
if Enc21@len =:= 4 ->
Enc20@element
end
end].


dec_ReceiptData(Bytes) ->

%% attribute sessionTime(1) with type DateAndTime
{Term1,Bytes1} = dec_DateAndTime(Bytes),

%% attribute sessionServiceProvider(2) with type Provider
{Term2,Bytes2} = dec_Provider(Bytes1),

%% attribute locationOfStation(3) with type INTEGER
{Term3,Bytes3} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes2,
{V1@V0,V1@Buf1}
end,

%% attribute sessionLocation(4) with type SessionLocation
{Term4,Bytes4} = dec_SessionLocation(Bytes3),

%% attribute sessionType(5) with type INTEGER
{Term5,Bytes5} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes4,
{V2@V0,V2@Buf1}
end,

%% attribute sessionResult(6) with type INTEGER
{Term6,Bytes6} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes5,
V3@Int2 = case V3@V0 of
0 -> correctTransaction;
1 -> obeStatusNotAccepted;
2 -> equipmentStatusNotAccepted;
3 -> contractNotInWhiteList;
4 -> contractIdentifierInBlackList;
5 -> contractIdentifierNotCorrect;
6 -> expiredContract;
7 -> contractRestrictionsNotFulfilled;
8 -> claimedVehicleCharacteristicsNotValid;
9 -> vehicleClassAuthenticationFailed;
10 -> entryVehicleClassDifferentFromExitVehicleClass;
11 -> entryReceiptMissing;
12 -> entryReceiptNotValid;
13 -> entryTollStationNotValid;
14 -> equipmentNotCertified;
15 -> timeDifference;
16 -> accessCredentialsNotAccepted;
17 -> contractAuthenticatorNotAccepted;
18 -> receiptAuthenticatorNotAccepted;
19 -> claimedVehicleCharacteristicsMissing;
20 -> paymentMeansNotAccepted;
21 -> paymentAuthenticatorNotAccepted;
22 -> paymentMeansInBlackList;
23 -> paymentMeansNotCorrect;
24 -> expiredPaymentMeans;
25 -> paymentMeansRestrictionsNotFulfilled;
_ -> V3@V0
end,
{V3@Int2,V3@Buf1}
end,

%% attribute sessionTariffClass(7) with type INTEGER
{Term7,Bytes7} = begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes6,
{V4@V0,V4@Buf1}
end,

%% attribute sessionClaimedClass(8) with type INTEGER
{Term8,Bytes8} = begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes7,
{V5@V0,V5@Buf1}
end,

%% attribute sessionFee(9) with type PaymentFee
{Term9,Bytes9} = dec_PaymentFee(Bytes8),

%% attribute sessionContractProvider(10) with type Provider
{Term10,Bytes10} = dec_Provider(Bytes9),

%% attribute sessionTypeOfContract(11) with type OCTET STRING
{Term11,Bytes11} = begin
<<V6@V0:2/binary-unit:8,V6@Buf1/bitstring>> = Bytes10,
V6@Conv2 = binary:copy(V6@V0),
{V6@Conv2,V6@Buf1}
end,

%% attribute sessionContextVersion(12) with type INTEGER
{Term12,Bytes12} = begin
{V7@V0,V7@Buf1} = case Bytes11 of
<<0:1,V7@V3:7,V7@Buf4/bitstring>> ->
{V7@V3,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
<<V7@V10:V7@V3/signed-unit:8,V7@Buf11/bitstring>> = V7@Buf4,
{V7@V10,V7@Buf11}
end,
{V7@V0,V7@Buf1}
end,

%% attribute receiptDataAuthenticator(13) with type OCTET STRING
{Term13,Bytes13} = begin
<<V8@V0:4/binary-unit:8,V8@Buf1/bitstring>> = Bytes12,
V8@Conv2 = binary:copy(V8@V0),
{V8@Conv2,V8@Buf1}
end,
Res1 = {'ReceiptData',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13},
{Res1,Bytes13}.

enc_ReceiptFinancialPart(Val) ->
[begin
%% attribute personalAccountNumber(1) with type OCTET STRING
Enc1@element = element(2, Val),
Enc2@len = byte_size(Enc1@element),
if Enc2@len =:= 10 ->
Enc1@element
end
end,
begin
%% attribute sessionPaymentFee(2) with type PaymentFee
Enc3@element = element(3, Val),
enc_PaymentFee(Enc3@element)
end,
begin
%% attribute sessionCurrentBalance(3) with type PurseBalance
Enc4@element = element(4, Val),
enc_PurseBalance(Enc4@element)
end|begin
%% attribute receiptFinancialSerialNumber(4) with type INTEGER
Enc5@element = element(5, Val),
if Enc5@element bsr 32 =:= 0 ->
<<Enc5@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_ReceiptFinancialPart(Bytes) ->

%% attribute personalAccountNumber(1) with type OCTET STRING
{Term1,Bytes1} = begin
<<V1@V0:10/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end,

%% attribute sessionPaymentFee(2) with type PaymentFee
{Term2,Bytes2} = dec_PaymentFee(Bytes1),

%% attribute sessionCurrentBalance(3) with type PurseBalance
{Term3,Bytes3} = dec_PurseBalance(Bytes2),

%% attribute receiptFinancialSerialNumber(4) with type INTEGER
{Term4,Bytes4} = begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes3,
{V2@V0,V2@Buf1}
end,
Res1 = {'ReceiptFinancialPart',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.

enc_ReceiptServicePart(Val) ->
[begin
%% attribute sessionTime(1) with type DateAndTime
Enc1@element = element(2, Val),
enc_DateAndTime(Enc1@element)
end,
begin
%% attribute sessionServiceProvider(2) with type Provider
Enc2@element = element(3, Val),
enc_Provider(Enc2@element)
end,
begin
%% attribute stationLocation(3) with type INTEGER
Enc3@element = element(4, Val),
if Enc3@element bsr 20 =:= 0 ->
<<Enc3@element:20>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute sessionLocation(4) with type BIT STRING
Enc5@element = element(5, Val),
Enc6@bits = bit_size(Enc5@element),
if Enc6@bits =:= 8 ->
Enc5@element
end
end,
begin
%% attribute typeOfSession(5) with type INTEGER
Enc7@element = element(6, Val),
if Enc7@element =:= unspecified ->
<<0:4>>;
Enc7@element =:= closedEntryWithPayment ->
<<1:4>>;
Enc7@element =:= closedEntryWithoutPayment ->
<<2:4>>;
Enc7@element =:= closedTransit ->
<<3:4>>;
Enc7@element =:= closedExit ->
<<4:4>>;
Enc7@element =:= closedCredit ->
<<5:4>>;
Enc7@element =:= mixed ->
<<6:4>>;
Enc7@element =:= passage ->
<<7:4>>;
Enc7@element =:= checkpoint ->
<<8:4>>;
Enc7@element =:= reload ->
<<9:4>>;
Enc7@element =:= reservedForFutureCENUse1 ->
<<10:4>>;
Enc7@element =:= reservedForFutureCENUse2 ->
<<11:4>>;
Enc7@element =:= reservedForFutureCENUse3 ->
<<12:4>>;
Enc7@element =:= reservedForFutureCENUse4 ->
<<13:4>>;
Enc7@element =:= privateUse5 ->
<<14:4>>;
Enc7@element =:= privateUse6 ->
<<15:4>>;
Enc7@element bsr 4 =:= 0 ->
<<Enc7@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end,
begin
%% attribute sessionResultOperational(6) with type INTEGER
Enc9@element = element(7, Val),
if Enc9@element =:= correctTransaction ->
0;
Enc9@element =:= obeStatusNotAccepted ->
1;
Enc9@element =:= equipmentStatusNotAccepted ->
2;
Enc9@element =:= contractNotInWhiteList ->
3;
Enc9@element =:= contractIdentifierInBlackList ->
4;
Enc9@element =:= contractIdentifierNotCorrect ->
5;
Enc9@element =:= expiredContract ->
6;
Enc9@element =:= contractRestrictionsNotFulfilled ->
7;
Enc9@element =:= claimedVehicleCharacteristicsNotValid ->
8;
Enc9@element =:= vehicleClassAuthenticationFailed ->
9;
Enc9@element =:= entryVehicleClassDifferentFromExitVehicleClass ->
10;
Enc9@element =:= entryReceiptMissing ->
11;
Enc9@element =:= entryReceiptNotValid ->
12;
Enc9@element =:= entryTollStationNotValid ->
13;
Enc9@element =:= equipmentNotCertified ->
14;
Enc9@element =:= timeDifference ->
15;
Enc9@element =:= accessCredentialsNotAccepted ->
16;
Enc9@element =:= contractAuthenticatorNotAccepted ->
17;
Enc9@element =:= receiptAuthenticatorNotAccepted ->
18;
Enc9@element =:= claimedVehicleCharacteristicsMissing ->
19;
Enc9@element =:= paymentMeansNotAccepted ->
20;
Enc9@element =:= paymentAuthenticatorNotAccepted ->
21;
Enc9@element =:= paymentMeansInBlackList ->
22;
Enc9@element =:= paymentMeansNotCorrect ->
23;
Enc9@element =:= expiredPaymentMeans ->
24;
Enc9@element =:= paymentMeansRestrictionsNotFulfilled ->
25;
Enc9@element bsr 8 =:= 0 ->
Enc9@element;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end|begin
%% attribute sessionResultFinancial(7) with type OCTET STRING
Enc11@element = element(8, Val),
Enc12@len = byte_size(Enc11@element),
if Enc12@len =:= 1 ->
Enc11@element
end
end].


dec_ReceiptServicePart(Bytes) ->

%% attribute sessionTime(1) with type DateAndTime
{Term1,Bytes1} = dec_DateAndTime(Bytes),

%% attribute sessionServiceProvider(2) with type Provider
{Term2,Bytes2} = dec_Provider(Bytes1),

%% attribute stationLocation(3) with type INTEGER
{Term3,Bytes3} = begin
<<V1@V0:20,V1@Buf1/bitstring>> = Bytes2,
{V1@V0,V1@Buf1}
end,

%% attribute sessionLocation(4) with type BIT STRING
{Term4,Bytes4} = begin
<<V2@V0:8/binary-unit:1,V2@Buf1/bitstring>> = Bytes3,
{V2@V2,V2@Buf3}  = {list_to_bitstring([V2@V0]),V2@Buf1},
{V2@V2,V2@Buf3}
end,

%% attribute typeOfSession(5) with type INTEGER
{Term5,Bytes5} = begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes4,
V3@Int2 = case V3@V0 of
0 -> unspecified;
1 -> closedEntryWithPayment;
2 -> closedEntryWithoutPayment;
3 -> closedTransit;
4 -> closedExit;
5 -> closedCredit;
6 -> mixed;
7 -> passage;
8 -> checkpoint;
9 -> reload;
10 -> reservedForFutureCENUse1;
11 -> reservedForFutureCENUse2;
12 -> reservedForFutureCENUse3;
13 -> reservedForFutureCENUse4;
14 -> privateUse5;
15 -> privateUse6
end,
{V3@Int2,V3@Buf1}
end,

%% attribute sessionResultOperational(6) with type INTEGER
{Term6,Bytes6} = begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes5,
V4@Int2 = case V4@V0 of
0 -> correctTransaction;
1 -> obeStatusNotAccepted;
2 -> equipmentStatusNotAccepted;
3 -> contractNotInWhiteList;
4 -> contractIdentifierInBlackList;
5 -> contractIdentifierNotCorrect;
6 -> expiredContract;
7 -> contractRestrictionsNotFulfilled;
8 -> claimedVehicleCharacteristicsNotValid;
9 -> vehicleClassAuthenticationFailed;
10 -> entryVehicleClassDifferentFromExitVehicleClass;
11 -> entryReceiptMissing;
12 -> entryReceiptNotValid;
13 -> entryTollStationNotValid;
14 -> equipmentNotCertified;
15 -> timeDifference;
16 -> accessCredentialsNotAccepted;
17 -> contractAuthenticatorNotAccepted;
18 -> receiptAuthenticatorNotAccepted;
19 -> claimedVehicleCharacteristicsMissing;
20 -> paymentMeansNotAccepted;
21 -> paymentAuthenticatorNotAccepted;
22 -> paymentMeansInBlackList;
23 -> paymentMeansNotCorrect;
24 -> expiredPaymentMeans;
25 -> paymentMeansRestrictionsNotFulfilled;
_ -> V4@V0
end,
{V4@Int2,V4@Buf1}
end,

%% attribute sessionResultFinancial(7) with type OCTET STRING
{Term7,Bytes7} = begin
<<V5@V0:1/binary-unit:8,V5@Buf1/bitstring>> = Bytes6,
V5@Conv2 = binary:copy(V5@V0),
{V5@Conv2,V5@Buf1}
end,
Res1 = {'ReceiptServicePart',Term1,Term2,Term3,Term4,Term5,Term6,Term7},
{Res1,Bytes7}.

enc_UserId(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute pan(1) with type OCTET STRING
Enc6@element = element(2, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc7@len = byte_size(Enc6@element),
if Enc7@len =:= 10 ->
Enc6@element
end
end
end
end,
begin
%% attribute contractSerialNumber(2) with type INTEGER
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
Enc9@element bsr 32 =:= 0 ->
<<Enc9@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end,
begin
%% attribute licencePlateNumber(3) with type Lpn
Enc12@element = element(4, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
enc_Lpn(Enc12@element)
end
end,
begin
%% attribute obeId(4) with type ObeId
Enc14@element = element(5, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
true ->
enc_ObeId(Enc14@element)
end
end|begin
%% attribute iccId(5) with type OCTET STRING
Enc16@element = element(6, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc17@len = byte_size(Enc16@element),
if Enc17@len < 128 ->
[Enc17@len|Enc16@element];
Enc17@len < 16384 ->
[<<2:2,Enc17@len:14>>|Enc16@element];
true ->
encode_fragmented(Enc16@element, 8)
end
end
end
end].


dec_UserId(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute pan(1) with type OCTET STRING
{Term1,Bytes2} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V2@V0:10/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute contractSerialNumber(2) with type INTEGER
{Term2,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:32,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute licencePlateNumber(3) with type Lpn
{Term3,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
dec_Lpn(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute obeId(4) with type ObeId
{Term4,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
dec_ObeId(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute iccId(5) with type OCTET STRING
{Term5,Bytes6} = case Opt band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes5 of
<<0:1,V4@V3:7,V4@V5:V4@V3/binary-unit:8,V4@Buf6/bitstring>> ->
{V4@V5,V4@Buf6};
<<1:1,0:1,V4@V4:14,V4@V6:V4@V4/binary-unit:8,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,1:1,V4@V4:6,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7}  = decode_fragmented(V4@V4, V4@Buf5, 8),
{V4@V6,V4@Buf7}
end,
V4@Conv8 = binary:copy(V4@V0),
{V4@Conv8,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,
Res1 = {'UserId',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes6}.

enc_VehicleAxles(Val) ->
[begin
%% attribute vehicleFirstAxleHeight(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 8 =:= 0 ->
Enc1@element;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute vehicleAxlesNumber(2) with type VehicleAxlesNumber
Enc3@element = element(3, Val),
enc_VehicleAxlesNumber(Enc3@element)
end].


dec_VehicleAxles(Bytes) ->

%% attribute vehicleFirstAxleHeight(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute vehicleAxlesNumber(2) with type VehicleAxlesNumber
{Term2,Bytes2} = dec_VehicleAxlesNumber(Bytes1),
Res1 = {'VehicleAxles',Term1,Term2},
{Res1,Bytes2}.

enc_VehicleSpecificCharacteristics(Val) ->
[begin
%% attribute environmentalCharacteristics(1) with type EnvironmentalCharacteristics
Enc1@element = element(2, Val),
enc_EnvironmentalCharacteristics(Enc1@element)
end,
begin
%% attribute engineCharacteristics(2) with type INTEGER
Enc2@element = element(3, Val),
if Enc2@element =:= noEntry ->
0;
Enc2@element =:= noEngine ->
1;
Enc2@element =:= petrolUnleaded ->
2;
Enc2@element =:= petrolLeaded ->
3;
Enc2@element =:= diesel ->
4;
Enc2@element =:= lpg ->
5;
Enc2@element =:= battery ->
6;
Enc2@element =:= solar ->
7;
Enc2@element =:= hybrid ->
8;
Enc2@element =:= hydrogen ->
9;
Enc2@element =:= multiFuel ->
10;
Enc2@element =:= bivalentPetrolLpg ->
11;
Enc2@element =:= bivalentPetrolCng ->
12;
Enc2@element =:= combinedPetrolElectric ->
13;
Enc2@element =:= cng ->
14;
Enc2@element =:= lng ->
15;
Enc2@element =:= combinedDieselElectric ->
16;
Enc2@element =:= combinedHydrogenElectric ->
17;
Enc2@element =:= bivalentHydrogenPetrol ->
18;
Enc2@element =:= bivalentHydrogenPetrolElectricEngine ->
19;
Enc2@element =:= fuelCellHydrogen ->
20;
Enc2@element =:= fuelCellPetrol ->
21;
Enc2@element =:= fuelCellMethanol ->
22;
Enc2@element =:= fuelCellEthanol ->
23;
Enc2@element =:= fuelCellDiesel ->
24;
Enc2@element =:= combinedMultiFuelElectricEngine ->
25;
Enc2@element =:= combinedCngElectricEngine ->
26;
Enc2@element =:= combinedLngElectricEngine ->
27;
Enc2@element =:= petrolEthanol ->
28;
Enc2@element =:= combinedLpgElectricEngine ->
29;
Enc2@element =:= hybridPetrolExternalBattery ->
30;
Enc2@element =:= hybridDieselExternalBattery ->
31;
Enc2@element =:= hybridLpgExternalBattery ->
32;
Enc2@element =:= hybridHydrogenExternalBattery ->
33;
Enc2@element =:= hybridMultiFuelExternalBattery ->
34;
Enc2@element =:= hybridCngExternalBattery ->
35;
Enc2@element =:= hybridLngExternalBattery ->
36;
Enc2@element =:= hybridBivalentHydrogenPetrolExternalBattery ->
37;
Enc2@element =:= hydrogenCng ->
38;
Enc2@element =:= hydrogenLng ->
39;
Enc2@element =:= hybridHydrogenCngExternalBattery ->
40;
Enc2@element =:= hybridHydrogenLngExternalBattery ->
41;
Enc2@element =:= ethanol ->
42;
Enc2@element =:= hybridFuelCellHydrogen ->
43;
Enc2@element =:= hybridFuelCellHydrogenExternalBattery ->
44;
Enc2@element =:= dualFuelLngDiesel ->
45;
Enc2@element =:= electricExternal ->
46;
Enc2@element =:= biogas ->
47;
Enc2@element =:= bioDiesel ->
48;
Enc2@element =:= bioPetrol ->
49;
Enc2@element =:= bivalentPetrolBiogas ->
50;
Enc2@element =:= combinedBiogasElectricEngine ->
51;
Enc2@element =:= dualFuelCngDiesel ->
52;
Enc2@element =:= other ->
255;
Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute descriptiveCharacteristics(3) with type INTEGER
Enc4@element = element(4, Val),
if Enc4@element =:= noEntry ->
0;
Enc4@element bsr 8 =:= 0 ->
Enc4@element;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end|begin
%% attribute futureCharacteristics(4) with type INTEGER
Enc6@element = element(5, Val),
if Enc6@element =:= noEntry ->
[0];
Enc6@element =:= airSuspension ->
[1];
Enc6@element bsr 8 =:= 0 ->
[Enc6@element];
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end].


dec_VehicleSpecificCharacteristics(Bytes) ->

%% attribute environmentalCharacteristics(1) with type EnvironmentalCharacteristics
{Term1,Bytes1} = dec_EnvironmentalCharacteristics(Bytes),

%% attribute engineCharacteristics(2) with type INTEGER
{Term2,Bytes2} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes1,
V1@Int2 = case V1@V0 of
0 -> noEntry;
1 -> noEngine;
2 -> petrolUnleaded;
3 -> petrolLeaded;
4 -> diesel;
5 -> lpg;
6 -> battery;
7 -> solar;
8 -> hybrid;
9 -> hydrogen;
10 -> multiFuel;
11 -> bivalentPetrolLpg;
12 -> bivalentPetrolCng;
13 -> combinedPetrolElectric;
14 -> cng;
15 -> lng;
16 -> combinedDieselElectric;
17 -> combinedHydrogenElectric;
18 -> bivalentHydrogenPetrol;
19 -> bivalentHydrogenPetrolElectricEngine;
20 -> fuelCellHydrogen;
21 -> fuelCellPetrol;
22 -> fuelCellMethanol;
23 -> fuelCellEthanol;
24 -> fuelCellDiesel;
25 -> combinedMultiFuelElectricEngine;
26 -> combinedCngElectricEngine;
27 -> combinedLngElectricEngine;
28 -> petrolEthanol;
29 -> combinedLpgElectricEngine;
30 -> hybridPetrolExternalBattery;
31 -> hybridDieselExternalBattery;
32 -> hybridLpgExternalBattery;
33 -> hybridHydrogenExternalBattery;
34 -> hybridMultiFuelExternalBattery;
35 -> hybridCngExternalBattery;
36 -> hybridLngExternalBattery;
37 -> hybridBivalentHydrogenPetrolExternalBattery;
38 -> hydrogenCng;
39 -> hydrogenLng;
40 -> hybridHydrogenCngExternalBattery;
41 -> hybridHydrogenLngExternalBattery;
42 -> ethanol;
43 -> hybridFuelCellHydrogen;
44 -> hybridFuelCellHydrogenExternalBattery;
45 -> dualFuelLngDiesel;
46 -> electricExternal;
47 -> biogas;
48 -> bioDiesel;
49 -> bioPetrol;
50 -> bivalentPetrolBiogas;
51 -> combinedBiogasElectricEngine;
52 -> dualFuelCngDiesel;
255 -> other;
_ -> V1@V0
end,
{V1@Int2,V1@Buf1}
end,

%% attribute descriptiveCharacteristics(3) with type INTEGER
{Term3,Bytes3} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes2,
V2@Int2 = case V2@V0 of
0 -> noEntry;
_ -> V2@V0
end,
{V2@Int2,V2@Buf1}
end,

%% attribute futureCharacteristics(4) with type INTEGER
{Term4,Bytes4} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes3,
V3@Int2 = case V3@V0 of
0 -> noEntry;
1 -> airSuspension;
_ -> V3@V0
end,
{V3@Int2,V3@Buf1}
end,
Res1 = {'VehicleSpecificCharacteristics',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.

enc_AggregatedSingleTariffClassSession(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute timePeriodCovered(1) with type Period
Enc10@element = element(2, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
true ->
enc_Period(Enc10@element)
end
end,
begin
%% attribute currentTariffClass(2) with type TariffClassDescription
Enc12@element = element(3, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
enc_TariffClassDescription(Enc12@element)
end
end,
begin
%% attribute vehicleDescription(3) with type VehicleDescription
Enc14@element = element(4, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
true ->
enc_VehicleDescription(Enc14@element)
end
end,
begin
%% attribute totalDistanceCovered(4) with type Distance
Enc16@element = element(5, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
true ->
enc_Distance(Enc16@element)
end
end,
begin
%% attribute numberOfDetectedEvents(5) with type INTEGER
Enc18@element = element(6, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
Enc18@element bsr 16 =:= 0 ->
<<Enc18@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc18@element}}})
end
end,
begin
%% attribute obeStatus(6) with type INTEGER
Enc21@element = element(7, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
Enc21@element bsr 8 =:= 0 ->
Enc21@element;
true ->
exit({error,{asn1,{illegal_integer,Enc21@element}}})
end
end,
begin
%% attribute feeExclVat(7) with type PaymentFee
Enc24@element = element(8, Val),
if Enc24@element =:= asn1_NOVALUE ->
[];
true ->
enc_PaymentFee(Enc24@element)
end
end|begin
%% attribute sumVat(8) with type PaymentFee
Enc26@element = element(9, Val),
if Enc26@element =:= asn1_NOVALUE ->
[];
true ->
enc_PaymentFee(Enc26@element)
end
end].


dec_AggregatedSingleTariffClassSession(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute timePeriodCovered(1) with type Period
{Term1,Bytes3} = case (Opt bsr 7) band 1 of
1 ->
dec_Period(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute currentTariffClass(2) with type TariffClassDescription
{Term2,Bytes4} = case (Opt bsr 6) band 1 of
1 ->
dec_TariffClassDescription(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute vehicleDescription(3) with type VehicleDescription
{Term3,Bytes5} = case (Opt bsr 5) band 1 of
1 ->
dec_VehicleDescription(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute totalDistanceCovered(4) with type Distance
{Term4,Bytes6} = case (Opt bsr 4) band 1 of
1 ->
dec_Distance(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute numberOfDetectedEvents(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes6,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute obeStatus(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes7,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute feeExclVat(7) with type PaymentFee
{Term7,Bytes9} = case (Opt bsr 1) band 1 of
1 ->
dec_PaymentFee(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute sumVat(8) with type PaymentFee
{Term8,Bytes10} = case Opt band 1 of
1 ->
dec_PaymentFee(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% Extensions
{Extensions,Bytes11} = case Ext of
0 -> {<<>>,Bytes10};
1 ->
{V5@V0,V5@Buf1} = case Bytes10 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes12= skipextensions(Bytes11, 1, Extensions),
Res1 = {'AggregatedSingleTariffClassSession',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8},
{Res1,Bytes12}.

enc_DetectedChargeObject(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(7, Val),
Enc6@element = element(8, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(9, Val),
Enc8@element = element(10, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute chargeObjectId(1) with type ChargeObjectId
Enc11@element = element(2, Val),
enc_ChargeObjectId(Enc11@element)
end,
begin
%% attribute subObjectNumber(2) with type INTEGER
Enc12@element = element(3, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
Enc12@element bsr 32 =:= 0 ->
<<Enc12@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end,
begin
%% attribute timeWhenUsed(3) with type GeneralizedTime
Enc15@element = element(4, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc16@len = length(Enc15@element),
Enc16@bin = encode_chars(Enc15@element, 7),
if Enc16@len < 128 ->
[Enc16@len|Enc16@bin];
Enc16@len < 16384 ->
[<<2:2,Enc16@len:14>>|Enc16@bin];
true ->
encode_fragmented(Enc16@bin, 7)
end
end
end
end,
begin
%% attribute mileageWhenUsed(4) with type Distance
Enc18@element = element(5, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
true ->
enc_Distance(Enc18@element)
end
end,
begin
%% attribute currentTariffClass(5) with type TariffClassDescription
Enc20@element = element(6, Val),
if Enc20@element =:= asn1_NOVALUE ->
[];
true ->
enc_TariffClassDescription(Enc20@element)
end
end,
begin
%% attribute vehicleDescription(6) with type VehicleDescription
Enc22@element = element(7, Val),
if Enc22@element =:= asn1_NOVALUE ->
[];
true ->
enc_VehicleDescription(Enc22@element)
end
end,
begin
%% attribute obeStatus(7) with type INTEGER
Enc24@element = element(8, Val),
if Enc24@element =:= asn1_NOVALUE ->
[];
Enc24@element bsr 8 =:= 0 ->
Enc24@element;
true ->
exit({error,{asn1,{illegal_integer,Enc24@element}}})
end
end,
begin
%% attribute feeExclVat(8) with type PaymentFee
Enc27@element = element(9, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
enc_PaymentFee(Enc27@element)
end
end,
begin
%% attribute sumVat(9) with type PaymentFee
Enc29@element = element(10, Val),
if Enc29@element =:= asn1_NOVALUE ->
[];
true ->
enc_PaymentFee(Enc29@element)
end
end|begin
%% attribute chargeObjDetectionMode(10) with type INTEGER
Enc31@element = element(11, Val),
if Enc31@element =:= asn1_NOVALUE ->
[];
Enc31@element =:= measured ->
[0];
Enc31@element =:= inferred ->
[1];
Enc31@element =:= lac ->
[2];
Enc31@element bsr 8 =:= 0 ->
[Enc31@element];
true ->
exit({error,{asn1,{illegal_integer,Enc31@element}}})
end
end].


dec_DetectedChargeObject(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:9,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute chargeObjectId(1) with type ChargeObjectId
{Term1,Bytes3} = dec_ChargeObjectId(Bytes2),

%% attribute subObjectNumber(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V3@V0:32,V3@Buf1/bitstring>> = Bytes3,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute timeWhenUsed(3) with type GeneralizedTime
{Term3,Bytes5} = case (Opt bsr 7) band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes4 of
<<0:1,V4@V3:7,V4@V5:V4@V3/binary-unit:7,V4@Buf6/bitstring>> ->
{V4@V5,V4@Buf6};
<<1:1,0:1,V4@V4:14,V4@V6:V4@V4/binary-unit:7,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,1:1,V4@V4:6,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7}  = decode_fragmented(V4@V4, V4@Buf5, 7),
{V4@V6,V4@Buf7}
end,
{V4@V8,V4@Buf9}  = {decode_chars(V4@V0, 7),V4@Buf1},
{V4@V8,V4@Buf9}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute mileageWhenUsed(4) with type Distance
{Term4,Bytes6} = case (Opt bsr 6) band 1 of
1 ->
dec_Distance(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute currentTariffClass(5) with type TariffClassDescription
{Term5,Bytes7} = case (Opt bsr 5) band 1 of
1 ->
dec_TariffClassDescription(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute vehicleDescription(6) with type VehicleDescription
{Term6,Bytes8} = case (Opt bsr 4) band 1 of
1 ->
dec_VehicleDescription(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute obeStatus(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes8,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute feeExclVat(8) with type PaymentFee
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
dec_PaymentFee(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute sumVat(9) with type PaymentFee
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
dec_PaymentFee(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute chargeObjDetectionMode(10) with type INTEGER
{Term10,Bytes12} = case Opt band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes11,
V6@Int2 = case V6@V0 of
0 -> measured;
1 -> inferred;
2 -> lac;
_ -> V6@V0
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V7@V0,V7@Buf1} = case Bytes12 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = {'DetectedChargeObject',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10},
{Res1,Bytes14}.

enc_TariffClassDescription(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_DEFAULT ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
Enc1@element =:= 0 ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute tariffClassId(1) with type INTEGER
Enc6@element = element(2, Val),
if Enc6@element =:= asn1_DEFAULT ->
[];
Enc6@element =:= 0 ->
[];
Enc6@element bsr 32 =:= 0 ->
<<Enc6@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end,
begin
%% attribute localVehicleClassId(2) with type INTEGER
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
Enc9@element bsr 16 =:= 0 ->
<<Enc9@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end,
begin
%% attribute timeClassId(3) with type INTEGER
Enc12@element = element(4, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
Enc12@element bsr 16 =:= 0 ->
<<Enc12@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end,
begin
%% attribute locationClassId(4) with type INTEGER
Enc15@element = element(5, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
Enc15@element bsr 32 =:= 0 ->
<<Enc15@element:32>>;
true ->
exit({error,{asn1,{illegal_integer,Enc15@element}}})
end
end|begin
%% attribute userClassId(5) with type INTEGER
Enc18@element = element(6, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
Enc18@element bsr 8 =:= 0 ->
[Enc18@element];
true ->
exit({error,{asn1,{illegal_integer,Enc18@element}}})
end
end].


dec_TariffClassDescription(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tariffClassId(1) with type INTEGER
{Term1,Bytes2} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V2@V0:32,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end;
0 ->
{0,Bytes1}
end,

%% attribute localVehicleClassId(2) with type INTEGER
{Term2,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute timeClassId(3) with type INTEGER
{Term3,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute locationClassId(4) with type INTEGER
{Term4,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:32,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute userClassId(5) with type INTEGER
{Term5,Bytes6} = case Opt band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,
Res1 = {'TariffClassDescription',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes6}.

enc_VehicleDescription(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc11@element = element(12, Val),
Enc12@element = element(13, Val),
if Enc11@element =:= asn1_NOVALUE ->
if Enc12@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc12@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc13@element = element(14, Val),
Enc14@element = element(15, Val),
if Enc13@element =:= asn1_NOVALUE ->
if Enc14@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc14@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc15@element = element(16, Val),
Enc16@element = element(17, Val),
if Enc15@element =:= asn1_NOVALUE ->
if Enc16@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc16@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc17@element = element(18, Val),
if Enc17@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute vehicleLPNr(1) with type Lpn
Enc19@element = element(2, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
enc_Lpn(Enc19@element)
end
end,
begin
%% attribute axles(2) with type VehicleAxles
Enc21@element = element(3, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
enc_VehicleAxles(Enc21@element)
end
end,
begin
%% attribute class(3) with type INTEGER
Enc23@element = element(4, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
Enc23@element bsr 8 =:= 0 ->
Enc23@element;
true ->
exit({error,{asn1,{illegal_integer,Enc23@element}}})
end
end,
begin
%% attribute dimensions(4) with type VehicleDimensions
Enc26@element = element(5, Val),
if Enc26@element =:= asn1_NOVALUE ->
[];
true ->
enc_VehicleDimensions(Enc26@element)
end
end,
begin
%% attribute specificCharacteristics(5) with type VehicleSpecificCharacteristics
Enc28@element = element(6, Val),
if Enc28@element =:= asn1_NOVALUE ->
[];
true ->
enc_VehicleSpecificCharacteristics(Enc28@element)
end
end,
begin
%% attribute ladenWeight(6) with type INTEGER
Enc30@element = element(7, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
Enc30@element bsr 16 =:= 0 ->
<<Enc30@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc30@element}}})
end
end,
begin
%% attribute weightLimits(7) with type VehicleWeightLimits
Enc33@element = element(8, Val),
if Enc33@element =:= asn1_NOVALUE ->
[];
true ->
enc_VehicleWeightLimits(Enc33@element)
end
end,
begin
%% attribute trailerCharacteristics(8) with type TrailerCharacteristics
Enc35@element = element(9, Val),
if Enc35@element =:= asn1_NOVALUE ->
[];
true ->
enc_TrailerCharacteristics(Enc35@element)
end
end,
begin
%% attribute vehicleCurrentMaxTrainWeight(9) with type INTEGER
Enc37@element = element(10, Val),
if Enc37@element =:= asn1_NOVALUE ->
[];
Enc37@element bsr 16 =:= 0 ->
<<Enc37@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc37@element}}})
end
end,
begin
%% attribute actualNumberOfPassengers(10) with type INTEGER
Enc40@element = element(11, Val),
if Enc40@element =:= asn1_NOVALUE ->
[];
Enc40@element bsr 8 =:= 0 ->
Enc40@element;
true ->
exit({error,{asn1,{illegal_integer,Enc40@element}}})
end
end,
begin
%% attribute axleWeightLimits(11) with type AxleWeightLimits
Enc43@element = element(12, Val),
if Enc43@element =:= asn1_NOVALUE ->
[];
true ->
enc_AxleWeightLimits(Enc43@element)
end
end,
begin
%% attribute dieselEmissionValues(12) with type DieselEmissionValues
Enc45@element = element(13, Val),
if Enc45@element =:= asn1_NOVALUE ->
[];
true ->
enc_DieselEmissionValues(Enc45@element)
end
end,
begin
%% attribute driverCharacteristics(13) with type DriverCharacteristics
Enc47@element = element(14, Val),
if Enc47@element =:= asn1_NOVALUE ->
[];
true ->
enc_DriverCharacteristics(Enc47@element)
end
end,
begin
%% attribute engineDetails(14) with type EngineDetails
Enc49@element = element(15, Val),
if Enc49@element =:= asn1_NOVALUE ->
[];
true ->
enc_EngineDetails(Enc49@element)
end
end,
begin
%% attribute exhaustEmissionValues(15) with type ExhaustEmissionValues
Enc51@element = element(16, Val),
if Enc51@element =:= asn1_NOVALUE ->
[];
true ->
enc_ExhaustEmissionValues(Enc51@element)
end
end,
begin
%% attribute passengerCapacity(16) with type PassengerCapacity
Enc53@element = element(17, Val),
if Enc53@element =:= asn1_NOVALUE ->
[];
true ->
enc_PassengerCapacity(Enc53@element)
end
end|begin
%% attribute soundLevel(17) with type SoundLevel
Enc55@element = element(18, Val),
if Enc55@element =:= asn1_NOVALUE ->
[];
true ->
enc_SoundLevel(Enc55@element)
end
end].


dec_VehicleDescription(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:17,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute vehicleLPNr(1) with type Lpn
{Term1,Bytes3} = case (Opt bsr 16) band 1 of
1 ->
dec_Lpn(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute axles(2) with type VehicleAxles
{Term2,Bytes4} = case (Opt bsr 15) band 1 of
1 ->
dec_VehicleAxles(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute class(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 14) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes4,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute dimensions(4) with type VehicleDimensions
{Term4,Bytes6} = case (Opt bsr 13) band 1 of
1 ->
dec_VehicleDimensions(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute specificCharacteristics(5) with type VehicleSpecificCharacteristics
{Term5,Bytes7} = case (Opt bsr 12) band 1 of
1 ->
dec_VehicleSpecificCharacteristics(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute ladenWeight(6) with type INTEGER
{Term6,Bytes8} = case (Opt bsr 11) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes7,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute weightLimits(7) with type VehicleWeightLimits
{Term7,Bytes9} = case (Opt bsr 10) band 1 of
1 ->
dec_VehicleWeightLimits(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute trailerCharacteristics(8) with type TrailerCharacteristics
{Term8,Bytes10} = case (Opt bsr 9) band 1 of
1 ->
dec_TrailerCharacteristics(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute vehicleCurrentMaxTrainWeight(9) with type INTEGER
{Term9,Bytes11} = case (Opt bsr 8) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes10,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute actualNumberOfPassengers(10) with type INTEGER
{Term10,Bytes12} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes11,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute axleWeightLimits(11) with type AxleWeightLimits
{Term11,Bytes13} = case (Opt bsr 6) band 1 of
1 ->
dec_AxleWeightLimits(Bytes12);
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute dieselEmissionValues(12) with type DieselEmissionValues
{Term12,Bytes14} = case (Opt bsr 5) band 1 of
1 ->
dec_DieselEmissionValues(Bytes13);
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% attribute driverCharacteristics(13) with type DriverCharacteristics
{Term13,Bytes15} = case (Opt bsr 4) band 1 of
1 ->
dec_DriverCharacteristics(Bytes14);
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% attribute engineDetails(14) with type EngineDetails
{Term14,Bytes16} = case (Opt bsr 3) band 1 of
1 ->
dec_EngineDetails(Bytes15);
0 ->
{asn1_NOVALUE,Bytes15}
end,

%% attribute exhaustEmissionValues(15) with type ExhaustEmissionValues
{Term15,Bytes17} = case (Opt bsr 2) band 1 of
1 ->
dec_ExhaustEmissionValues(Bytes16);
0 ->
{asn1_NOVALUE,Bytes16}
end,

%% attribute passengerCapacity(16) with type PassengerCapacity
{Term16,Bytes18} = case (Opt bsr 1) band 1 of
1 ->
dec_PassengerCapacity(Bytes17);
0 ->
{asn1_NOVALUE,Bytes17}
end,

%% attribute soundLevel(17) with type SoundLevel
{Term17,Bytes19} = case Opt band 1 of
1 ->
dec_SoundLevel(Bytes18);
0 ->
{asn1_NOVALUE,Bytes18}
end,

%% Extensions
{Extensions,Bytes20} = case Ext of
0 -> {<<>>,Bytes19};
1 ->
{V7@V0,V7@Buf1} = case Bytes19 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes21= skipextensions(Bytes20, 1, Extensions),
Res1 = {'VehicleDescription',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13,Term14,Term15,Term16,Term17},
{Res1,Bytes21}.

typeinfo('Int1Unsigned') ->
  {'INTEGER',{0,255}};
typeinfo('Int1Signed') ->
  {'INTEGER',{-128,127}};
typeinfo('Int2Unsigned') ->
  {'INTEGER',{0,65535}};
typeinfo('Int2Signed') ->
  {'INTEGER',{-32768,32767}};
typeinfo('Int3Unsigned') ->
  {'INTEGER',{0,16777215}};
typeinfo('Int4Unsigned') ->
  {'INTEGER',{0,4294967295}};
typeinfo('Int4Signed') ->
  {'INTEGER',{-2147483648,2147483647}};
typeinfo('Int8Unsigned') ->
  {'INTEGER',{0,9223372036854775807}};
typeinfo('Int8Signed') ->
  {'INTEGER',{-9223372036854775808,9223372036854775807}};
typeinfo('AccountStatus') ->
  {{'INTEGER_NNL',[{ok,0},{low,1},{empty,2},{negative,3}]},{0,255}};
typeinfo('ActualNumberOfPassengers') ->
  {'INTEGER',{0,255}};
typeinfo('Altitude') ->
  {'INTEGER',{-32768,32767}};
typeinfo('CO2EmissionValue') ->
  {'INTEGER',{0,65535}};
typeinfo('ContractAuthenticator') ->
  octet_string;
typeinfo('ContractSerialNumber') ->
  {'INTEGER',{0,4294967295}};
typeinfo('CopValue') ->
  {{'INTEGER_NNL',[{noEntry,0},{co2class1,1},{co2class2,2},{co2class3,3},{co2class4,4},{co2class5,5},{co2class6,6},{co2class7,7}]},{0,15}};
typeinfo('CountryCode') ->
  {bit_string,10};
typeinfo('DescriptiveCharacteristics') ->
  {{'INTEGER_NNL',[{noEntry,0}]},{0,255}};
typeinfo('DetectionMode') ->
  {{'INTEGER_NNL',[{measured,0},{inferred,1},{lac,2}]},{0,255}};
typeinfo('EmissionUnit') ->
  {{'INTEGER_NNL',[{mgPerKm,0},{mgPerKwh,1}]},{0,1}};
typeinfo('EngineCharacteristics') ->
  {{'INTEGER_NNL',[{noEntry,0},{noEngine,1},{petrolUnleaded,2},{petrolLeaded,3},{diesel,4},{lpg,5},{battery,6},{solar,7},{hybrid,8},{hydrogen,9},{multiFuel,10},{bivalentPetrolLpg,11},{bivalentPetrolCng,12},{combinedPetrolElectric,13},{cng,14},{lng,15},{combinedDieselElectric,16},{combinedHydrogenElectric,17},{bivalentHydrogenPetrol,18},{bivalentHydrogenPetrolElectricEngine,19},{fuelCellHydrogen,20},{fuelCellPetrol,21},{fuelCellMethanol,22},{fuelCellEthanol,23},{fuelCellDiesel,24},{combinedMultiFuelElectricEngine,25},{combinedCngElectricEngine,26},{combinedLngElectricEngine,27},{petrolEthanol,28},{combinedLpgElectricEngine,29},{hybridPetrolExternalBattery,30},{hybridDieselExternalBattery,31},{hybridLpgExternalBattery,32},{hybridHydrogenExternalBattery,33},{hybridMultiFuelExternalBattery,34},{hybridCngExternalBattery,35},{hybridLngExternalBattery,36},{hybridBivalentHydrogenPetrolExternalBattery,37},{hydrogenCng,38},{hydrogenLng,39},{hybridHydrogenCngExternalBattery,40},{hybridHydrogenLngExternalBattery,41},{ethanol,42},{hybridFuelCellHydrogen,43},{hybridFuelCellHydrogenExternalBattery,44},{dualFuelLngDiesel,45},{electricExternal,46},{biogas,47},{bioDiesel,48},{bioPetrol,49},{bivalentPetrolBiogas,50},{combinedBiogasElectricEngine,51},{dualFuelCngDiesel,52},{other,255}]},{0,255}};
typeinfo('EquipmentIccId') ->
  octet_string;
typeinfo('EquipmentObuId') ->
  octet_string;
typeinfo('EquipmentStatus') ->
  {bit_string,16};
typeinfo('EuroValue') ->
  {{'INTEGER_NNL',[{noEntry,0},{euro1,1},{euro2,2},{euro3,3},{euro4,4},{euro5,5},{euro6,6},{euro7,7},{eev,15}]},{0,15}};
typeinfo('FutureCharacteristics') ->
  {{'INTEGER_NNL',[{noEntry,0},{airSuspension,1}]},{0,255}};
typeinfo('IssuerIdentifier') ->
  {'INTEGER',{0,16383}};
typeinfo('Latitude') ->
  {'INTEGER',{-2147483648,2147483647}};
typeinfo('DistanceUnit') ->
  {{'INTEGER_NNL',[{kilometres,0},{miles,1},{metres,2},{yards,3},{feet,4},{decimetres,5},{quartermetres,6},{centimeters,7},{millimeters,8}]},{0,255}};
typeinfo('LocalVehicleClassId') ->
  {'INTEGER',{0,65535}};
typeinfo('LocationClassId') ->
  {'INTEGER',{0,4294967295}};
typeinfo('Longitude') ->
  {'INTEGER',{-2147483648,2147483647}};
typeinfo('PaymentSecurityData') ->
  octet_string;
typeinfo('PayUnit') ->
  octet_string;
typeinfo('PersonalAccountNumber') ->
  octet_string;
typeinfo('ReceiptAuthenticator') ->
  octet_string;
typeinfo('ReceiptDistance') ->
  {'INTEGER',{0,16777215}};
typeinfo('ResultFin') ->
  octet_string;
typeinfo('ReceiptIccId') ->
  octet_string;
typeinfo('ReceiptObuId') ->
  octet_string;
typeinfo('ResultOp') ->
  {{'INTEGER_NNL',[{correctTransaction,0},{obeStatusNotAccepted,1},{equipmentStatusNotAccepted,2},{contractNotInWhiteList,3},{contractIdentifierInBlackList,4},{contractIdentifierNotCorrect,5},{expiredContract,6},{contractRestrictionsNotFulfilled,7},{claimedVehicleCharacteristicsNotValid,8},{vehicleClassAuthenticationFailed,9},{entryVehicleClassDifferentFromExitVehicleClass,10},{entryReceiptMissing,11},{entryReceiptNotValid,12},{entryTollStationNotValid,13},{equipmentNotCertified,14},{timeDifference,15},{accessCredentialsNotAccepted,16},{contractAuthenticatorNotAccepted,17},{receiptAuthenticatorNotAccepted,18},{claimedVehicleCharacteristicsMissing,19},{paymentMeansNotAccepted,20},{paymentAuthenticatorNotAccepted,21},{paymentMeansInBlackList,22},{paymentMeansNotCorrect,23},{expiredPaymentMeans,24},{paymentMeansRestrictionsNotFulfilled,25}]},{0,255}};
typeinfo('ReceiptServiceSerialNumber') ->
  {'INTEGER',{0,16777215}};
typeinfo('ReceiptText') ->
  octet_string;
typeinfo('StationType') ->
  {{'INTEGER_NNL',[{unspecified,0},{closedEntryWithPayment,1},{closedEntryWithoutPayment,2},{closedTransit,3},{closedExit,4},{closedCredit,5},{mixed,6},{passage,7},{checkpoint,8},{reload,9},{reservedForFutureCENUse1,10},{reservedForFutureCENUse2,11},{reservedForFutureCENUse3,12},{reservedForFutureCENUse4,13},{privateUse5,14},{privateUse6,15}]},{0,15}};
typeinfo('TariffClassId') ->
  {'INTEGER',{0,4294967295}};
typeinfo('Time') ->
  {'INTEGER',{0,4294967295}};
typeinfo('TimeClassId') ->
  {'INTEGER',{0,65535}};
typeinfo('TimeUnit') ->
  {{'INTEGER_NNL',[{seconds,0},{minutes,1},{hours,2},{days,3},{months,4}]},{0,255}};
typeinfo('TrailerType') ->
  {{'INTEGER_NNL',[{notPresent,0},{trailer,1},{semitrailer,2}]},{0,31}};
typeinfo('TyreConfiguration') ->
  {{'INTEGER_NNL',[{notSpecified,0},{singleTyre,1},{dualTyres,2},{reservedForUse,3}]},{0,3}};
typeinfo('UserClassId') ->
  {'INTEGER',{0,255}};
typeinfo('VehicleAuthenticator') ->
  octet_string;
typeinfo('VehicleClass') ->
  {'INTEGER',{0,255}};
typeinfo('VehicleCurrentMaxTrainWeight') ->
  {'INTEGER',{0,65535}};
typeinfo('VehicleTotalDistance') ->
  {'INTEGER',{0,4294967295}};
typeinfo('VehicleWeightLaden') ->
  {'INTEGER',{0,65535}};
typeinfo('Weekday') ->
  {{'INTEGER_NNL',[{reserved,0},{monday,1},{tuesday,2},{wednesday,3},{thursday,4},{friday,5},{saturday,6},{sunday,7}]},{0,7}};
typeinfo('AbsolutePosition2d') ->
  {sequence,'AbsolutePosition2d',2,[{<<103,110,115,115,76,111,110>>,{'INTEGER',{-2147483648,2147483647}},mandatory},{<<103,110,115,115,76,97,116>>,{'INTEGER',{-2147483648,2147483647}},mandatory}]};
typeinfo('AbsolutePosition3d') ->
  {sequence,'AbsolutePosition3d',3,[{<<108,111,110,103,105,116,117,100,101>>,{'INTEGER',{-2147483648,2147483647}},mandatory},{<<108,97,116,105,116,117,100,101>>,{'INTEGER',{-2147483648,2147483647}},mandatory},{<<97,108,116,105,116,117,100,101>>,{'INTEGER',{-32768,32767}},'OPTIONAL'}]};
typeinfo('AxleWeightLimit') ->
  {sequence,'AxleWeightLimit',2,[{<<97,120,108,101,78,117,109,98,101,114>>,{'INTEGER',{0,255}},mandatory},{<<109,97,120,76,97,100,101,110,87,101,105,103,104,116,79,110,65,120,108,101>>,{'INTEGER',{0,65535}},mandatory}]};
typeinfo('AxleWeightLimits') ->
  {sequence,'AxleWeightLimits',5,[{<<109,97,120,76,97,100,101,110,119,101,105,103,104,116,79,110,65,120,108,101,49>>,{'INTEGER',{0,65535}},mandatory},{<<109,97,120,76,97,100,101,110,119,101,105,103,104,116,79,110,65,120,108,101,50>>,{'INTEGER',{0,65535}},mandatory},{<<109,97,120,76,97,100,101,110,119,101,105,103,104,116,79,110,65,120,108,101,51>>,{'INTEGER',{0,65535}},mandatory},{<<109,97,120,76,97,100,101,110,119,101,105,103,104,116,79,110,65,120,108,101,52>>,{'INTEGER',{0,65535}},mandatory},{<<109,97,120,76,97,100,101,110,119,101,105,103,104,116,79,110,65,120,108,101,53>>,{'INTEGER',{0,65535}},mandatory}]};
typeinfo('DateCompact') ->
  {sequence,'DateCompact',3,[{<<121,101,97,114>>,{'INTEGER',{1990,2117}},mandatory},{<<109,111,110,116,104>>,{'INTEGER',{1,12}},mandatory},{<<100,97,121>>,{'INTEGER',{1,31}},mandatory}]};
typeinfo('DieselEmissionValues') ->
  {sequence,'DieselEmissionValues',2,[{<<112,97,114,116,105,99,117,108,97,116,101>>,{typeinfo,{'EfcDataDictionary','Particulate'}},mandatory},{<<97,98,115,111,114,112,116,105,111,110,67,111,101,102,102>>,{'INTEGER',{0,65535}},mandatory}]};
typeinfo('DriverCharacteristics') ->
  {sequence,'DriverCharacteristics',2,[{<<100,114,105,118,101,114,67,108,97,115,115>>,{'INTEGER',{0,255}},mandatory},{<<116,114,105,112,80,117,114,112,111,115,101>>,{'INTEGER',{0,255}},mandatory}]};
typeinfo('Distance') ->
  {sequence,'Distance',2,[{<<100,105,115,116,97,110,99,101,86,97,108,117,101>>,{'INTEGER',{0,4294967295}},mandatory},{<<100,105,115,116,97,110,99,101,85,110,105,116>>,{{'INTEGER_NNL',[{kilometres,0},{miles,1},{metres,2},{yards,3},{feet,4},{decimetres,5},{quartermetres,6},{centimeters,7},{millimeters,8}]},{0,255}},{'DEFAULT',0}}]};
typeinfo('Duration') ->
  {sequence,'Duration',2,[{<<100,117,114,97,116,105,111,110,86,97,108,117,101>>,{'INTEGER',{0,4294967295}},mandatory},{<<116,105,109,101,85,110,105,116>>,{{'INTEGER_NNL',[{seconds,0},{minutes,1},{hours,2},{days,3},{months,4}]},{0,255}},{'DEFAULT',0}}]};
typeinfo('EngineDetails') ->
  {sequence,'EngineDetails',2,[{<<101,110,103,105,110,101,67,97,112,97,99,105,116,121>>,{'INTEGER',{0,65535}},mandatory},{<<101,110,103,105,110,101,80,111,119,101,114>>,{'INTEGER',{0,65535}},mandatory}]};
typeinfo('ExhaustEmissionValues') ->
  {sequence,'ExhaustEmissionValues',5,[{<<117,110,105,116,84,121,112,101>>,{{'INTEGER_NNL',[{mgPerKm,0},{mgPerKwh,1}]},{0,1}},mandatory},{<<101,109,105,115,115,105,111,110,67,111>>,{'INTEGER',{0,32767}},mandatory},{<<101,109,105,115,115,105,111,110,72,99>>,{'INTEGER',{0,65535}},mandatory},{<<101,109,105,115,115,105,111,110,78,111,120>>,{'INTEGER',{0,65535}},mandatory},{<<101,109,105,115,115,105,111,110,72,99,78,111,120>>,{'INTEGER',{0,65535}},mandatory}]};
typeinfo('NumberOfAxles') ->
  {sequence,'NumberOfAxles',2,[{<<116,114,97,105,108,101,114,65,120,108,101,115>>,{'INTEGER',{0,7}},mandatory},{<<116,114,97,99,116,111,114,65,120,108,101,115>>,{'INTEGER',{0,7}},mandatory}]};
typeinfo('ObeId') ->
  {sequence,'ObeId',2,[{<<109,97,110,117,102,97,99,116,117,114,101,114,73,100>>,{'INTEGER',{0,65535}},mandatory},{<<101,113,117,105,112,109,101,110,116,79,98,117,73,100>>,octet_string,mandatory}]};
typeinfo('Particulate') ->
  {sequence,'Particulate',2,[{<<117,110,105,116,84,121,112,101>>,{{'INTEGER_NNL',[{mgPerKm,0},{mgPerKwh,1}]},{0,1}},mandatory},{<<118,97,108,117,101>>,{'INTEGER',{0,32767}},mandatory}]};
typeinfo('PassengerCapacity') ->
  {sequence,'PassengerCapacity',2,[{<<110,117,109,98,101,114,79,102,83,101,97,116,115>>,{'INTEGER',{0,255}},mandatory},{<<110,117,109,98,101,114,79,102,83,116,97,110,100,105,110,103,80,108,97,99,101,115>>,{'INTEGER',{0,255}},mandatory}]};
typeinfo('PaymentFee') ->
  {sequence,'PaymentFee',2,[{<<112,97,121,109,101,110,116,70,101,101,65,109,111,117,110,116>>,{'INTEGER',{0,65535}},mandatory},{<<112,97,121,109,101,110,116,70,101,101,85,110,105,116>>,octet_string,mandatory}]};
typeinfo('Period') ->
  {sequence,'Period',2,[{<<98,101,103,105,110,79,102,80,101,114,105,111,100>>,string,mandatory},{<<101,110,100,79,102,80,101,114,105,111,100>>,string,mandatory}]};
typeinfo('Provider') ->
  {sequence,'Provider',2,[{<<99,111,117,110,116,114,121,67,111,100,101>>,{bit_string,10},mandatory},{<<112,114,111,118,105,100,101,114,73,100,101,110,116,105,102,105,101,114>>,{'INTEGER',{0,16383}},mandatory}]};
typeinfo('RelativePosition3d') ->
  {sequence,'RelativePosition3d',3,[{<<108,111,110,103,105,116,117,100,101>>,{'INTEGER',{-32768,32767}},mandatory},{<<108,97,116,105,116,117,100,101>>,{'INTEGER',{-32768,32767}},mandatory},{<<97,108,116,105,116,117,100,101>>,{'INTEGER',{-32768,32767}},'OPTIONAL'}]};
typeinfo('SessionClass') ->
  {sequence,'SessionClass',2,[{<<115,101,115,115,105,111,110,84,97,114,105,102,102,67,108,97,115,115>>,{'INTEGER',{0,255}},mandatory},{<<115,101,115,115,105,111,110,67,108,97,105,109,101,100,67,108,97,115,115>>,{'INTEGER',{0,255}},mandatory}]};
typeinfo('SessionLocation') ->
  {sequence,'SessionLocation',2,[{<<97,115,99,101,110,100,105,110,103,75,105,108,111,109,101,116,114,97,103,101>>,'BOOLEAN',mandatory},{<<108,97,110,101,67,111,100,101,78,117,109,98,101,114>>,{'INTEGER',{0,127}},mandatory}]};
typeinfo('SignedValue') ->
  {choice,#{<<110,101,103,97,116,105,118,101>> => {'INTEGER',{-8388608,-1}},<<112,111,115,105,116,105,118,101>> => {'INTEGER',{0,8388607}}}};
typeinfo('SoundLevel') ->
  {sequence,'SoundLevel',2,[{<<115,111,117,110,100,83,116,97,116,105,111,110,97,114,121>>,{'INTEGER',{0,255}},mandatory},{<<115,111,117,110,100,68,114,105,118,101,66,121>>,{'INTEGER',{0,255}},mandatory}]};
typeinfo('TimeCompact') ->
  {sequence,'TimeCompact',3,[{<<104,111,117,114,115>>,{'INTEGER',{0,23}},mandatory},{<<109,105,110,115>>,{'INTEGER',{0,59}},mandatory},{<<100,111,117,98,108,101,83,101,99,115>>,{'INTEGER',{0,30}},mandatory}]};
typeinfo('TrailerDetails') ->
  {sequence,'TrailerDetails',2,[{<<116,114,97,105,108,101,114,84,121,112,101>>,{{'INTEGER_NNL',[{notPresent,0},{trailer,1},{semitrailer,2}]},{0,31}},mandatory},{<<116,114,97,105,108,101,114,65,120,108,101,115>>,{'INTEGER',{0,7}},mandatory}]};
typeinfo('AxlesWeightLimits') ->
  {sof,{typeinfo,{'EfcDataDictionary','AxleWeightLimit'}}};
typeinfo('ChargeObjectId') ->
  {sequence,'ChargeObjectId',2,[{<<99,104,97,114,103,101,79,98,106,101,99,116,79,112,101,114,97,116,111,114>>,{typeinfo,{'EfcDataDictionary','Provider'}},'OPTIONAL'},{<<99,104,97,114,103,101,79,98,106,101,99,116,68,101,115,105,103,110,97,116,105,111,110>>,{'INTEGER',{0,4294967295}},mandatory}]};
typeinfo('ContractValidity') ->
  {sequence,'ContractValidity',2,[{<<99,111,110,116,114,97,99,116,82,101,115,116,114,105,99,116,105,111,110,115>>,octet_string,mandatory},{<<99,111,110,116,114,97,99,116,69,120,112,105,114,121,68,97,116,101>>,{typeinfo,{'EfcDataDictionary','DateCompact'}},mandatory}]};
typeinfo('DateAndTime') ->
  {sequence,'DateAndTime',2,[{<<116,105,109,101,68,97,116,101>>,{typeinfo,{'EfcDataDictionary','DateCompact'}},mandatory},{<<116,105,109,101,67,111,109,112,97,99,116>>,{typeinfo,{'EfcDataDictionary','TimeCompact'}},mandatory}]};
typeinfo('EnvironmentalCharacteristics') ->
  {sequence,'EnvironmentalCharacteristics',2,[{<<101,117,114,111,86,97,108,117,101>>,{{'INTEGER_NNL',[{noEntry,0},{euro1,1},{euro2,2},{euro3,3},{euro4,4},{euro5,5},{euro6,6},{euro7,7},{eev,15}]},{0,15}},mandatory},{<<99,111,112,86,97,108,117,101>>,{{'INTEGER_NNL',[{noEntry,0},{co2class1,1},{co2class2,2},{co2class3,3},{co2class4,4},{co2class5,5},{co2class6,6},{co2class7,7}]},{0,15}},mandatory}]};
typeinfo('Lpn') ->
  {sequence,'Lpn',3,[{<<99,111,117,110,116,114,121,67,111,100,101>>,{bit_string,10},mandatory},{<<97,108,112,104,97,98,101,116,73,110,100,105,99,97,116,111,114>>,{'ENUMERATED',#{reservedForUse3 => 15,reservedForUse1 => 13,latinHebrewAlphabet => 8,latinAlphabetNo2 => 2,latinArabicAlphabet => 6,latinAlphabetNo3 => 3,latinCyrillicAlphabet => 5,reservedForUse2 => 14,reservedForUse10 => 22,reservedForUse13 => 25,latinGreekAlphabet => 7,reservedForUse7 => 19,reservedForUse19 => 31,reservedForUse15 => 27,latinAlphabetNo1 => 1,reservedForUse12 => 24,twoOctetBMP => 11,reservedForUse11 => 23,latinAlphabetNo4 => 4,reservedForUse18 => 30,reservedForUse9 => 21,latinAlphabetNo5 => 9,reservedForUse16 => 28,reservedForUse21 => 33,reservedForUse14 => 26,reservedForUse17 => 29,reservedForUse5 => 17,reservedForUse4 => 16,fourOctetCanonical => 12,reservedForUse20 => 32,reservedForUse6 => 18,reservedForUse8 => 20,latinAlphabetNo6 => 10}},mandatory},{<<108,105,99,101,110,99,101,80,108,97,116,101,78,117,109,98,101,114>>,octet_string,mandatory}]};
typeinfo('PaymentMeans') ->
  {sequence,'PaymentMeans',3,[{<<112,101,114,115,111,110,97,108,65,99,99,111,117,110,116,78,117,109,98,101,114>>,octet_string,mandatory},{<<112,97,121,109,101,110,116,77,101,97,110,115,69,120,112,105,114,121,68,97,116,101>>,{typeinfo,{'EfcDataDictionary','DateCompact'}},mandatory},{<<112,97,109,101,110,116,77,101,97,110,115,85,115,97,103,101,67,111,110,116,114,111,108>>,octet_string,mandatory}]};
typeinfo('PaymentMeansBalance') ->
  {typeinfo,{'EfcDataDictionary','SignedValue'}};
typeinfo('Point') ->
  {choice,#{<<97,98,115,111,108,117,116,101,80,111,105,110,116,67,111,111,114,100,105,110,97,116,101,115>> => {typeinfo,{'EfcDataDictionary','AbsolutePosition3d'}},<<112,111,105,110,116,73,100,101,110,116,105,102,105,101,114>> => {'INTEGER',{0,4294967295}},<<114,101,108,97,116,105,118,101,80,111,105,110,116,67,111,111,114,100,105,110,97,116,101,115>> => {typeinfo,{'EfcDataDictionary','RelativePosition3d'}}}};
typeinfo('PurseBalance') ->
  {sequence,'PurseBalance',2,[{<<112,117,114,115,101,86,97,108,117,101>>,{typeinfo,{'EfcDataDictionary','SignedValue'}},mandatory},{<<112,117,114,115,101,85,110,105,116>>,octet_string,mandatory}]};
typeinfo('TrailerCharacteristics') ->
  {sequence,'TrailerCharacteristics',3,[{<<116,114,97,105,108,101,114,68,101,116,97,105,108,115>>,{typeinfo,{'EfcDataDictionary','TrailerDetails'}},mandatory},{<<116,114,97,105,108,101,114,77,97,120,76,97,100,101,110,87,101,105,103,104,116>>,{'INTEGER',{0,65535}},mandatory},{<<116,114,97,105,108,101,114,87,101,105,103,104,116,85,110,108,97,100,101,110>>,{'INTEGER',{0,65535}},mandatory}]};
typeinfo('ValidityOfContract') ->
  {sequence,'ValidityOfContract',2,[{<<105,115,115,117,101,114,82,101,115,116,114,105,99,116,105,111,110,115>>,octet_string,mandatory},{<<99,111,110,116,114,97,99,116,69,120,112,105,114,121,68,97,116,101>>,{typeinfo,{'EfcDataDictionary','DateCompact'}},mandatory}]};
typeinfo('VehicleAxlesNumber') ->
  {sequence,'VehicleAxlesNumber',2,[{<<116,121,114,101,67,111,110,102,105,103,117,114,97,116,105,111,110>>,{{'INTEGER_NNL',[{notSpecified,0},{singleTyre,1},{dualTyres,2},{reservedForUse,3}]},{0,3}},mandatory},{<<110,117,109,98,101,114,79,102,65,120,108,101,115>>,{typeinfo,{'EfcDataDictionary','NumberOfAxles'}},mandatory}]};
typeinfo('VehicleDimensions') ->
  {sequence,'VehicleDimensions',3,[{<<118,101,104,105,99,108,101,76,101,110,103,116,104,79,118,101,114,97,108,108>>,{'INTEGER',{0,255}},mandatory},{<<118,101,104,105,99,108,101,72,101,105,103,116,104,79,118,101,114,97,108,108>>,{'INTEGER',{0,255}},mandatory},{<<118,101,104,105,99,108,101,87,105,100,116,104,79,118,101,114,97,108,108>>,{'INTEGER',{0,255}},mandatory}]};
typeinfo('VehicleWeightLimits') ->
  {sequence,'VehicleWeightLimits',3,[{<<118,101,104,105,99,108,101,77,97,120,76,97,100,101,110,87,101,105,103,104,116>>,{'INTEGER',{0,65535}},mandatory},{<<118,101,104,105,99,108,101,84,114,97,105,110,77,97,120,105,109,117,109,87,101,105,103,104,116>>,{'INTEGER',{0,65535}},mandatory},{<<118,101,104,105,99,108,101,87,101,105,103,104,116,85,110,108,97,100,101,110>>,{'INTEGER',{0,65535}},mandatory}]};
typeinfo('EfcContextMark') ->
  {sequence,'EfcContextMark',3,[{<<99,111,110,116,114,97,99,116,80,114,111,118,105,100,101,114>>,{typeinfo,{'EfcDataDictionary','Provider'}},mandatory},{<<116,121,112,101,79,102,67,111,110,116,114,97,99,116>>,octet_string,mandatory},{<<99,111,110,116,101,120,116,86,101,114,115,105,111,110>>,'INTEGER',mandatory}]};
typeinfo('ReceiptContract') ->
  {sequence,'ReceiptContract',3,[{<<115,101,115,115,105,111,110,67,111,110,116,114,97,99,116,80,114,111,118,105,100,101,114>>,{typeinfo,{'EfcDataDictionary','Provider'}},mandatory},{<<115,101,115,115,105,111,110,84,121,112,101,79,102,67,111,110,116,114,97,99,116>>,octet_string,mandatory},{<<115,101,115,115,105,111,110,67,111,110,116,114,97,99,116,83,101,114,105,97,108,78,117,109,98,101,114>>,{'INTEGER',{0,4294967295}},mandatory}]};
typeinfo('ReceiptData') ->
  {sequence,'ReceiptData',13,[{<<115,101,115,115,105,111,110,84,105,109,101>>,{typeinfo,{'EfcDataDictionary','DateAndTime'}},mandatory},{<<115,101,115,115,105,111,110,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114>>,{typeinfo,{'EfcDataDictionary','Provider'}},mandatory},{<<108,111,99,97,116,105,111,110,79,102,83,116,97,116,105,111,110>>,{'INTEGER',{0,65535}},mandatory},{<<115,101,115,115,105,111,110,76,111,99,97,116,105,111,110>>,{typeinfo,{'EfcDataDictionary','SessionLocation'}},mandatory},{<<115,101,115,115,105,111,110,84,121,112,101>>,{'INTEGER',{0,255}},mandatory},{<<115,101,115,115,105,111,110,82,101,115,117,108,116>>,{{'INTEGER_NNL',[{correctTransaction,0},{obeStatusNotAccepted,1},{equipmentStatusNotAccepted,2},{contractNotInWhiteList,3},{contractIdentifierInBlackList,4},{contractIdentifierNotCorrect,5},{expiredContract,6},{contractRestrictionsNotFulfilled,7},{claimedVehicleCharacteristicsNotValid,8},{vehicleClassAuthenticationFailed,9},{entryVehicleClassDifferentFromExitVehicleClass,10},{entryReceiptMissing,11},{entryReceiptNotValid,12},{entryTollStationNotValid,13},{equipmentNotCertified,14},{timeDifference,15},{accessCredentialsNotAccepted,16},{contractAuthenticatorNotAccepted,17},{receiptAuthenticatorNotAccepted,18},{claimedVehicleCharacteristicsMissing,19},{paymentMeansNotAccepted,20},{paymentAuthenticatorNotAccepted,21},{paymentMeansInBlackList,22},{paymentMeansNotCorrect,23},{expiredPaymentMeans,24},{paymentMeansRestrictionsNotFulfilled,25}]},{0,255}},mandatory},{<<115,101,115,115,105,111,110,84,97,114,105,102,102,67,108,97,115,115>>,{'INTEGER',{0,255}},mandatory},{<<115,101,115,115,105,111,110,67,108,97,105,109,101,100,67,108,97,115,115>>,{'INTEGER',{0,255}},mandatory},{<<115,101,115,115,105,111,110,70,101,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},mandatory},{<<115,101,115,115,105,111,110,67,111,110,116,114,97,99,116,80,114,111,118,105,100,101,114>>,{typeinfo,{'EfcDataDictionary','Provider'}},mandatory},{<<115,101,115,115,105,111,110,84,121,112,101,79,102,67,111,110,116,114,97,99,116>>,octet_string,mandatory},{<<115,101,115,115,105,111,110,67,111,110,116,101,120,116,86,101,114,115,105,111,110>>,'INTEGER',mandatory},{<<114,101,99,101,105,112,116,68,97,116,97,65,117,116,104,101,110,116,105,99,97,116,111,114>>,octet_string,mandatory}]};
typeinfo('ReceiptFinancialPart') ->
  {sequence,'ReceiptFinancialPart',4,[{<<112,101,114,115,111,110,97,108,65,99,99,111,117,110,116,78,117,109,98,101,114>>,octet_string,mandatory},{<<115,101,115,115,105,111,110,80,97,121,109,101,110,116,70,101,101>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},mandatory},{<<115,101,115,115,105,111,110,67,117,114,114,101,110,116,66,97,108,97,110,99,101>>,{typeinfo,{'EfcDataDictionary','PurseBalance'}},mandatory},{<<114,101,99,101,105,112,116,70,105,110,97,110,99,105,97,108,83,101,114,105,97,108,78,117,109,98,101,114>>,{'INTEGER',{0,4294967295}},mandatory}]};
typeinfo('ReceiptServicePart') ->
  {sequence,'ReceiptServicePart',7,[{<<115,101,115,115,105,111,110,84,105,109,101>>,{typeinfo,{'EfcDataDictionary','DateAndTime'}},mandatory},{<<115,101,115,115,105,111,110,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114>>,{typeinfo,{'EfcDataDictionary','Provider'}},mandatory},{<<115,116,97,116,105,111,110,76,111,99,97,116,105,111,110>>,{'INTEGER',{0,1048575}},mandatory},{<<115,101,115,115,105,111,110,76,111,99,97,116,105,111,110>>,{bit_string,8},mandatory},{<<116,121,112,101,79,102,83,101,115,115,105,111,110>>,{{'INTEGER_NNL',[{unspecified,0},{closedEntryWithPayment,1},{closedEntryWithoutPayment,2},{closedTransit,3},{closedExit,4},{closedCredit,5},{mixed,6},{passage,7},{checkpoint,8},{reload,9},{reservedForFutureCENUse1,10},{reservedForFutureCENUse2,11},{reservedForFutureCENUse3,12},{reservedForFutureCENUse4,13},{privateUse5,14},{privateUse6,15}]},{0,15}},mandatory},{<<115,101,115,115,105,111,110,82,101,115,117,108,116,79,112,101,114,97,116,105,111,110,97,108>>,{{'INTEGER_NNL',[{correctTransaction,0},{obeStatusNotAccepted,1},{equipmentStatusNotAccepted,2},{contractNotInWhiteList,3},{contractIdentifierInBlackList,4},{contractIdentifierNotCorrect,5},{expiredContract,6},{contractRestrictionsNotFulfilled,7},{claimedVehicleCharacteristicsNotValid,8},{vehicleClassAuthenticationFailed,9},{entryVehicleClassDifferentFromExitVehicleClass,10},{entryReceiptMissing,11},{entryReceiptNotValid,12},{entryTollStationNotValid,13},{equipmentNotCertified,14},{timeDifference,15},{accessCredentialsNotAccepted,16},{contractAuthenticatorNotAccepted,17},{receiptAuthenticatorNotAccepted,18},{claimedVehicleCharacteristicsMissing,19},{paymentMeansNotAccepted,20},{paymentAuthenticatorNotAccepted,21},{paymentMeansInBlackList,22},{paymentMeansNotCorrect,23},{expiredPaymentMeans,24},{paymentMeansRestrictionsNotFulfilled,25}]},{0,255}},mandatory},{<<115,101,115,115,105,111,110,82,101,115,117,108,116,70,105,110,97,110,99,105,97,108>>,octet_string,mandatory}]};
typeinfo('UserId') ->
  {sequence,'UserId',5,[{<<112,97,110>>,octet_string,'OPTIONAL'},{<<99,111,110,116,114,97,99,116,83,101,114,105,97,108,78,117,109,98,101,114>>,{'INTEGER',{0,4294967295}},'OPTIONAL'},{<<108,105,99,101,110,99,101,80,108,97,116,101,78,117,109,98,101,114>>,{typeinfo,{'EfcDataDictionary','Lpn'}},'OPTIONAL'},{<<111,98,101,73,100>>,{typeinfo,{'EfcDataDictionary','ObeId'}},'OPTIONAL'},{<<105,99,99,73,100>>,octet_string,'OPTIONAL'}]};
typeinfo('VehicleAxles') ->
  {sequence,'VehicleAxles',2,[{<<118,101,104,105,99,108,101,70,105,114,115,116,65,120,108,101,72,101,105,103,104,116>>,{'INTEGER',{0,255}},mandatory},{<<118,101,104,105,99,108,101,65,120,108,101,115,78,117,109,98,101,114>>,{typeinfo,{'EfcDataDictionary','VehicleAxlesNumber'}},mandatory}]};
typeinfo('VehicleSpecificCharacteristics') ->
  {sequence,'VehicleSpecificCharacteristics',4,[{<<101,110,118,105,114,111,110,109,101,110,116,97,108,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115>>,{typeinfo,{'EfcDataDictionary','EnvironmentalCharacteristics'}},mandatory},{<<101,110,103,105,110,101,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115>>,{{'INTEGER_NNL',[{noEntry,0},{noEngine,1},{petrolUnleaded,2},{petrolLeaded,3},{diesel,4},{lpg,5},{battery,6},{solar,7},{hybrid,8},{hydrogen,9},{multiFuel,10},{bivalentPetrolLpg,11},{bivalentPetrolCng,12},{combinedPetrolElectric,13},{cng,14},{lng,15},{combinedDieselElectric,16},{combinedHydrogenElectric,17},{bivalentHydrogenPetrol,18},{bivalentHydrogenPetrolElectricEngine,19},{fuelCellHydrogen,20},{fuelCellPetrol,21},{fuelCellMethanol,22},{fuelCellEthanol,23},{fuelCellDiesel,24},{combinedMultiFuelElectricEngine,25},{combinedCngElectricEngine,26},{combinedLngElectricEngine,27},{petrolEthanol,28},{combinedLpgElectricEngine,29},{hybridPetrolExternalBattery,30},{hybridDieselExternalBattery,31},{hybridLpgExternalBattery,32},{hybridHydrogenExternalBattery,33},{hybridMultiFuelExternalBattery,34},{hybridCngExternalBattery,35},{hybridLngExternalBattery,36},{hybridBivalentHydrogenPetrolExternalBattery,37},{hydrogenCng,38},{hydrogenLng,39},{hybridHydrogenCngExternalBattery,40},{hybridHydrogenLngExternalBattery,41},{ethanol,42},{hybridFuelCellHydrogen,43},{hybridFuelCellHydrogenExternalBattery,44},{dualFuelLngDiesel,45},{electricExternal,46},{biogas,47},{bioDiesel,48},{bioPetrol,49},{bivalentPetrolBiogas,50},{combinedBiogasElectricEngine,51},{dualFuelCngDiesel,52},{other,255}]},{0,255}},mandatory},{<<100,101,115,99,114,105,112,116,105,118,101,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115>>,{{'INTEGER_NNL',[{noEntry,0}]},{0,255}},mandatory},{<<102,117,116,117,114,101,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115>>,{{'INTEGER_NNL',[{noEntry,0},{airSuspension,1}]},{0,255}},mandatory}]};
typeinfo('AggregatedSingleTariffClassSession') ->
  {sequence,'AggregatedSingleTariffClassSession',8,[{<<116,105,109,101,80,101,114,105,111,100,67,111,118,101,114,101,100>>,{typeinfo,{'EfcDataDictionary','Period'}},'OPTIONAL'},{<<99,117,114,114,101,110,116,84,97,114,105,102,102,67,108,97,115,115>>,{typeinfo,{'EfcDataDictionary','TariffClassDescription'}},'OPTIONAL'},{<<118,101,104,105,99,108,101,68,101,115,99,114,105,112,116,105,111,110>>,{typeinfo,{'EfcDataDictionary','VehicleDescription'}},'OPTIONAL'},{<<116,111,116,97,108,68,105,115,116,97,110,99,101,67,111,118,101,114,101,100>>,{typeinfo,{'EfcDataDictionary','Distance'}},'OPTIONAL'},{<<110,117,109,98,101,114,79,102,68,101,116,101,99,116,101,100,69,118,101,110,116,115>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<111,98,101,83,116,97,116,117,115>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<102,101,101,69,120,99,108,86,97,116>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<115,117,109,86,97,116>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'}]};
typeinfo('DetectedChargeObject') ->
  {sequence,'DetectedChargeObject',10,[{<<99,104,97,114,103,101,79,98,106,101,99,116,73,100>>,{typeinfo,{'EfcDataDictionary','ChargeObjectId'}},mandatory},{<<115,117,98,79,98,106,101,99,116,78,117,109,98,101,114>>,{'INTEGER',{0,4294967295}},'OPTIONAL'},{<<116,105,109,101,87,104,101,110,85,115,101,100>>,string,'OPTIONAL'},{<<109,105,108,101,97,103,101,87,104,101,110,85,115,101,100>>,{typeinfo,{'EfcDataDictionary','Distance'}},'OPTIONAL'},{<<99,117,114,114,101,110,116,84,97,114,105,102,102,67,108,97,115,115>>,{typeinfo,{'EfcDataDictionary','TariffClassDescription'}},'OPTIONAL'},{<<118,101,104,105,99,108,101,68,101,115,99,114,105,112,116,105,111,110>>,{typeinfo,{'EfcDataDictionary','VehicleDescription'}},'OPTIONAL'},{<<111,98,101,83,116,97,116,117,115>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<102,101,101,69,120,99,108,86,97,116>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<115,117,109,86,97,116>>,{typeinfo,{'EfcDataDictionary','PaymentFee'}},'OPTIONAL'},{<<99,104,97,114,103,101,79,98,106,68,101,116,101,99,116,105,111,110,77,111,100,101>>,{{'INTEGER_NNL',[{measured,0},{inferred,1},{lac,2}]},{0,255}},'OPTIONAL'}]};
typeinfo('TariffClassDescription') ->
  {sequence,'TariffClassDescription',5,[{<<116,97,114,105,102,102,67,108,97,115,115,73,100>>,{'INTEGER',{0,4294967295}},{'DEFAULT',0}},{<<108,111,99,97,108,86,101,104,105,99,108,101,67,108,97,115,115,73,100>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<116,105,109,101,67,108,97,115,115,73,100>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<108,111,99,97,116,105,111,110,67,108,97,115,115,73,100>>,{'INTEGER',{0,4294967295}},'OPTIONAL'},{<<117,115,101,114,67,108,97,115,115,73,100>>,{'INTEGER',{0,255}},'OPTIONAL'}]};
typeinfo('VehicleDescription') ->
  {sequence,'VehicleDescription',17,[{<<118,101,104,105,99,108,101,76,80,78,114>>,{typeinfo,{'EfcDataDictionary','Lpn'}},'OPTIONAL'},{<<97,120,108,101,115>>,{typeinfo,{'EfcDataDictionary','VehicleAxles'}},'OPTIONAL'},{<<99,108,97,115,115>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<100,105,109,101,110,115,105,111,110,115>>,{typeinfo,{'EfcDataDictionary','VehicleDimensions'}},'OPTIONAL'},{<<115,112,101,99,105,102,105,99,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115>>,{typeinfo,{'EfcDataDictionary','VehicleSpecificCharacteristics'}},'OPTIONAL'},{<<108,97,100,101,110,87,101,105,103,104,116>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<119,101,105,103,104,116,76,105,109,105,116,115>>,{typeinfo,{'EfcDataDictionary','VehicleWeightLimits'}},'OPTIONAL'},{<<116,114,97,105,108,101,114,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115>>,{typeinfo,{'EfcDataDictionary','TrailerCharacteristics'}},'OPTIONAL'},{<<118,101,104,105,99,108,101,67,117,114,114,101,110,116,77,97,120,84,114,97,105,110,87,101,105,103,104,116>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<97,99,116,117,97,108,78,117,109,98,101,114,79,102,80,97,115,115,101,110,103,101,114,115>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<97,120,108,101,87,101,105,103,104,116,76,105,109,105,116,115>>,{typeinfo,{'EfcDataDictionary','AxleWeightLimits'}},'OPTIONAL'},{<<100,105,101,115,101,108,69,109,105,115,115,105,111,110,86,97,108,117,101,115>>,{typeinfo,{'EfcDataDictionary','DieselEmissionValues'}},'OPTIONAL'},{<<100,114,105,118,101,114,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115>>,{typeinfo,{'EfcDataDictionary','DriverCharacteristics'}},'OPTIONAL'},{<<101,110,103,105,110,101,68,101,116,97,105,108,115>>,{typeinfo,{'EfcDataDictionary','EngineDetails'}},'OPTIONAL'},{<<101,120,104,97,117,115,116,69,109,105,115,115,105,111,110,86,97,108,117,101,115>>,{typeinfo,{'EfcDataDictionary','ExhaustEmissionValues'}},'OPTIONAL'},{<<112,97,115,115,101,110,103,101,114,67,97,112,97,99,105,116,121>>,{typeinfo,{'EfcDataDictionary','PassengerCapacity'}},'OPTIONAL'},{<<115,111,117,110,100,76,101,118,101,108>>,{typeinfo,{'EfcDataDictionary','SoundLevel'}},'OPTIONAL'}]};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

dec_components1(Bytes, Acc) ->
%% Length with constraint no
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:7,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,0:1,V1@V4:14,V1@Buf5/bitstring>> ->
{V1@V4,V1@Buf5};
<<1:1,1:1,V1@V4:6,V1@Buf5/bitstring>> ->
V1@Mul6 = V1@V4 * 16384,
{V1@Mul6,V1@Buf5}
end,
{Acc1,Buf1} = dec_fragment2(V1@V0, V1@Buf1, Acc),
if V1@V0 >= 16384 ->
dec_components1(Buf1, Acc1);
true ->
{lists:reverse(Acc1),Buf1}
end.

dec_fragment2(0, Bytes, Acc) ->
{Acc,Bytes};
dec_fragment2(Num, Bytes, Acc) ->
{Term,Remain} = dec_AxleWeightLimit(Bytes),
dec_fragment2(Num-1, Remain, [Term|Acc]).

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_chars(Val, N) ->
    [ 
     C ||
         <<C:N>> <= Val
    ].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

encode_chars(Val, NumBits) ->
    << 
      <<C:NumBits>> ||
          C <- Val
    >>.

encode_components(Cs, _Encoder, 0, Acc) ->
    {Cs, lists:reverse(Acc)};
encode_components([C | Cs], Encoder, Size, Acc) ->
    B = Encoder(C),
    encode_components(Cs, Encoder, Size - 1, [B | Acc]).

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_fragmented_sof(Fun, Comps, Len) ->
    encode_fragmented_sof_1(Fun, Comps, Len, 4).

encode_fragmented_sof_1(Encoder, Comps0, Len0, N) ->
    SegSz = N * 16384,
    if
        Len0 >= SegSz ->
            {Comps, B} = encode_components(Comps0, Encoder, SegSz, []),
            Len = Len0 - SegSz,
            [<<3:2,N:6>>,
             B |
             encode_fragmented_sof_1(Encoder, Comps, Len, N)];
        N > 1 ->
            encode_fragmented_sof_1(Encoder, Comps0, Len0, N - 1);
        Len0 < 128 ->
            {[], B} = encode_components(Comps0, Encoder, Len0, []),
            [Len0 | B];
        Len0 < 16384 ->
            {[], B} = encode_components(Comps0, Encoder, Len0, []),
            [<<2:2,Len0:14>> | B]
    end.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

encode_unconstrained_number(Val) when not is_integer(Val) ->
    exit({error, {asn1, {illegal_integer, Val}}});
encode_unconstrained_number(Val) when Val >= 0 ->
    if
        Val < 128 ->
            [1, Val];
        Val < 256 ->
            [<<2,0>>, Val];
        true ->
            case binary:encode_unsigned(Val) of
                <<0:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) of
                        Sz when Sz < 128 ->
                            [Sz, Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14>>, Bin]
                    end;
                <<1:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) + 1 of
                        Sz when Sz < 128 ->
                            [Sz, 0, Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14,0:8>>, Bin]
                    end
            end
    end;
encode_unconstrained_number(Val) ->
    Oct = enint(Val, []),
    Len = length(Oct),
    if
        Len < 128 ->
            [Len | Oct];
        Len < 16384 ->
            [<<2:2,Len:14>> | Oct]
    end.

enint(-1, [B1 | T]) when B1 > 127 ->
    [B1 | T];
enint(N, Acc) ->
    enint(N bsr 8, [N band 255 | Acc]).

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
