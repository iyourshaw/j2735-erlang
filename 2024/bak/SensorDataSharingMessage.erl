%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in SensorDataSharingMessage.

-module('SensorDataSharingMessage').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("SensorDataSharingMessage.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'SensorDataSharingMessage'},
            {options,[{i,"./erl"},uper,jer,verbose,{i,"./asn"},{outdir,"./erl"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_SensorDataSharingMessage/1,
enc_EquipmentType/1,
enc_DetectedObjectList/1,
enc_DetectedObjectData/1,
enc_DetectedObjectOptionalData/1,
enc_DetectedObjectCommonData/1,
enc_DetectedVehicleData/1,
enc_DetectedVRUData/1,
enc_DetectedObstacleData/1,
enc_ObjectType/1,
enc_ObjectID/1,
enc_ClassificationConfidence/1,
enc_MeasurementTimeOffset/1,
enc_PositionOffsetXYZ/1,
enc_ObjectDistance/1,
enc_Attitude/1,
enc_PitchDetected/1,
enc_RollDetected/1,
enc_YawDetected/1,
enc_AttitudeConfidence/1,
enc_AngularVelocity/1,
enc_PitchRate/1,
enc_RollRate/1,
enc_AngularVelocityConfidence/1,
enc_PitchRateConfidence/1,
enc_RollRateConfidence/1,
enc_VehicleSizeConfidence/1,
enc_ObstacleSize/1,
enc_ObstacleSizeConfidence/1,
enc_SizeValue/1,
enc_SizeValueConfidence/1
]).

-export([
dec_SensorDataSharingMessage/1,
dec_EquipmentType/1,
dec_DetectedObjectList/1,
dec_DetectedObjectData/1,
dec_DetectedObjectOptionalData/1,
dec_DetectedObjectCommonData/1,
dec_DetectedVehicleData/1,
dec_DetectedVRUData/1,
dec_DetectedObstacleData/1,
dec_ObjectType/1,
dec_ObjectID/1,
dec_ClassificationConfidence/1,
dec_MeasurementTimeOffset/1,
dec_PositionOffsetXYZ/1,
dec_ObjectDistance/1,
dec_Attitude/1,
dec_PitchDetected/1,
dec_RollDetected/1,
dec_YawDetected/1,
dec_AttitudeConfidence/1,
dec_AngularVelocity/1,
dec_PitchRate/1,
dec_RollRate/1,
dec_AngularVelocityConfidence/1,
dec_PitchRateConfidence/1,
dec_RollRateConfidence/1,
dec_VehicleSizeConfidence/1,
dec_ObstacleSize/1,
dec_ObstacleSizeConfidence/1,
dec_SizeValue/1,
dec_SizeValueConfidence/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('SensorDataSharingMessage', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('SensorDataSharingMessage', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('SensorDataSharingMessage', Data) -> enc_SensorDataSharingMessage(Data);
encode_disp('EquipmentType', Data) -> enc_EquipmentType(Data);
encode_disp('DetectedObjectList', Data) -> enc_DetectedObjectList(Data);
encode_disp('DetectedObjectData', Data) -> enc_DetectedObjectData(Data);
encode_disp('DetectedObjectOptionalData', Data) -> enc_DetectedObjectOptionalData(Data);
encode_disp('DetectedObjectCommonData', Data) -> enc_DetectedObjectCommonData(Data);
encode_disp('DetectedVehicleData', Data) -> enc_DetectedVehicleData(Data);
encode_disp('DetectedVRUData', Data) -> enc_DetectedVRUData(Data);
encode_disp('DetectedObstacleData', Data) -> enc_DetectedObstacleData(Data);
encode_disp('ObjectType', Data) -> enc_ObjectType(Data);
encode_disp('ObjectID', Data) -> enc_ObjectID(Data);
encode_disp('ClassificationConfidence', Data) -> enc_ClassificationConfidence(Data);
encode_disp('MeasurementTimeOffset', Data) -> enc_MeasurementTimeOffset(Data);
encode_disp('PositionOffsetXYZ', Data) -> enc_PositionOffsetXYZ(Data);
encode_disp('ObjectDistance', Data) -> enc_ObjectDistance(Data);
encode_disp('Attitude', Data) -> enc_Attitude(Data);
encode_disp('PitchDetected', Data) -> enc_PitchDetected(Data);
encode_disp('RollDetected', Data) -> enc_RollDetected(Data);
encode_disp('YawDetected', Data) -> enc_YawDetected(Data);
encode_disp('AttitudeConfidence', Data) -> enc_AttitudeConfidence(Data);
encode_disp('AngularVelocity', Data) -> enc_AngularVelocity(Data);
encode_disp('PitchRate', Data) -> enc_PitchRate(Data);
encode_disp('RollRate', Data) -> enc_RollRate(Data);
encode_disp('AngularVelocityConfidence', Data) -> enc_AngularVelocityConfidence(Data);
encode_disp('PitchRateConfidence', Data) -> enc_PitchRateConfidence(Data);
encode_disp('RollRateConfidence', Data) -> enc_RollRateConfidence(Data);
encode_disp('VehicleSizeConfidence', Data) -> enc_VehicleSizeConfidence(Data);
encode_disp('ObstacleSize', Data) -> enc_ObstacleSize(Data);
encode_disp('ObstacleSizeConfidence', Data) -> enc_ObstacleSizeConfidence(Data);
encode_disp('SizeValue', Data) -> enc_SizeValue(Data);
encode_disp('SizeValueConfidence', Data) -> enc_SizeValueConfidence(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('SensorDataSharingMessage', Data) -> dec_SensorDataSharingMessage(Data);
decode_disp('EquipmentType', Data) -> dec_EquipmentType(Data);
decode_disp('DetectedObjectList', Data) -> dec_DetectedObjectList(Data);
decode_disp('DetectedObjectData', Data) -> dec_DetectedObjectData(Data);
decode_disp('DetectedObjectOptionalData', Data) -> dec_DetectedObjectOptionalData(Data);
decode_disp('DetectedObjectCommonData', Data) -> dec_DetectedObjectCommonData(Data);
decode_disp('DetectedVehicleData', Data) -> dec_DetectedVehicleData(Data);
decode_disp('DetectedVRUData', Data) -> dec_DetectedVRUData(Data);
decode_disp('DetectedObstacleData', Data) -> dec_DetectedObstacleData(Data);
decode_disp('ObjectType', Data) -> dec_ObjectType(Data);
decode_disp('ObjectID', Data) -> dec_ObjectID(Data);
decode_disp('ClassificationConfidence', Data) -> dec_ClassificationConfidence(Data);
decode_disp('MeasurementTimeOffset', Data) -> dec_MeasurementTimeOffset(Data);
decode_disp('PositionOffsetXYZ', Data) -> dec_PositionOffsetXYZ(Data);
decode_disp('ObjectDistance', Data) -> dec_ObjectDistance(Data);
decode_disp('Attitude', Data) -> dec_Attitude(Data);
decode_disp('PitchDetected', Data) -> dec_PitchDetected(Data);
decode_disp('RollDetected', Data) -> dec_RollDetected(Data);
decode_disp('YawDetected', Data) -> dec_YawDetected(Data);
decode_disp('AttitudeConfidence', Data) -> dec_AttitudeConfidence(Data);
decode_disp('AngularVelocity', Data) -> dec_AngularVelocity(Data);
decode_disp('PitchRate', Data) -> dec_PitchRate(Data);
decode_disp('RollRate', Data) -> dec_RollRate(Data);
decode_disp('AngularVelocityConfidence', Data) -> dec_AngularVelocityConfidence(Data);
decode_disp('PitchRateConfidence', Data) -> dec_PitchRateConfidence(Data);
decode_disp('RollRateConfidence', Data) -> dec_RollRateConfidence(Data);
decode_disp('VehicleSizeConfidence', Data) -> dec_VehicleSizeConfidence(Data);
decode_disp('ObstacleSize', Data) -> dec_ObstacleSize(Data);
decode_disp('ObstacleSizeConfidence', Data) -> dec_ObstacleSizeConfidence(Data);
decode_disp('SizeValue', Data) -> dec_SizeValue(Data);
decode_disp('SizeValueConfidence', Data) -> dec_SizeValueConfidence(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_SensorDataSharingMessage(Val) ->
[begin
Enc1@element = element(8, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute msgCnt(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 7 =:= 0 ->
<<Enc2@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute sourceID(2) with type OCTET STRING
Enc4@element = element(3, Val),
Enc5@len = byte_size(Enc4@element),
if Enc5@len =:= 4 ->
Enc4@element
end
end,
begin
%% attribute equipmentType(3) with type ENUMERATED
Enc6@element = element(4, Val),
if Enc6@element =:= unknown ->
<<0:1,0:2>>;
Enc6@element =:= rsu ->
<<0:1,1:2>>;
Enc6@element =:= obu ->
<<0:1,2:2>>;
Enc6@element =:= vru ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc6@element}}})
end
end,
begin
%% attribute sDSMTimeStamp(4) with type DDateTime
Enc8@element = element(5, Val),
'Common':enc_DDateTime(Enc8@element)
end,
begin
%% attribute refPos(5) with type Position3D
Enc9@element = element(6, Val),
'Common':enc_Position3D(Enc9@element)
end,
begin
%% attribute refPosXYConf(6) with type PositionalAccuracy
Enc10@element = element(7, Val),
'Common':enc_PositionalAccuracy(Enc10@element)
end,
begin
%% attribute refPosElConf(7) with type ENUMERATED
Enc11@element = element(8, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
Enc11@element =:= unavailable ->
<<0:4>>;
Enc11@element =:= 'elev-500-00' ->
<<1:4>>;
Enc11@element =:= 'elev-200-00' ->
<<2:4>>;
Enc11@element =:= 'elev-100-00' ->
<<3:4>>;
Enc11@element =:= 'elev-050-00' ->
<<4:4>>;
Enc11@element =:= 'elev-020-00' ->
<<5:4>>;
Enc11@element =:= 'elev-010-00' ->
<<6:4>>;
Enc11@element =:= 'elev-005-00' ->
<<7:4>>;
Enc11@element =:= 'elev-002-00' ->
<<8:4>>;
Enc11@element =:= 'elev-001-00' ->
<<9:4>>;
Enc11@element =:= 'elev-000-50' ->
<<10:4>>;
Enc11@element =:= 'elev-000-20' ->
<<11:4>>;
Enc11@element =:= 'elev-000-10' ->
<<12:4>>;
Enc11@element =:= 'elev-000-05' ->
<<13:4>>;
Enc11@element =:= 'elev-000-02' ->
<<14:4>>;
Enc11@element =:= 'elev-000-01' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc11@element}}})
end
end|begin
%% attribute objects(8) with type DetectedObjectList
Enc14@element = element(9, Val),
enc_DetectedObjectList(Enc14@element)
end].


dec_SensorDataSharingMessage(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute msgCnt(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute sourceID(2) with type OCTET STRING
{Term2,Bytes3} = begin
<<V3@V0:4/binary-unit:8,V3@Buf1/bitstring>> = Bytes2,
V3@Conv2 = binary:copy(V3@V0),
{V3@Conv2,V3@Buf1}
end,

%% attribute equipmentType(3) with type ENUMERATED
{Term3,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:2,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> unknown;
1 -> rsu;
2 -> obu;
3 -> vru
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11};
<<1:1,1:1,V4@V10:6,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
V4@Mul12 = V4@V10 * 16384,
{V4@Mul12,V4@Buf11}
end,
<<V4@V13:V4@V6/unit:8,V4@Buf14/bitstring>> = V4@Buf7,
{V4@V13,V4@Buf14}
end,
V4@Int15 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int15,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end,

%% attribute sDSMTimeStamp(4) with type DDateTime
{Term4,Bytes5} = 'Common':dec_DDateTime(Bytes4),

%% attribute refPos(5) with type Position3D
{Term5,Bytes6} = 'Common':dec_Position3D(Bytes5),

%% attribute refPosXYConf(6) with type PositionalAccuracy
{Term6,Bytes7} = 'Common':dec_PositionalAccuracy(Bytes6),

%% attribute refPosElConf(7) with type ENUMERATED
{Term7,Bytes8} = case Opt band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes7,
V5@Int2 = case V5@V0 of
0 -> unavailable;
1 -> 'elev-500-00';
2 -> 'elev-200-00';
3 -> 'elev-100-00';
4 -> 'elev-050-00';
5 -> 'elev-020-00';
6 -> 'elev-010-00';
7 -> 'elev-005-00';
8 -> 'elev-002-00';
9 -> 'elev-001-00';
10 -> 'elev-000-50';
11 -> 'elev-000-20';
12 -> 'elev-000-10';
13 -> 'elev-000-05';
14 -> 'elev-000-02';
15 -> 'elev-000-01'
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute objects(8) with type DetectedObjectList
{Term8,Bytes9} = dec_DetectedObjectList(Bytes8),
Res1 = {'SensorDataSharingMessage',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8},
{Res1,Bytes9}.

enc_EquipmentType(Val) ->
if Val =:= unknown ->
<<0:1,0:2>>;
Val =:= rsu ->
<<0:1,1:2>>;
Val =:= obu ->
<<0:1,2:2>>;
Val =:= vru ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_EquipmentType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> rsu;
2 -> obu;
3 -> vru
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_DetectedObjectList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 8 =:= 0 ->
[Enc1@len@sub|[enc_DetectedObjectData(Comp) || Comp <- Val]]
end.



dec_DetectedObjectList(Bytes) ->
%% Length with constraint {1,256}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components1(V1@Add2, V1@Buf1, []).

enc_DetectedObjectData(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute detObjCommon(1) with type DetectedObjectCommonData
Enc2@element = element(2, Val),
enc_DetectedObjectCommonData(Enc2@element)
end|begin
%% attribute detObjOptData(2) with type DetectedObjectOptionalData
Enc3@element = element(3, Val),
if Enc3@element =:= asn1_NOVALUE ->
[];
true ->
enc_DetectedObjectOptionalData(Enc3@element)
end
end].


dec_DetectedObjectData(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute detObjCommon(1) with type DetectedObjectCommonData
{Term1,Bytes2} = dec_DetectedObjectCommonData(Bytes1),

%% attribute detObjOptData(2) with type DetectedObjectOptionalData
{Term2,Bytes3} = case Opt band 1 of
1 ->
dec_DetectedObjectOptionalData(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,
Res1 = {'DetectedObjectData',Term1,Term2},
{Res1,Bytes3}.

enc_DetectedObjectOptionalData(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= detVeh ->
[<<0:2>>|enc_DetectedVehicleData(ChoiceVal)];
ChoiceTag =:= detVRU ->
[<<1:2>>|enc_DetectedVRUData(ChoiceVal)];
ChoiceTag =:= detObst ->
[<<2:2>>|enc_DetectedObstacleData(ChoiceVal)]
end.


dec_DetectedObjectOptionalData(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_DetectedVehicleData(Bytes1)
end,
{{detVeh,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_DetectedVRUData(Bytes1)
end,
{{detVRU,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_DetectedObstacleData(Bytes1)
end,
{{detObst,Val},NewBytes}
end.
enc_DetectedObjectCommonData(Val) ->
[begin
Enc1@element = element(11, Val),
Enc2@element = element(12, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(15, Val),
Enc4@element = element(16, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(17, Val),
Enc6@element = element(18, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(19, Val),
if Enc7@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute objType(1) with type ENUMERATED
Enc9@element = element(2, Val),
if Enc9@element =:= unknown ->
<<0:1,0:2>>;
Enc9@element =:= vehicle ->
<<0:1,1:2>>;
Enc9@element =:= vru ->
<<0:1,2:2>>;
Enc9@element =:= animal ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc9@element}}})
end
end,
begin
%% attribute objTypeCfd(2) with type INTEGER
Enc11@element = element(3, Val),
if 0 =< Enc11@element, Enc11@element < 102 ->
<<Enc11@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc11@element}}})
end
end,
begin
%% attribute objectID(3) with type INTEGER
Enc13@element = element(4, Val),
if Enc13@element bsr 16 =:= 0 ->
<<Enc13@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc13@element}}})
end
end,
begin
%% attribute measurementTime(4) with type INTEGER
Enc15@element = element(5, Val),
Enc15@element@sub = Enc15@element - -1500,
if 0 =< Enc15@element@sub, Enc15@element@sub < 3001 ->
<<Enc15@element@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc15@element}}})
end
end,
begin
%% attribute timeConfidence(5) with type ENUMERATED
Enc17@element = element(6, Val),
if Enc17@element =:= unavailable ->
<<0:6>>;
Enc17@element =:= 'time-100-000' ->
<<1:6>>;
Enc17@element =:= 'time-050-000' ->
<<2:6>>;
Enc17@element =:= 'time-020-000' ->
<<3:6>>;
Enc17@element =:= 'time-010-000' ->
<<4:6>>;
Enc17@element =:= 'time-002-000' ->
<<5:6>>;
Enc17@element =:= 'time-001-000' ->
<<6:6>>;
Enc17@element =:= 'time-000-500' ->
<<7:6>>;
Enc17@element =:= 'time-000-200' ->
<<8:6>>;
Enc17@element =:= 'time-000-100' ->
<<9:6>>;
Enc17@element =:= 'time-000-050' ->
<<10:6>>;
Enc17@element =:= 'time-000-020' ->
<<11:6>>;
Enc17@element =:= 'time-000-010' ->
<<12:6>>;
Enc17@element =:= 'time-000-005' ->
<<13:6>>;
Enc17@element =:= 'time-000-002' ->
<<14:6>>;
Enc17@element =:= 'time-000-001' ->
<<15:6>>;
Enc17@element =:= 'time-000-000-5' ->
<<16:6>>;
Enc17@element =:= 'time-000-000-2' ->
<<17:6>>;
Enc17@element =:= 'time-000-000-1' ->
<<18:6>>;
Enc17@element =:= 'time-000-000-05' ->
<<19:6>>;
Enc17@element =:= 'time-000-000-02' ->
<<20:6>>;
Enc17@element =:= 'time-000-000-01' ->
<<21:6>>;
Enc17@element =:= 'time-000-000-005' ->
<<22:6>>;
Enc17@element =:= 'time-000-000-002' ->
<<23:6>>;
Enc17@element =:= 'time-000-000-001' ->
<<24:6>>;
Enc17@element =:= 'time-000-000-000-5' ->
<<25:6>>;
Enc17@element =:= 'time-000-000-000-2' ->
<<26:6>>;
Enc17@element =:= 'time-000-000-000-1' ->
<<27:6>>;
Enc17@element =:= 'time-000-000-000-05' ->
<<28:6>>;
Enc17@element =:= 'time-000-000-000-02' ->
<<29:6>>;
Enc17@element =:= 'time-000-000-000-01' ->
<<30:6>>;
Enc17@element =:= 'time-000-000-000-005' ->
<<31:6>>;
Enc17@element =:= 'time-000-000-000-002' ->
<<32:6>>;
Enc17@element =:= 'time-000-000-000-001' ->
<<33:6>>;
Enc17@element =:= 'time-000-000-000-000-5' ->
<<34:6>>;
Enc17@element =:= 'time-000-000-000-000-2' ->
<<35:6>>;
Enc17@element =:= 'time-000-000-000-000-1' ->
<<36:6>>;
Enc17@element =:= 'time-000-000-000-000-05' ->
<<37:6>>;
Enc17@element =:= 'time-000-000-000-000-02' ->
<<38:6>>;
Enc17@element =:= 'time-000-000-000-000-01' ->
<<39:6>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc17@element}}})
end
end,
begin
%% attribute pos(6) with type PositionOffsetXYZ
Enc19@element = element(7, Val),
enc_PositionOffsetXYZ(Enc19@element)
end,
begin
%% attribute posConfidence(7) with type PositionConfidenceSet
Enc20@element = element(8, Val),
'Common':enc_PositionConfidenceSet(Enc20@element)
end,
begin
%% attribute speed(8) with type INTEGER
Enc21@element = element(9, Val),
if Enc21@element bsr 13 =:= 0 ->
<<Enc21@element:13>>;
true ->
exit({error,{asn1,{illegal_integer,Enc21@element}}})
end
end,
begin
%% attribute speedConfidence(9) with type ENUMERATED
Enc23@element = element(10, Val),
if Enc23@element =:= unavailable ->
<<0:3>>;
Enc23@element =:= prec100ms ->
<<1:3>>;
Enc23@element =:= prec10ms ->
<<2:3>>;
Enc23@element =:= prec5ms ->
<<3:3>>;
Enc23@element =:= prec1ms ->
<<4:3>>;
Enc23@element =:= 'prec0-1ms' ->
<<5:3>>;
Enc23@element =:= 'prec0-05ms' ->
<<6:3>>;
Enc23@element =:= 'prec0-01ms' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc23@element}}})
end
end,
begin
%% attribute speedZ(10) with type INTEGER
Enc25@element = element(11, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
Enc25@element bsr 13 =:= 0 ->
<<Enc25@element:13>>;
true ->
exit({error,{asn1,{illegal_integer,Enc25@element}}})
end
end,
begin
%% attribute speedConfidenceZ(11) with type ENUMERATED
Enc28@element = element(12, Val),
if Enc28@element =:= asn1_NOVALUE ->
[];
Enc28@element =:= unavailable ->
<<0:3>>;
Enc28@element =:= prec100ms ->
<<1:3>>;
Enc28@element =:= prec10ms ->
<<2:3>>;
Enc28@element =:= prec5ms ->
<<3:3>>;
Enc28@element =:= prec1ms ->
<<4:3>>;
Enc28@element =:= 'prec0-1ms' ->
<<5:3>>;
Enc28@element =:= 'prec0-05ms' ->
<<6:3>>;
Enc28@element =:= 'prec0-01ms' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc28@element}}})
end
end,
begin
%% attribute heading(12) with type INTEGER
Enc31@element = element(13, Val),
if 0 =< Enc31@element, Enc31@element < 28801 ->
<<Enc31@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc31@element}}})
end
end,
begin
%% attribute headingConf(13) with type ENUMERATED
Enc33@element = element(14, Val),
if Enc33@element =:= unavailable ->
<<0:3>>;
Enc33@element =:= prec10deg ->
<<1:3>>;
Enc33@element =:= prec05deg ->
<<2:3>>;
Enc33@element =:= prec01deg ->
<<3:3>>;
Enc33@element =:= 'prec0-1deg' ->
<<4:3>>;
Enc33@element =:= 'prec0-05deg' ->
<<5:3>>;
Enc33@element =:= 'prec0-01deg' ->
<<6:3>>;
Enc33@element =:= 'prec0-0125deg' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc33@element}}})
end
end,
begin
%% attribute accel4way(14) with type AccelerationSet4Way
Enc35@element = element(15, Val),
if Enc35@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_AccelerationSet4Way(Enc35@element)
end
end,
begin
%% attribute accCfdX(15) with type ENUMERATED
Enc37@element = element(16, Val),
if Enc37@element =:= asn1_NOVALUE ->
[];
Enc37@element =:= unavailable ->
<<0:3>>;
Enc37@element =:= 'accl-100-00' ->
<<1:3>>;
Enc37@element =:= 'accl-010-00' ->
<<2:3>>;
Enc37@element =:= 'accl-005-00' ->
<<3:3>>;
Enc37@element =:= 'accl-001-00' ->
<<4:3>>;
Enc37@element =:= 'accl-000-10' ->
<<5:3>>;
Enc37@element =:= 'accl-000-05' ->
<<6:3>>;
Enc37@element =:= 'accl-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc37@element}}})
end
end,
begin
%% attribute accCfdY(16) with type ENUMERATED
Enc40@element = element(17, Val),
if Enc40@element =:= asn1_NOVALUE ->
[];
Enc40@element =:= unavailable ->
<<0:3>>;
Enc40@element =:= 'accl-100-00' ->
<<1:3>>;
Enc40@element =:= 'accl-010-00' ->
<<2:3>>;
Enc40@element =:= 'accl-005-00' ->
<<3:3>>;
Enc40@element =:= 'accl-001-00' ->
<<4:3>>;
Enc40@element =:= 'accl-000-10' ->
<<5:3>>;
Enc40@element =:= 'accl-000-05' ->
<<6:3>>;
Enc40@element =:= 'accl-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc40@element}}})
end
end,
begin
%% attribute accCfdZ(17) with type ENUMERATED
Enc43@element = element(18, Val),
if Enc43@element =:= asn1_NOVALUE ->
[];
Enc43@element =:= unavailable ->
<<0:3>>;
Enc43@element =:= 'accl-100-00' ->
<<1:3>>;
Enc43@element =:= 'accl-010-00' ->
<<2:3>>;
Enc43@element =:= 'accl-005-00' ->
<<3:3>>;
Enc43@element =:= 'accl-001-00' ->
<<4:3>>;
Enc43@element =:= 'accl-000-10' ->
<<5:3>>;
Enc43@element =:= 'accl-000-05' ->
<<6:3>>;
Enc43@element =:= 'accl-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc43@element}}})
end
end|begin
%% attribute accCfdYaw(18) with type ENUMERATED
Enc46@element = element(19, Val),
if Enc46@element =:= asn1_NOVALUE ->
[];
Enc46@element =:= unavailable ->
<<0:3>>;
Enc46@element =:= 'degSec-100-00' ->
<<1:3>>;
Enc46@element =:= 'degSec-010-00' ->
<<2:3>>;
Enc46@element =:= 'degSec-005-00' ->
<<3:3>>;
Enc46@element =:= 'degSec-001-00' ->
<<4:3>>;
Enc46@element =:= 'degSec-000-10' ->
<<5:3>>;
Enc46@element =:= 'degSec-000-05' ->
<<6:3>>;
Enc46@element =:= 'degSec-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc46@element}}})
end
end].


dec_DetectedObjectCommonData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:7,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute objType(1) with type ENUMERATED
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:2,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> unknown;
1 -> vehicle;
2 -> vru;
3 -> animal
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11};
<<1:1,1:1,V3@V10:6,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
V3@Mul12 = V3@V10 * 16384,
{V3@Mul12,V3@Buf11}
end,
<<V3@V13:V3@V6/unit:8,V3@Buf14/bitstring>> = V3@Buf7,
{V3@V13,V3@Buf14}
end,
V3@Int15 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int15,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end,

%% attribute objTypeCfd(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute objectID(3) with type INTEGER
{Term3,Bytes5} = begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end,

%% attribute measurementTime(4) with type INTEGER
{Term4,Bytes6} = begin
<<V6@V0:12,V6@Buf1/bitstring>> = Bytes5,
V6@Add2 = V6@V0 + -1500,
{V6@Add2,V6@Buf1}
end,

%% attribute timeConfidence(5) with type ENUMERATED
{Term5,Bytes7} = begin
<<V7@V0:6,V7@Buf1/bitstring>> = Bytes6,
V7@Int2 = case V7@V0 of
0 -> unavailable;
1 -> 'time-100-000';
2 -> 'time-050-000';
3 -> 'time-020-000';
4 -> 'time-010-000';
5 -> 'time-002-000';
6 -> 'time-001-000';
7 -> 'time-000-500';
8 -> 'time-000-200';
9 -> 'time-000-100';
10 -> 'time-000-050';
11 -> 'time-000-020';
12 -> 'time-000-010';
13 -> 'time-000-005';
14 -> 'time-000-002';
15 -> 'time-000-001';
16 -> 'time-000-000-5';
17 -> 'time-000-000-2';
18 -> 'time-000-000-1';
19 -> 'time-000-000-05';
20 -> 'time-000-000-02';
21 -> 'time-000-000-01';
22 -> 'time-000-000-005';
23 -> 'time-000-000-002';
24 -> 'time-000-000-001';
25 -> 'time-000-000-000-5';
26 -> 'time-000-000-000-2';
27 -> 'time-000-000-000-1';
28 -> 'time-000-000-000-05';
29 -> 'time-000-000-000-02';
30 -> 'time-000-000-000-01';
31 -> 'time-000-000-000-005';
32 -> 'time-000-000-000-002';
33 -> 'time-000-000-000-001';
34 -> 'time-000-000-000-000-5';
35 -> 'time-000-000-000-000-2';
36 -> 'time-000-000-000-000-1';
37 -> 'time-000-000-000-000-05';
38 -> 'time-000-000-000-000-02';
39 -> 'time-000-000-000-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V7@V0}}})
end,
{V7@Int2,V7@Buf1}
end,

%% attribute pos(6) with type PositionOffsetXYZ
{Term6,Bytes8} = dec_PositionOffsetXYZ(Bytes7),

%% attribute posConfidence(7) with type PositionConfidenceSet
{Term7,Bytes9} = 'Common':dec_PositionConfidenceSet(Bytes8),

%% attribute speed(8) with type INTEGER
{Term8,Bytes10} = begin
<<V8@V0:13,V8@Buf1/bitstring>> = Bytes9,
{V8@V0,V8@Buf1}
end,

%% attribute speedConfidence(9) with type ENUMERATED
{Term9,Bytes11} = begin
<<V9@V0:3,V9@Buf1/bitstring>> = Bytes10,
V9@Int2 = case V9@V0 of
0 -> unavailable;
1 -> prec100ms;
2 -> prec10ms;
3 -> prec5ms;
4 -> prec1ms;
5 -> 'prec0-1ms';
6 -> 'prec0-05ms';
7 -> 'prec0-01ms'
end,
{V9@Int2,V9@Buf1}
end,

%% attribute speedZ(10) with type INTEGER
{Term10,Bytes12} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V10@V0:13,V10@Buf1/bitstring>> = Bytes11,
{V10@V0,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute speedConfidenceZ(11) with type ENUMERATED
{Term11,Bytes13} = case (Opt bsr 5) band 1 of
1 ->
begin
<<V11@V0:3,V11@Buf1/bitstring>> = Bytes12,
V11@Int2 = case V11@V0 of
0 -> unavailable;
1 -> prec100ms;
2 -> prec10ms;
3 -> prec5ms;
4 -> prec1ms;
5 -> 'prec0-1ms';
6 -> 'prec0-05ms';
7 -> 'prec0-01ms'
end,
{V11@Int2,V11@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute heading(12) with type INTEGER
{Term12,Bytes14} = begin
<<V12@V0:15,V12@Buf1/bitstring>> = Bytes13,
{V12@V0,V12@Buf1}
end,

%% attribute headingConf(13) with type ENUMERATED
{Term13,Bytes15} = begin
<<V13@V0:3,V13@Buf1/bitstring>> = Bytes14,
V13@Int2 = case V13@V0 of
0 -> unavailable;
1 -> prec10deg;
2 -> prec05deg;
3 -> prec01deg;
4 -> 'prec0-1deg';
5 -> 'prec0-05deg';
6 -> 'prec0-01deg';
7 -> 'prec0-0125deg'
end,
{V13@Int2,V13@Buf1}
end,

%% attribute accel4way(14) with type AccelerationSet4Way
{Term14,Bytes16} = case (Opt bsr 4) band 1 of
1 ->
'Common':dec_AccelerationSet4Way(Bytes15);
0 ->
{asn1_NOVALUE,Bytes15}
end,

%% attribute accCfdX(15) with type ENUMERATED
{Term15,Bytes17} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V14@V0:3,V14@Buf1/bitstring>> = Bytes16,
V14@Int2 = case V14@V0 of
0 -> unavailable;
1 -> 'accl-100-00';
2 -> 'accl-010-00';
3 -> 'accl-005-00';
4 -> 'accl-001-00';
5 -> 'accl-000-10';
6 -> 'accl-000-05';
7 -> 'accl-000-01'
end,
{V14@Int2,V14@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes16}
end,

%% attribute accCfdY(16) with type ENUMERATED
{Term16,Bytes18} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V15@V0:3,V15@Buf1/bitstring>> = Bytes17,
V15@Int2 = case V15@V0 of
0 -> unavailable;
1 -> 'accl-100-00';
2 -> 'accl-010-00';
3 -> 'accl-005-00';
4 -> 'accl-001-00';
5 -> 'accl-000-10';
6 -> 'accl-000-05';
7 -> 'accl-000-01'
end,
{V15@Int2,V15@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes17}
end,

%% attribute accCfdZ(17) with type ENUMERATED
{Term17,Bytes19} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V16@V0:3,V16@Buf1/bitstring>> = Bytes18,
V16@Int2 = case V16@V0 of
0 -> unavailable;
1 -> 'accl-100-00';
2 -> 'accl-010-00';
3 -> 'accl-005-00';
4 -> 'accl-001-00';
5 -> 'accl-000-10';
6 -> 'accl-000-05';
7 -> 'accl-000-01'
end,
{V16@Int2,V16@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes18}
end,

%% attribute accCfdYaw(18) with type ENUMERATED
{Term18,Bytes20} = case Opt band 1 of
1 ->
begin
<<V17@V0:3,V17@Buf1/bitstring>> = Bytes19,
V17@Int2 = case V17@V0 of
0 -> unavailable;
1 -> 'degSec-100-00';
2 -> 'degSec-010-00';
3 -> 'degSec-005-00';
4 -> 'degSec-001-00';
5 -> 'degSec-000-10';
6 -> 'degSec-000-05';
7 -> 'degSec-000-01'
end,
{V17@Int2,V17@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes19}
end,

%% Extensions
{Extensions,Bytes21} = case Ext of
0 -> {<<>>,Bytes20};
1 ->
{V18@V0,V18@Buf1} = case Bytes20 of
<<0:1,V18@V3:6,V18@Buf4/bitstring>> ->
V18@Add5 = V18@V3 + 1,
{V18@Add5,V18@Buf4};
<<1:1,V18@Buf2/bitstring>> ->
{V18@V3,V18@Buf4} = case V18@Buf2 of
<<0:1,V18@V6:7,V18@Buf7/bitstring>> when V18@V6 =/= 0 ->
{V18@V6,V18@Buf7};
<<1:1,0:1,V18@V7:14,V18@Buf8/bitstring>> when V18@V7 =/= 0 ->
{V18@V7,V18@Buf8};
<<1:1,1:1,V18@V7:6,V18@Buf8/bitstring>> when V18@V7 =/= 0 ->
V18@Mul9 = V18@V7 * 16384,
{V18@Mul9,V18@Buf8}
end,
{V18@V3,V18@Buf4}
end,
<<V18@V10:V18@V0/bitstring-unit:1,V18@Buf11/bitstring>> = V18@Buf1,
{V18@V10,V18@Buf11}
end,
Bytes22= skipextensions(Bytes21, 1, Extensions),
Res1 = {'DetectedObjectCommonData',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13,Term14,Term15,Term16,Term17,Term18},
{Res1,Bytes22}.

enc_DetectedVehicleData(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute lights(1) with type BIT STRING
Enc12@element = element(2, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc13@bs = try bit_string_name2pos_2(Enc12@element) of
Enc13@positions ->
bitstring_from_positions(Enc13@positions, 9)
catch throw:invalid ->
adjust_trailing_zeroes(Enc12@element, 9)
end,
Enc13@bits = bit_size(Enc13@bs),
if Enc13@bits =:= 9 ->
[<<0:1>>|Enc13@bs];
Enc13@bits < 128 ->
[<<1:1,Enc13@bits:8>>|Enc13@bs];
Enc13@bits < 16384 ->
[<<1:1,2:2,Enc13@bits:14>>|Enc13@bs];
true ->
[<<1:1>>|encode_fragmented(Enc13@bs, 1)]
end
end
end
end,
begin
%% attribute vehAttitude(2) with type Attitude
Enc15@element = element(3, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
enc_Attitude(Enc15@element)
end
end,
begin
%% attribute vehAttitudeConfidence(3) with type AttitudeConfidence
Enc17@element = element(4, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
true ->
enc_AttitudeConfidence(Enc17@element)
end
end,
begin
%% attribute vehAngVel(4) with type AngularVelocity
Enc19@element = element(5, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
enc_AngularVelocity(Enc19@element)
end
end,
begin
%% attribute vehAngVelConfidence(5) with type AngularVelocityConfidence
Enc21@element = element(6, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
enc_AngularVelocityConfidence(Enc21@element)
end
end,
begin
%% attribute size(6) with type VehicleSize
Enc23@element = element(7, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_VehicleSize(Enc23@element)
end
end,
begin
%% attribute height(7) with type INTEGER
Enc25@element = element(8, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
Enc25@element bsr 7 =:= 0 ->
<<Enc25@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc25@element}}})
end
end,
begin
%% attribute vehicleSizeConfidence(8) with type VehicleSizeConfidence
Enc28@element = element(9, Val),
if Enc28@element =:= asn1_NOVALUE ->
[];
true ->
enc_VehicleSizeConfidence(Enc28@element)
end
end,
begin
%% attribute vehicleClass(9) with type INTEGER
Enc30@element = element(10, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
Enc30@element bsr 8 =:= 0 ->
Enc30@element;
true ->
exit({error,{asn1,{illegal_integer,Enc30@element}}})
end
end|begin
%% attribute classConf(10) with type INTEGER
Enc33@element = element(11, Val),
if Enc33@element =:= asn1_NOVALUE ->
[];
0 =< Enc33@element, Enc33@element < 102 ->
<<Enc33@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc33@element}}})
end
end].


dec_DetectedVehicleData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute lights(1) with type BIT STRING
{Term1,Bytes3} = case (Opt bsr 9) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:9/binary-unit:1,V3@Buf4/bitstring>> ->
{V3@V3,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@V8:V3@V6/binary-unit:1,V3@Buf9/bitstring>> ->
{V3@V8,V3@Buf9};
<<1:1,0:1,V3@V7:14,V3@V9:V3@V7/binary-unit:1,V3@Buf10/bitstring>> ->
{V3@V9,V3@Buf10};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> ->
{V3@V9,V3@Buf10}  = decode_fragmented(V3@V7, V3@Buf8, 1),
{V3@V9,V3@Buf10}
end,
{V3@V3,V3@Buf4}
end,
{V3@V11,V3@Buf12}  = {decode_named_bit_string(V3@V0, [{lowBeamHeadlightsOn,0},{highBeamHeadlightsOn,1},{leftTurnSignalOn,2},{rightTurnSignalOn,3},{hazardSignalOn,4},{automaticLightControlOn,5},{daytimeRunningLightsOn,6},{fogLightOn,7},{parkingLightsOn,8}]),V3@Buf1},
{V3@V11,V3@Buf12}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute vehAttitude(2) with type Attitude
{Term2,Bytes4} = case (Opt bsr 8) band 1 of
1 ->
dec_Attitude(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute vehAttitudeConfidence(3) with type AttitudeConfidence
{Term3,Bytes5} = case (Opt bsr 7) band 1 of
1 ->
dec_AttitudeConfidence(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute vehAngVel(4) with type AngularVelocity
{Term4,Bytes6} = case (Opt bsr 6) band 1 of
1 ->
dec_AngularVelocity(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute vehAngVelConfidence(5) with type AngularVelocityConfidence
{Term5,Bytes7} = case (Opt bsr 5) band 1 of
1 ->
dec_AngularVelocityConfidence(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute size(6) with type VehicleSize
{Term6,Bytes8} = case (Opt bsr 4) band 1 of
1 ->
'Common':dec_VehicleSize(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute height(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:7,V4@Buf1/bitstring>> = Bytes8,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute vehicleSizeConfidence(8) with type VehicleSizeConfidence
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
dec_VehicleSizeConfidence(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute vehicleClass(9) with type INTEGER
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:8,V5@Buf1/bitstring>> = Bytes10,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute classConf(10) with type INTEGER
{Term10,Bytes12} = case Opt band 1 of
1 ->
begin
<<V6@V0:7,V6@Buf1/bitstring>> = Bytes11,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V7@V0,V7@Buf1} = case Bytes12 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = {'DetectedVehicleData',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10},
{Res1,Bytes14}.

enc_DetectedVRUData(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute basicType(1) with type ENUMERATED
Enc5@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
Enc5@element =:= unavailable ->
<<0:1,0:3>>;
Enc5@element =:= aPEDESTRIAN ->
<<0:1,1:3>>;
Enc5@element =:= aPEDALCYCLIST ->
<<0:1,2:3>>;
Enc5@element =:= aPUBLICSAFETYWORKER ->
<<0:1,3:3>>;
Enc5@element =:= anANIMAL ->
<<0:1,4:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end,
begin
%% attribute propulsion(2) with type PropelledInformation
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
true ->
'PersonalSafetyMessage':enc_PropelledInformation(Enc8@element)
end
end,
begin
%% attribute attachment(3) with type ENUMERATED
Enc10@element = element(4, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
Enc10@element =:= unavailable ->
<<0:1,0:3>>;
Enc10@element =:= stroller ->
<<0:1,1:3>>;
Enc10@element =:= bicycleTrailer ->
<<0:1,2:3>>;
Enc10@element =:= cart ->
<<0:1,3:3>>;
Enc10@element =:= wheelchair ->
<<0:1,4:3>>;
Enc10@element =:= otherWalkAssistAttachments ->
<<0:1,5:3>>;
Enc10@element =:= pet ->
<<0:1,6:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc10@element}}})
end
end|begin
%% attribute radius(4) with type INTEGER
Enc13@element = element(5, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
0 =< Enc13@element, Enc13@element < 201 ->
[Enc13@element];
true ->
exit({error,{asn1,{illegal_integer,Enc13@element}}})
end
end].


dec_DetectedVRUData(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute basicType(1) with type ENUMERATED
{Term1,Bytes2} = case (Opt bsr 3) band 1 of
1 ->
begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:3,V2@Buf4/bitstring>> ->
V2@Int5 = case V2@V3 of
0 -> unavailable;
1 -> aPEDESTRIAN;
2 -> aPEDALCYCLIST;
3 -> aPUBLICSAFETYWORKER;
4 -> anANIMAL;
_ -> exit({error,{asn1,{decode_enumerated,V2@V3}}})
end,
{V2@Int5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7} = case V2@Buf5 of
<<0:1,V2@V9:7,V2@Buf10/bitstring>> when V2@V9 =/= 0 ->
{V2@V9,V2@Buf10};
<<1:1,0:1,V2@V10:14,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
{V2@V10,V2@Buf11};
<<1:1,1:1,V2@V10:6,V2@Buf11/bitstring>> when V2@V10 =/= 0 ->
V2@Mul12 = V2@V10 * 16384,
{V2@Mul12,V2@Buf11}
end,
<<V2@V13:V2@V6/unit:8,V2@Buf14/bitstring>> = V2@Buf7,
{V2@V13,V2@Buf14}
end,
V2@Int15 = case V2@V3 of
_ -> {asn1_enum,V2@V3}
end,
{V2@Int15,V2@Buf4}
end,
{V2@V0,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute propulsion(2) with type PropelledInformation
{Term2,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
'PersonalSafetyMessage':dec_PropelledInformation(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute attachment(3) with type ENUMERATED
{Term3,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:3,V3@Buf4/bitstring>> ->
V3@Int5 = case V3@V3 of
0 -> unavailable;
1 -> stroller;
2 -> bicycleTrailer;
3 -> cart;
4 -> wheelchair;
5 -> otherWalkAssistAttachments;
6 -> pet;
_ -> exit({error,{asn1,{decode_enumerated,V3@V3}}})
end,
{V3@Int5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7} = case V3@Buf5 of
<<0:1,V3@V9:7,V3@Buf10/bitstring>> when V3@V9 =/= 0 ->
{V3@V9,V3@Buf10};
<<1:1,0:1,V3@V10:14,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
{V3@V10,V3@Buf11};
<<1:1,1:1,V3@V10:6,V3@Buf11/bitstring>> when V3@V10 =/= 0 ->
V3@Mul12 = V3@V10 * 16384,
{V3@Mul12,V3@Buf11}
end,
<<V3@V13:V3@V6/unit:8,V3@Buf14/bitstring>> = V3@Buf7,
{V3@V13,V3@Buf14}
end,
V3@Int15 = case V3@V3 of
_ -> {asn1_enum,V3@V3}
end,
{V3@Int15,V3@Buf4}
end,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute radius(4) with type INTEGER
{Term4,Bytes5} = case Opt band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = {'DetectedVRUData',Term1,Term2,Term3,Term4},
{Res1,Bytes5}.

enc_DetectedObstacleData(Val) ->
[begin
%% attribute obstSize(1) with type ObstacleSize
Enc1@element = element(2, Val),
enc_ObstacleSize(Enc1@element)
end|begin
%% attribute obstSizeConfidence(2) with type ObstacleSizeConfidence
Enc2@element = element(3, Val),
enc_ObstacleSizeConfidence(Enc2@element)
end].


dec_DetectedObstacleData(Bytes) ->

%% attribute obstSize(1) with type ObstacleSize
{Term1,Bytes1} = dec_ObstacleSize(Bytes),

%% attribute obstSizeConfidence(2) with type ObstacleSizeConfidence
{Term2,Bytes2} = dec_ObstacleSizeConfidence(Bytes1),
Res1 = {'DetectedObstacleData',Term1,Term2},
{Res1,Bytes2}.

enc_ObjectType(Val) ->
if Val =:= unknown ->
<<0:1,0:2>>;
Val =:= vehicle ->
<<0:1,1:2>>;
Val =:= vru ->
<<0:1,2:2>>;
Val =:= animal ->
<<0:1,3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_ObjectType(Bytes) ->
begin
{V1@V0,V1@Buf1} = case Bytes of
<<0:1,V1@V3:2,V1@Buf4/bitstring>> ->
V1@Int5 = case V1@V3 of
0 -> unknown;
1 -> vehicle;
2 -> vru;
3 -> animal
end,
{V1@Int5,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7};
<<1:1,V1@Buf5/bitstring>> ->
{V1@V6,V1@Buf7} = case V1@Buf5 of
<<0:1,V1@V9:7,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10};
<<1:1,0:1,V1@V10:14,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
{V1@V10,V1@Buf11};
<<1:1,1:1,V1@V10:6,V1@Buf11/bitstring>> when V1@V10 =/= 0 ->
V1@Mul12 = V1@V10 * 16384,
{V1@Mul12,V1@Buf11}
end,
<<V1@V13:V1@V6/unit:8,V1@Buf14/bitstring>> = V1@Buf7,
{V1@V13,V1@Buf14}
end,
V1@Int15 = case V1@V3 of
_ -> {asn1_enum,V1@V3}
end,
{V1@Int15,V1@Buf4}
end,
{V1@V0,V1@Buf1}
end.

enc_ObjectID(Val) ->
if Val bsr 16 =:= 0 ->
<<Val:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ObjectID(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_ClassificationConfidence(Val) ->
if 0 =< Val, Val < 102 ->
<<Val:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ClassificationConfidence(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_MeasurementTimeOffset(Val) ->
Val@sub = Val - -1500,
if 0 =< Val@sub, Val@sub < 3001 ->
<<Val@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MeasurementTimeOffset(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -1500,
{V1@Add2,V1@Buf1}
end.

enc_PositionOffsetXYZ(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute offsetX(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - -32767,
if 0 =< Enc2@element@sub, Enc2@element@sub < 65535 ->
<<Enc2@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute offsetY(2) with type INTEGER
Enc4@element = element(3, Val),
Enc4@element@sub = Enc4@element - -32767,
if 0 =< Enc4@element@sub, Enc4@element@sub < 65535 ->
<<Enc4@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end|begin
%% attribute offsetZ(3) with type INTEGER
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc6@element@sub = Enc6@element - -32767,
if 0 =< Enc6@element@sub, Enc6@element@sub < 65535 ->
<<Enc6@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end
end
end].


dec_PositionOffsetXYZ(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute offsetX(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32767,
{V2@Add2,V2@Buf1}
end,

%% attribute offsetY(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -32767,
{V3@Add2,V3@Buf1}
end,

%% attribute offsetZ(3) with type INTEGER
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + -32767,
{V4@Add2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = {'PositionOffsetXYZ',Term1,Term2,Term3},
{Res1,Bytes4}.

enc_ObjectDistance(Val) ->
Val@sub = Val - -32767,
if 0 =< Val@sub, Val@sub < 65535 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ObjectDistance(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32767,
{V1@Add2,V1@Buf1}
end.

enc_Attitude(Val) ->
[begin
%% attribute pitch(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -7200,
if 0 =< Enc1@element@sub, Enc1@element@sub < 14401 ->
<<Enc1@element@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute roll(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -14400,
if 0 =< Enc3@element@sub, Enc3@element@sub < 28801 ->
<<Enc3@element@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute yaw(3) with type INTEGER
Enc5@element = element(4, Val),
Enc5@element@sub = Enc5@element - -14400,
if 0 =< Enc5@element@sub, Enc5@element@sub < 28801 ->
<<Enc5@element@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_Attitude(Bytes) ->

%% attribute pitch(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -7200,
{V1@Add2,V1@Buf1}
end,

%% attribute roll(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:15,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -14400,
{V2@Add2,V2@Buf1}
end,

%% attribute yaw(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + -14400,
{V3@Add2,V3@Buf1}
end,
Res1 = {'Attitude',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_PitchDetected(Val) ->
Val@sub = Val - -7200,
if 0 =< Val@sub, Val@sub < 14401 ->
<<Val@sub:14>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_PitchDetected(Bytes) ->
begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -7200,
{V1@Add2,V1@Buf1}
end.

enc_RollDetected(Val) ->
Val@sub = Val - -14400,
if 0 =< Val@sub, Val@sub < 28801 ->
<<Val@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RollDetected(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -14400,
{V1@Add2,V1@Buf1}
end.

enc_YawDetected(Val) ->
Val@sub = Val - -14400,
if 0 =< Val@sub, Val@sub < 28801 ->
<<Val@sub:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_YawDetected(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -14400,
{V1@Add2,V1@Buf1}
end.

enc_AttitudeConfidence(Val) ->
[begin
%% attribute pitchConfidence(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= unavailable ->
<<0:3>>;
Enc1@element =:= prec10deg ->
<<1:3>>;
Enc1@element =:= prec05deg ->
<<2:3>>;
Enc1@element =:= prec01deg ->
<<3:3>>;
Enc1@element =:= 'prec0-1deg' ->
<<4:3>>;
Enc1@element =:= 'prec0-05deg' ->
<<5:3>>;
Enc1@element =:= 'prec0-01deg' ->
<<6:3>>;
Enc1@element =:= 'prec0-0125deg' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end,
begin
%% attribute rollConfidence(2) with type ENUMERATED
Enc3@element = element(3, Val),
if Enc3@element =:= unavailable ->
<<0:3>>;
Enc3@element =:= prec10deg ->
<<1:3>>;
Enc3@element =:= prec05deg ->
<<2:3>>;
Enc3@element =:= prec01deg ->
<<3:3>>;
Enc3@element =:= 'prec0-1deg' ->
<<4:3>>;
Enc3@element =:= 'prec0-05deg' ->
<<5:3>>;
Enc3@element =:= 'prec0-01deg' ->
<<6:3>>;
Enc3@element =:= 'prec0-0125deg' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc3@element}}})
end
end|begin
%% attribute yawConfidence(3) with type ENUMERATED
Enc5@element = element(4, Val),
if Enc5@element =:= unavailable ->
<<0:3>>;
Enc5@element =:= prec10deg ->
<<1:3>>;
Enc5@element =:= prec05deg ->
<<2:3>>;
Enc5@element =:= prec01deg ->
<<3:3>>;
Enc5@element =:= 'prec0-1deg' ->
<<4:3>>;
Enc5@element =:= 'prec0-05deg' ->
<<5:3>>;
Enc5@element =:= 'prec0-01deg' ->
<<6:3>>;
Enc5@element =:= 'prec0-0125deg' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end].


dec_AttitudeConfidence(Bytes) ->

%% attribute pitchConfidence(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> prec10deg;
2 -> prec05deg;
3 -> prec01deg;
4 -> 'prec0-1deg';
5 -> 'prec0-05deg';
6 -> 'prec0-01deg';
7 -> 'prec0-0125deg'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute rollConfidence(2) with type ENUMERATED
{Term2,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> unavailable;
1 -> prec10deg;
2 -> prec05deg;
3 -> prec01deg;
4 -> 'prec0-1deg';
5 -> 'prec0-05deg';
6 -> 'prec0-01deg';
7 -> 'prec0-0125deg'
end,
{V2@Int2,V2@Buf1}
end,

%% attribute yawConfidence(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:3,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> prec10deg;
2 -> prec05deg;
3 -> prec01deg;
4 -> 'prec0-1deg';
5 -> 'prec0-05deg';
6 -> 'prec0-01deg';
7 -> 'prec0-0125deg'
end,
{V3@Int2,V3@Buf1}
end,
Res1 = {'AttitudeConfidence',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_AngularVelocity(Val) ->
[begin
%% attribute pitchRate(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -32767,
if 0 =< Enc1@element@sub, Enc1@element@sub < 65535 ->
<<Enc1@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute rollRate(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -32767,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_AngularVelocity(Bytes) ->

%% attribute pitchRate(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32767,
{V1@Add2,V1@Buf1}
end,

%% attribute rollRate(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32767,
{V2@Add2,V2@Buf1}
end,
Res1 = {'AngularVelocity',Term1,Term2},
{Res1,Bytes2}.

enc_PitchRate(Val) ->
Val@sub = Val - -32767,
if 0 =< Val@sub, Val@sub < 65535 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_PitchRate(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32767,
{V1@Add2,V1@Buf1}
end.

enc_RollRate(Val) ->
Val@sub = Val - -32767,
if 0 =< Val@sub, Val@sub < 65535 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_RollRate(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32767,
{V1@Add2,V1@Buf1}
end.

enc_AngularVelocityConfidence(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute pitchRateConfidence(1) with type ENUMERATED
Enc3@element = element(2, Val),
if Enc3@element =:= asn1_NOVALUE ->
[];
Enc3@element =:= unavailable ->
<<0:3>>;
Enc3@element =:= 'degSec-100-00' ->
<<1:3>>;
Enc3@element =:= 'degSec-010-00' ->
<<2:3>>;
Enc3@element =:= 'degSec-005-00' ->
<<3:3>>;
Enc3@element =:= 'degSec-001-00' ->
<<4:3>>;
Enc3@element =:= 'degSec-000-10' ->
<<5:3>>;
Enc3@element =:= 'degSec-000-05' ->
<<6:3>>;
Enc3@element =:= 'degSec-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc3@element}}})
end
end|begin
%% attribute rollRateConfidence(2) with type ENUMERATED
Enc6@element = element(3, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element =:= unavailable ->
<<0:3>>;
Enc6@element =:= 'degSec-100-00' ->
<<1:3>>;
Enc6@element =:= 'degSec-010-00' ->
<<2:3>>;
Enc6@element =:= 'degSec-005-00' ->
<<3:3>>;
Enc6@element =:= 'degSec-001-00' ->
<<4:3>>;
Enc6@element =:= 'degSec-000-10' ->
<<5:3>>;
Enc6@element =:= 'degSec-000-05' ->
<<6:3>>;
Enc6@element =:= 'degSec-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc6@element}}})
end
end].


dec_AngularVelocityConfidence(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute pitchRateConfidence(1) with type ENUMERATED
{Term1,Bytes2} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> unavailable;
1 -> 'degSec-100-00';
2 -> 'degSec-010-00';
3 -> 'degSec-005-00';
4 -> 'degSec-001-00';
5 -> 'degSec-000-10';
6 -> 'degSec-000-05';
7 -> 'degSec-000-01'
end,
{V2@Int2,V2@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes1}
end,

%% attribute rollRateConfidence(2) with type ENUMERATED
{Term2,Bytes3} = case Opt band 1 of
1 ->
begin
<<V3@V0:3,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> 'degSec-100-00';
2 -> 'degSec-010-00';
3 -> 'degSec-005-00';
4 -> 'degSec-001-00';
5 -> 'degSec-000-10';
6 -> 'degSec-000-05';
7 -> 'degSec-000-01'
end,
{V3@Int2,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,
Res1 = {'AngularVelocityConfidence',Term1,Term2},
{Res1,Bytes3}.

enc_PitchRateConfidence(Val) ->
if Val =:= unavailable ->
<<0:3>>;
Val =:= 'degSec-100-00' ->
<<1:3>>;
Val =:= 'degSec-010-00' ->
<<2:3>>;
Val =:= 'degSec-005-00' ->
<<3:3>>;
Val =:= 'degSec-001-00' ->
<<4:3>>;
Val =:= 'degSec-000-10' ->
<<5:3>>;
Val =:= 'degSec-000-05' ->
<<6:3>>;
Val =:= 'degSec-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_PitchRateConfidence(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> 'degSec-100-00';
2 -> 'degSec-010-00';
3 -> 'degSec-005-00';
4 -> 'degSec-001-00';
5 -> 'degSec-000-10';
6 -> 'degSec-000-05';
7 -> 'degSec-000-01'
end,
{V1@Int2,V1@Buf1}
end.

enc_RollRateConfidence(Val) ->
if Val =:= unavailable ->
<<0:3>>;
Val =:= 'degSec-100-00' ->
<<1:3>>;
Val =:= 'degSec-010-00' ->
<<2:3>>;
Val =:= 'degSec-005-00' ->
<<3:3>>;
Val =:= 'degSec-001-00' ->
<<4:3>>;
Val =:= 'degSec-000-10' ->
<<5:3>>;
Val =:= 'degSec-000-05' ->
<<6:3>>;
Val =:= 'degSec-000-01' ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_RollRateConfidence(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> 'degSec-100-00';
2 -> 'degSec-010-00';
3 -> 'degSec-005-00';
4 -> 'degSec-001-00';
5 -> 'degSec-000-10';
6 -> 'degSec-000-05';
7 -> 'degSec-000-01'
end,
{V1@Int2,V1@Buf1}
end.

enc_VehicleSizeConfidence(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute vehicleWidthConfidence(1) with type ENUMERATED
Enc2@element = element(2, Val),
if Enc2@element =:= unavailable ->
<<0:4>>;
Enc2@element =:= 'size-100-00' ->
<<1:4>>;
Enc2@element =:= 'size-050-00' ->
<<2:4>>;
Enc2@element =:= 'size-020-00' ->
<<3:4>>;
Enc2@element =:= 'size-010-00' ->
<<4:4>>;
Enc2@element =:= 'size-005-00' ->
<<5:4>>;
Enc2@element =:= 'size-002-00' ->
<<6:4>>;
Enc2@element =:= 'size-001-00' ->
<<7:4>>;
Enc2@element =:= 'size-000-50' ->
<<8:4>>;
Enc2@element =:= 'size-000-20' ->
<<9:4>>;
Enc2@element =:= 'size-000-10' ->
<<10:4>>;
Enc2@element =:= 'size-000-05' ->
<<11:4>>;
Enc2@element =:= 'size-000-02' ->
<<12:4>>;
Enc2@element =:= 'size-000-01' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc2@element}}})
end
end,
begin
%% attribute vehicleLengthConfidence(2) with type ENUMERATED
Enc4@element = element(3, Val),
if Enc4@element =:= unavailable ->
<<0:4>>;
Enc4@element =:= 'size-100-00' ->
<<1:4>>;
Enc4@element =:= 'size-050-00' ->
<<2:4>>;
Enc4@element =:= 'size-020-00' ->
<<3:4>>;
Enc4@element =:= 'size-010-00' ->
<<4:4>>;
Enc4@element =:= 'size-005-00' ->
<<5:4>>;
Enc4@element =:= 'size-002-00' ->
<<6:4>>;
Enc4@element =:= 'size-001-00' ->
<<7:4>>;
Enc4@element =:= 'size-000-50' ->
<<8:4>>;
Enc4@element =:= 'size-000-20' ->
<<9:4>>;
Enc4@element =:= 'size-000-10' ->
<<10:4>>;
Enc4@element =:= 'size-000-05' ->
<<11:4>>;
Enc4@element =:= 'size-000-02' ->
<<12:4>>;
Enc4@element =:= 'size-000-01' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc4@element}}})
end
end|begin
%% attribute vehicleHeightConfidence(3) with type ENUMERATED
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element =:= unavailable ->
<<0:4>>;
Enc6@element =:= 'size-100-00' ->
<<1:4>>;
Enc6@element =:= 'size-050-00' ->
<<2:4>>;
Enc6@element =:= 'size-020-00' ->
<<3:4>>;
Enc6@element =:= 'size-010-00' ->
<<4:4>>;
Enc6@element =:= 'size-005-00' ->
<<5:4>>;
Enc6@element =:= 'size-002-00' ->
<<6:4>>;
Enc6@element =:= 'size-001-00' ->
<<7:4>>;
Enc6@element =:= 'size-000-50' ->
<<8:4>>;
Enc6@element =:= 'size-000-20' ->
<<9:4>>;
Enc6@element =:= 'size-000-10' ->
<<10:4>>;
Enc6@element =:= 'size-000-05' ->
<<11:4>>;
Enc6@element =:= 'size-000-02' ->
<<12:4>>;
Enc6@element =:= 'size-000-01' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc6@element}}})
end
end].


dec_VehicleSizeConfidence(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute vehicleWidthConfidence(1) with type ENUMERATED
{Term1,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> unavailable;
1 -> 'size-100-00';
2 -> 'size-050-00';
3 -> 'size-020-00';
4 -> 'size-010-00';
5 -> 'size-005-00';
6 -> 'size-002-00';
7 -> 'size-001-00';
8 -> 'size-000-50';
9 -> 'size-000-20';
10 -> 'size-000-10';
11 -> 'size-000-05';
12 -> 'size-000-02';
13 -> 'size-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V2@V0}}})
end,
{V2@Int2,V2@Buf1}
end,

%% attribute vehicleLengthConfidence(2) with type ENUMERATED
{Term2,Bytes3} = begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> 'size-100-00';
2 -> 'size-050-00';
3 -> 'size-020-00';
4 -> 'size-010-00';
5 -> 'size-005-00';
6 -> 'size-002-00';
7 -> 'size-001-00';
8 -> 'size-000-50';
9 -> 'size-000-20';
10 -> 'size-000-10';
11 -> 'size-000-05';
12 -> 'size-000-02';
13 -> 'size-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V3@V0}}})
end,
{V3@Int2,V3@Buf1}
end,

%% attribute vehicleHeightConfidence(3) with type ENUMERATED
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> 'size-100-00';
2 -> 'size-050-00';
3 -> 'size-020-00';
4 -> 'size-010-00';
5 -> 'size-005-00';
6 -> 'size-002-00';
7 -> 'size-001-00';
8 -> 'size-000-50';
9 -> 'size-000-20';
10 -> 'size-000-10';
11 -> 'size-000-05';
12 -> 'size-000-02';
13 -> 'size-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V4@V0}}})
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = {'VehicleSizeConfidence',Term1,Term2,Term3},
{Res1,Bytes4}.

enc_ObstacleSize(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute width(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 10 =:= 0 ->
<<Enc2@element:10>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute length(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element bsr 10 =:= 0 ->
<<Enc4@element:10>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end|begin
%% attribute height(3) with type INTEGER
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element bsr 10 =:= 0 ->
<<Enc6@element:10>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end].


dec_ObstacleSize(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute width(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute length(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:10,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute height(3) with type INTEGER
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:10,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = {'ObstacleSize',Term1,Term2,Term3},
{Res1,Bytes4}.

enc_ObstacleSizeConfidence(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute widthConfidence(1) with type ENUMERATED
Enc2@element = element(2, Val),
if Enc2@element =:= unavailable ->
<<0:4>>;
Enc2@element =:= 'size-100-00' ->
<<1:4>>;
Enc2@element =:= 'size-050-00' ->
<<2:4>>;
Enc2@element =:= 'size-020-00' ->
<<3:4>>;
Enc2@element =:= 'size-010-00' ->
<<4:4>>;
Enc2@element =:= 'size-005-00' ->
<<5:4>>;
Enc2@element =:= 'size-002-00' ->
<<6:4>>;
Enc2@element =:= 'size-001-00' ->
<<7:4>>;
Enc2@element =:= 'size-000-50' ->
<<8:4>>;
Enc2@element =:= 'size-000-20' ->
<<9:4>>;
Enc2@element =:= 'size-000-10' ->
<<10:4>>;
Enc2@element =:= 'size-000-05' ->
<<11:4>>;
Enc2@element =:= 'size-000-02' ->
<<12:4>>;
Enc2@element =:= 'size-000-01' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc2@element}}})
end
end,
begin
%% attribute lengthConfidence(2) with type ENUMERATED
Enc4@element = element(3, Val),
if Enc4@element =:= unavailable ->
<<0:4>>;
Enc4@element =:= 'size-100-00' ->
<<1:4>>;
Enc4@element =:= 'size-050-00' ->
<<2:4>>;
Enc4@element =:= 'size-020-00' ->
<<3:4>>;
Enc4@element =:= 'size-010-00' ->
<<4:4>>;
Enc4@element =:= 'size-005-00' ->
<<5:4>>;
Enc4@element =:= 'size-002-00' ->
<<6:4>>;
Enc4@element =:= 'size-001-00' ->
<<7:4>>;
Enc4@element =:= 'size-000-50' ->
<<8:4>>;
Enc4@element =:= 'size-000-20' ->
<<9:4>>;
Enc4@element =:= 'size-000-10' ->
<<10:4>>;
Enc4@element =:= 'size-000-05' ->
<<11:4>>;
Enc4@element =:= 'size-000-02' ->
<<12:4>>;
Enc4@element =:= 'size-000-01' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc4@element}}})
end
end|begin
%% attribute heightConfidence(3) with type ENUMERATED
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element =:= unavailable ->
<<0:4>>;
Enc6@element =:= 'size-100-00' ->
<<1:4>>;
Enc6@element =:= 'size-050-00' ->
<<2:4>>;
Enc6@element =:= 'size-020-00' ->
<<3:4>>;
Enc6@element =:= 'size-010-00' ->
<<4:4>>;
Enc6@element =:= 'size-005-00' ->
<<5:4>>;
Enc6@element =:= 'size-002-00' ->
<<6:4>>;
Enc6@element =:= 'size-001-00' ->
<<7:4>>;
Enc6@element =:= 'size-000-50' ->
<<8:4>>;
Enc6@element =:= 'size-000-20' ->
<<9:4>>;
Enc6@element =:= 'size-000-10' ->
<<10:4>>;
Enc6@element =:= 'size-000-05' ->
<<11:4>>;
Enc6@element =:= 'size-000-02' ->
<<12:4>>;
Enc6@element =:= 'size-000-01' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc6@element}}})
end
end].


dec_ObstacleSizeConfidence(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute widthConfidence(1) with type ENUMERATED
{Term1,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> unavailable;
1 -> 'size-100-00';
2 -> 'size-050-00';
3 -> 'size-020-00';
4 -> 'size-010-00';
5 -> 'size-005-00';
6 -> 'size-002-00';
7 -> 'size-001-00';
8 -> 'size-000-50';
9 -> 'size-000-20';
10 -> 'size-000-10';
11 -> 'size-000-05';
12 -> 'size-000-02';
13 -> 'size-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V2@V0}}})
end,
{V2@Int2,V2@Buf1}
end,

%% attribute lengthConfidence(2) with type ENUMERATED
{Term2,Bytes3} = begin
<<V3@V0:4,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> unavailable;
1 -> 'size-100-00';
2 -> 'size-050-00';
3 -> 'size-020-00';
4 -> 'size-010-00';
5 -> 'size-005-00';
6 -> 'size-002-00';
7 -> 'size-001-00';
8 -> 'size-000-50';
9 -> 'size-000-20';
10 -> 'size-000-10';
11 -> 'size-000-05';
12 -> 'size-000-02';
13 -> 'size-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V3@V0}}})
end,
{V3@Int2,V3@Buf1}
end,

%% attribute heightConfidence(3) with type ENUMERATED
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
<<V4@V0:4,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> unavailable;
1 -> 'size-100-00';
2 -> 'size-050-00';
3 -> 'size-020-00';
4 -> 'size-010-00';
5 -> 'size-005-00';
6 -> 'size-002-00';
7 -> 'size-001-00';
8 -> 'size-000-50';
9 -> 'size-000-20';
10 -> 'size-000-10';
11 -> 'size-000-05';
12 -> 'size-000-02';
13 -> 'size-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V4@V0}}})
end,
{V4@Int2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = {'ObstacleSizeConfidence',Term1,Term2,Term3},
{Res1,Bytes4}.

enc_SizeValue(Val) ->
if Val bsr 10 =:= 0 ->
<<Val:10>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SizeValue(Bytes) ->
begin
<<V1@V0:10,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SizeValueConfidence(Val) ->
if Val =:= unavailable ->
<<0:4>>;
Val =:= 'size-100-00' ->
<<1:4>>;
Val =:= 'size-050-00' ->
<<2:4>>;
Val =:= 'size-020-00' ->
<<3:4>>;
Val =:= 'size-010-00' ->
<<4:4>>;
Val =:= 'size-005-00' ->
<<5:4>>;
Val =:= 'size-002-00' ->
<<6:4>>;
Val =:= 'size-001-00' ->
<<7:4>>;
Val =:= 'size-000-50' ->
<<8:4>>;
Val =:= 'size-000-20' ->
<<9:4>>;
Val =:= 'size-000-10' ->
<<10:4>>;
Val =:= 'size-000-05' ->
<<11:4>>;
Val =:= 'size-000-02' ->
<<12:4>>;
Val =:= 'size-000-01' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SizeValueConfidence(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unavailable;
1 -> 'size-100-00';
2 -> 'size-050-00';
3 -> 'size-020-00';
4 -> 'size-010-00';
5 -> 'size-005-00';
6 -> 'size-002-00';
7 -> 'size-001-00';
8 -> 'size-000-50';
9 -> 'size-000-20';
10 -> 'size-000-10';
11 -> 'size-000-05';
12 -> 'size-000-02';
13 -> 'size-000-01';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

typeinfo('SensorDataSharingMessage') ->
  {sequence,'SensorDataSharingMessage',8,[{<<109,115,103,67,110,116>>,{'INTEGER',{0,127}},mandatory},{<<115,111,117,114,99,101,73,68>>,octet_string,mandatory},{<<101,113,117,105,112,109,101,110,116,84,121,112,101>>,{'ENUMERATED_EXT',#{unknown => 0,vru => 3,rsu => 1,obu => 2}},mandatory},{<<115,68,83,77,84,105,109,101,83,116,97,109,112>>,{typeinfo,{'Common','DDateTime'}},mandatory},{<<114,101,102,80,111,115>>,{typeinfo,{'Common','Position3D'}},mandatory},{<<114,101,102,80,111,115,88,89,67,111,110,102>>,{typeinfo,{'Common','PositionalAccuracy'}},mandatory},{<<114,101,102,80,111,115,69,108,67,111,110,102>>,{'ENUMERATED',#{unavailable => 0,'elev-500-00' => 1,'elev-200-00' => 2,'elev-100-00' => 3,'elev-050-00' => 4,'elev-020-00' => 5,'elev-010-00' => 6,'elev-005-00' => 7,'elev-002-00' => 8,'elev-001-00' => 9,'elev-000-50' => 10,'elev-000-20' => 11,'elev-000-10' => 12,'elev-000-05' => 13,'elev-000-02' => 14,'elev-000-01' => 15}},'OPTIONAL'},{<<111,98,106,101,99,116,115>>,{typeinfo,{'SensorDataSharingMessage','DetectedObjectList'}},mandatory}]};
typeinfo('EquipmentType') ->
  {'ENUMERATED_EXT',#{unknown => 0,vru => 3,rsu => 1,obu => 2}};
typeinfo('DetectedObjectList') ->
  {sof,{typeinfo,{'SensorDataSharingMessage','DetectedObjectData'}}};
typeinfo('DetectedObjectData') ->
  {sequence,'DetectedObjectData',2,[{<<100,101,116,79,98,106,67,111,109,109,111,110>>,{typeinfo,{'SensorDataSharingMessage','DetectedObjectCommonData'}},mandatory},{<<100,101,116,79,98,106,79,112,116,68,97,116,97>>,{typeinfo,{'SensorDataSharingMessage','DetectedObjectOptionalData'}},'OPTIONAL'}]};
typeinfo('DetectedObjectOptionalData') ->
  {choice,#{<<100,101,116,79,98,115,116>> => {typeinfo,{'SensorDataSharingMessage','DetectedObstacleData'}},<<100,101,116,86,82,85>> => {typeinfo,{'SensorDataSharingMessage','DetectedVRUData'}},<<100,101,116,86,101,104>> => {typeinfo,{'SensorDataSharingMessage','DetectedVehicleData'}}}};
typeinfo('DetectedObjectCommonData') ->
  {sequence,'DetectedObjectCommonData',18,[{<<111,98,106,84,121,112,101>>,{'ENUMERATED_EXT',#{unknown => 0,vehicle => 1,animal => 3,vru => 2}},mandatory},{<<111,98,106,84,121,112,101,67,102,100>>,{'INTEGER',{0,101}},mandatory},{<<111,98,106,101,99,116,73,68>>,{'INTEGER',{0,65535}},mandatory},{<<109,101,97,115,117,114,101,109,101,110,116,84,105,109,101>>,{'INTEGER',{-1500,1500}},mandatory},{<<116,105,109,101,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{'time-000-000-1' => 18,'time-000-000-000-000-05' => 37,'time-050-000' => 2,'time-000-000-005' => 22,'time-000-000-000-002' => 32,'time-000-000-001' => 24,'time-010-000' => 4,'time-000-005' => 13,'time-000-000-000-2' => 26,'time-000-100' => 9,'time-001-000' => 6,'time-000-000-000-000-5' => 34,'time-000-000-05' => 19,'time-002-000' => 5,'time-000-000-2' => 17,'time-000-000-000-05' => 28,'time-000-000-02' => 20,'time-000-002' => 14,'time-000-010' => 12,'time-000-500' => 7,'time-000-000-000-1' => 27,'time-100-000' => 1,'time-000-000-000-000-02' => 38,'time-000-000-01' => 21,'time-000-200' => 8,'time-000-050' => 10,'time-000-000-000-000-1' => 36,'time-000-000-000-000-01' => 39,'time-000-020' => 11,'time-000-000-000-001' => 33,'time-000-000-000-005' => 31,'time-000-000-5' => 16,'time-000-000-002' => 23,'time-000-000-000-000-2' => 35,'time-000-000-000-01' => 30,'time-000-000-000-5' => 25,unavailable => 0,'time-000-001' => 15,'time-020-000' => 3,'time-000-000-000-02' => 29}},mandatory},{<<112,111,115>>,{typeinfo,{'SensorDataSharingMessage','PositionOffsetXYZ'}},mandatory},{<<112,111,115,67,111,110,102,105,100,101,110,99,101>>,{typeinfo,{'Common','PositionConfidenceSet'}},mandatory},{<<115,112,101,101,100>>,{'INTEGER',{0,8191}},mandatory},{<<115,112,101,101,100,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,prec100ms => 1,prec10ms => 2,prec5ms => 3,prec1ms => 4,'prec0-1ms' => 5,'prec0-05ms' => 6,'prec0-01ms' => 7}},mandatory},{<<115,112,101,101,100,90>>,{'INTEGER',{0,8191}},'OPTIONAL'},{<<115,112,101,101,100,67,111,110,102,105,100,101,110,99,101,90>>,{'ENUMERATED',#{unavailable => 0,prec100ms => 1,prec10ms => 2,prec5ms => 3,prec1ms => 4,'prec0-1ms' => 5,'prec0-05ms' => 6,'prec0-01ms' => 7}},'OPTIONAL'},{<<104,101,97,100,105,110,103>>,{'INTEGER',{0,28800}},mandatory},{<<104,101,97,100,105,110,103,67,111,110,102>>,{'ENUMERATED',#{unavailable => 0,prec10deg => 1,prec05deg => 2,prec01deg => 3,'prec0-1deg' => 4,'prec0-05deg' => 5,'prec0-01deg' => 6,'prec0-0125deg' => 7}},mandatory},{<<97,99,99,101,108,52,119,97,121>>,{typeinfo,{'Common','AccelerationSet4Way'}},'OPTIONAL'},{<<97,99,99,67,102,100,88>>,{'ENUMERATED',#{unavailable => 0,'accl-100-00' => 1,'accl-010-00' => 2,'accl-005-00' => 3,'accl-001-00' => 4,'accl-000-10' => 5,'accl-000-05' => 6,'accl-000-01' => 7}},'OPTIONAL'},{<<97,99,99,67,102,100,89>>,{'ENUMERATED',#{unavailable => 0,'accl-100-00' => 1,'accl-010-00' => 2,'accl-005-00' => 3,'accl-001-00' => 4,'accl-000-10' => 5,'accl-000-05' => 6,'accl-000-01' => 7}},'OPTIONAL'},{<<97,99,99,67,102,100,90>>,{'ENUMERATED',#{unavailable => 0,'accl-100-00' => 1,'accl-010-00' => 2,'accl-005-00' => 3,'accl-001-00' => 4,'accl-000-10' => 5,'accl-000-05' => 6,'accl-000-01' => 7}},'OPTIONAL'},{<<97,99,99,67,102,100,89,97,119>>,{'ENUMERATED',#{unavailable => 0,'degSec-100-00' => 1,'degSec-010-00' => 2,'degSec-005-00' => 3,'degSec-001-00' => 4,'degSec-000-10' => 5,'degSec-000-05' => 6,'degSec-000-01' => 7}},'OPTIONAL'}]};
typeinfo('DetectedVehicleData') ->
  {sequence,'DetectedVehicleData',10,[{<<108,105,103,104,116,115>>,{bit_string_nnl,[{lowBeamHeadlightsOn,0},{highBeamHeadlightsOn,1},{leftTurnSignalOn,2},{rightTurnSignalOn,3},{hazardSignalOn,4},{automaticLightControlOn,5},{daytimeRunningLightsOn,6},{fogLightOn,7},{parkingLightsOn,8}]},'OPTIONAL'},{<<118,101,104,65,116,116,105,116,117,100,101>>,{typeinfo,{'SensorDataSharingMessage','Attitude'}},'OPTIONAL'},{<<118,101,104,65,116,116,105,116,117,100,101,67,111,110,102,105,100,101,110,99,101>>,{typeinfo,{'SensorDataSharingMessage','AttitudeConfidence'}},'OPTIONAL'},{<<118,101,104,65,110,103,86,101,108>>,{typeinfo,{'SensorDataSharingMessage','AngularVelocity'}},'OPTIONAL'},{<<118,101,104,65,110,103,86,101,108,67,111,110,102,105,100,101,110,99,101>>,{typeinfo,{'SensorDataSharingMessage','AngularVelocityConfidence'}},'OPTIONAL'},{<<115,105,122,101>>,{typeinfo,{'Common','VehicleSize'}},'OPTIONAL'},{<<104,101,105,103,104,116>>,{'INTEGER',{0,127}},'OPTIONAL'},{<<118,101,104,105,99,108,101,83,105,122,101,67,111,110,102,105,100,101,110,99,101>>,{typeinfo,{'SensorDataSharingMessage','VehicleSizeConfidence'}},'OPTIONAL'},{<<118,101,104,105,99,108,101,67,108,97,115,115>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<99,108,97,115,115,67,111,110,102>>,{'INTEGER',{0,101}},'OPTIONAL'}]};
typeinfo('DetectedVRUData') ->
  {sequence,'DetectedVRUData',4,[{<<98,97,115,105,99,84,121,112,101>>,{'ENUMERATED_EXT',#{unavailable => 0,aPEDESTRIAN => 1,aPEDALCYCLIST => 2,aPUBLICSAFETYWORKER => 3,anANIMAL => 4}},'OPTIONAL'},{<<112,114,111,112,117,108,115,105,111,110>>,{typeinfo,{'PersonalSafetyMessage','PropelledInformation'}},'OPTIONAL'},{<<97,116,116,97,99,104,109,101,110,116>>,{'ENUMERATED_EXT',#{unavailable => 0,wheelchair => 4,pet => 6,stroller => 1,bicycleTrailer => 2,cart => 3,otherWalkAssistAttachments => 5}},'OPTIONAL'},{<<114,97,100,105,117,115>>,{'INTEGER',{0,200}},'OPTIONAL'}]};
typeinfo('DetectedObstacleData') ->
  {sequence,'DetectedObstacleData',2,[{<<111,98,115,116,83,105,122,101>>,{typeinfo,{'SensorDataSharingMessage','ObstacleSize'}},mandatory},{<<111,98,115,116,83,105,122,101,67,111,110,102,105,100,101,110,99,101>>,{typeinfo,{'SensorDataSharingMessage','ObstacleSizeConfidence'}},mandatory}]};
typeinfo('ObjectType') ->
  {'ENUMERATED_EXT',#{unknown => 0,vehicle => 1,animal => 3,vru => 2}};
typeinfo('ObjectID') ->
  {'INTEGER',{0,65535}};
typeinfo('ClassificationConfidence') ->
  {'INTEGER',{0,101}};
typeinfo('MeasurementTimeOffset') ->
  {'INTEGER',{-1500,1500}};
typeinfo('PositionOffsetXYZ') ->
  {sequence,'PositionOffsetXYZ',3,[{<<111,102,102,115,101,116,88>>,{'INTEGER',{-32767,32767}},mandatory},{<<111,102,102,115,101,116,89>>,{'INTEGER',{-32767,32767}},mandatory},{<<111,102,102,115,101,116,90>>,{'INTEGER',{-32767,32767}},'OPTIONAL'}]};
typeinfo('ObjectDistance') ->
  {'INTEGER',{-32767,32767}};
typeinfo('Attitude') ->
  {sequence,'Attitude',3,[{<<112,105,116,99,104>>,{'INTEGER',{-7200,7200}},mandatory},{<<114,111,108,108>>,{'INTEGER',{-14400,14400}},mandatory},{<<121,97,119>>,{'INTEGER',{-14400,14400}},mandatory}]};
typeinfo('PitchDetected') ->
  {'INTEGER',{-7200,7200}};
typeinfo('RollDetected') ->
  {'INTEGER',{-14400,14400}};
typeinfo('YawDetected') ->
  {'INTEGER',{-14400,14400}};
typeinfo('AttitudeConfidence') ->
  {sequence,'AttitudeConfidence',3,[{<<112,105,116,99,104,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,prec10deg => 1,prec05deg => 2,prec01deg => 3,'prec0-1deg' => 4,'prec0-05deg' => 5,'prec0-01deg' => 6,'prec0-0125deg' => 7}},mandatory},{<<114,111,108,108,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,prec10deg => 1,prec05deg => 2,prec01deg => 3,'prec0-1deg' => 4,'prec0-05deg' => 5,'prec0-01deg' => 6,'prec0-0125deg' => 7}},mandatory},{<<121,97,119,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,prec10deg => 1,prec05deg => 2,prec01deg => 3,'prec0-1deg' => 4,'prec0-05deg' => 5,'prec0-01deg' => 6,'prec0-0125deg' => 7}},mandatory}]};
typeinfo('AngularVelocity') ->
  {sequence,'AngularVelocity',2,[{<<112,105,116,99,104,82,97,116,101>>,{'INTEGER',{-32767,32767}},mandatory},{<<114,111,108,108,82,97,116,101>>,{'INTEGER',{-32767,32767}},mandatory}]};
typeinfo('PitchRate') ->
  {'INTEGER',{-32767,32767}};
typeinfo('RollRate') ->
  {'INTEGER',{-32767,32767}};
typeinfo('AngularVelocityConfidence') ->
  {sequence,'AngularVelocityConfidence',2,[{<<112,105,116,99,104,82,97,116,101,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,'degSec-100-00' => 1,'degSec-010-00' => 2,'degSec-005-00' => 3,'degSec-001-00' => 4,'degSec-000-10' => 5,'degSec-000-05' => 6,'degSec-000-01' => 7}},'OPTIONAL'},{<<114,111,108,108,82,97,116,101,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,'degSec-100-00' => 1,'degSec-010-00' => 2,'degSec-005-00' => 3,'degSec-001-00' => 4,'degSec-000-10' => 5,'degSec-000-05' => 6,'degSec-000-01' => 7}},'OPTIONAL'}]};
typeinfo('PitchRateConfidence') ->
  {'ENUMERATED',#{unavailable => 0,'degSec-100-00' => 1,'degSec-010-00' => 2,'degSec-005-00' => 3,'degSec-001-00' => 4,'degSec-000-10' => 5,'degSec-000-05' => 6,'degSec-000-01' => 7}};
typeinfo('RollRateConfidence') ->
  {'ENUMERATED',#{unavailable => 0,'degSec-100-00' => 1,'degSec-010-00' => 2,'degSec-005-00' => 3,'degSec-001-00' => 4,'degSec-000-10' => 5,'degSec-000-05' => 6,'degSec-000-01' => 7}};
typeinfo('VehicleSizeConfidence') ->
  {sequence,'VehicleSizeConfidence',3,[{<<118,101,104,105,99,108,101,87,105,100,116,104,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,'size-100-00' => 1,'size-050-00' => 2,'size-020-00' => 3,'size-010-00' => 4,'size-005-00' => 5,'size-002-00' => 6,'size-001-00' => 7,'size-000-50' => 8,'size-000-20' => 9,'size-000-10' => 10,'size-000-05' => 11,'size-000-02' => 12,'size-000-01' => 13}},mandatory},{<<118,101,104,105,99,108,101,76,101,110,103,116,104,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,'size-100-00' => 1,'size-050-00' => 2,'size-020-00' => 3,'size-010-00' => 4,'size-005-00' => 5,'size-002-00' => 6,'size-001-00' => 7,'size-000-50' => 8,'size-000-20' => 9,'size-000-10' => 10,'size-000-05' => 11,'size-000-02' => 12,'size-000-01' => 13}},mandatory},{<<118,101,104,105,99,108,101,72,101,105,103,104,116,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,'size-100-00' => 1,'size-050-00' => 2,'size-020-00' => 3,'size-010-00' => 4,'size-005-00' => 5,'size-002-00' => 6,'size-001-00' => 7,'size-000-50' => 8,'size-000-20' => 9,'size-000-10' => 10,'size-000-05' => 11,'size-000-02' => 12,'size-000-01' => 13}},'OPTIONAL'}]};
typeinfo('ObstacleSize') ->
  {sequence,'ObstacleSize',3,[{<<119,105,100,116,104>>,{'INTEGER',{0,1023}},mandatory},{<<108,101,110,103,116,104>>,{'INTEGER',{0,1023}},mandatory},{<<104,101,105,103,104,116>>,{'INTEGER',{0,1023}},'OPTIONAL'}]};
typeinfo('ObstacleSizeConfidence') ->
  {sequence,'ObstacleSizeConfidence',3,[{<<119,105,100,116,104,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,'size-100-00' => 1,'size-050-00' => 2,'size-020-00' => 3,'size-010-00' => 4,'size-005-00' => 5,'size-002-00' => 6,'size-001-00' => 7,'size-000-50' => 8,'size-000-20' => 9,'size-000-10' => 10,'size-000-05' => 11,'size-000-02' => 12,'size-000-01' => 13}},mandatory},{<<108,101,110,103,116,104,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,'size-100-00' => 1,'size-050-00' => 2,'size-020-00' => 3,'size-010-00' => 4,'size-005-00' => 5,'size-002-00' => 6,'size-001-00' => 7,'size-000-50' => 8,'size-000-20' => 9,'size-000-10' => 10,'size-000-05' => 11,'size-000-02' => 12,'size-000-01' => 13}},mandatory},{<<104,101,105,103,104,116,67,111,110,102,105,100,101,110,99,101>>,{'ENUMERATED',#{unavailable => 0,'size-100-00' => 1,'size-050-00' => 2,'size-020-00' => 3,'size-010-00' => 4,'size-005-00' => 5,'size-002-00' => 6,'size-001-00' => 7,'size-000-50' => 8,'size-000-20' => 9,'size-000-10' => 10,'size-000-05' => 11,'size-000-02' => 12,'size-000-01' => 13}},'OPTIONAL'}]};
typeinfo('SizeValue') ->
  {'INTEGER',{0,1023}};
typeinfo('SizeValueConfidence') ->
  {'ENUMERATED',#{unavailable => 0,'size-100-00' => 1,'size-050-00' => 2,'size-020-00' => 3,'size-010-00' => 4,'size-005-00' => 5,'size-002-00' => 6,'size-001-00' => 7,'size-000-50' => 8,'size-000-20' => 9,'size-000-10' => 10,'size-000-05' => 11,'size-000-02' => 12,'size-000-01' => 13}};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

bit_string_name2pos_2([lowBeamHeadlightsOn | T]) ->
    [0 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([highBeamHeadlightsOn | T]) ->
    [1 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([leftTurnSignalOn | T]) ->
    [2 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([rightTurnSignalOn | T]) ->
    [3 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([hazardSignalOn | T]) ->
    [4 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([automaticLightControlOn | T]) ->
    [5 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([daytimeRunningLightsOn | T]) ->
    [6 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([fogLightOn | T]) ->
    [7 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([parkingLightsOn | T]) ->
    [8 | bit_string_name2pos_2(T)];
bit_string_name2pos_2([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_2(T)];
bit_string_name2pos_2([]) ->
    [];
bit_string_name2pos_2(_) ->
    throw(invalid).

dec_components1(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components1(Num, Bytes, Acc) ->
{Term,Remain} = dec_DetectedObjectData(Bytes),
dec_components1(Num-1, Remain, [Term|Acc]).

adjust_trailing_zeroes(Bs0, Lb) ->
    case bit_size(Bs0) of
        Sz when Sz < Lb ->
            <<Bs0:Sz/bits,0:(Lb - Sz)>>;
        Lb ->
            Bs0;
        _ ->
            <<_:Lb/bits,Tail/bits>> = Bs0,
            Sz = Lb + bit_size(bs_drop_trailing_zeroes(Tail)),
            <<Bs:Sz/bits,_/bits>> = Bs0,
            Bs
    end.

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

bitstring_from_positions(L0, Lb) ->
    L1 = lists:sort(L0),
    L = diff(L1, -1, Lb - 1),
    << 
      <<B:(N + 0)>> ||
          {B, N} <- L
    >>.

bs_drop_trailing_zeroes(Bs) ->
    bs_drop_trailing_zeroes(Bs, bit_size(Bs)).

bs_drop_trailing_zeroes(Bs, 0) ->
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) when Sz0 < 8 ->
    <<Byte:Sz0>> = Bs0,
    Sz = Sz0 - ntz(Byte),
    <<Bs:Sz/bits,_/bits>> = Bs0,
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) ->
    Sz1 = Sz0 - 8,
    <<Bs1:Sz1/bits,Byte:8>> = Bs0,
    case ntz(Byte) of
        8 ->
            bs_drop_trailing_zeroes(Bs1, Sz1);
        Ntz ->
            Sz = Sz0 - Ntz,
            <<Bs:Sz/bits,_:Ntz/bits>> = Bs0,
            Bs
    end.

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

decode_named_bit_string(Val, NNL) ->
    Bits =
        [ 
         B ||
             <<B:1>> <= Val
        ],
    decode_named_bit_string_1(0, Bits, NNL, []).

decode_named_bit_string_1(Pos, [0 | Bt], Names, Acc) ->
    decode_named_bit_string_1(Pos + 1, Bt, Names, Acc);
decode_named_bit_string_1(Pos, [1 | Bt], Names, Acc) ->
    case lists:keyfind(Pos, 2, Names) of
        {Name, _} ->
            decode_named_bit_string_1(Pos + 1, Bt, Names, [Name | Acc]);
        false ->
            decode_named_bit_string_1(Pos + 1,
                                      Bt, Names,
                                      [{bit, Pos} | Acc])
    end;
decode_named_bit_string_1(_Pos, [], _Names, Acc) ->
    lists:reverse(Acc).

diff([H | T], Prev, Last) ->
    [{1, H - Prev} | diff(T, H, Last)];
diff([], Prev, Last) when Last >= Prev ->
    [{0, Last - Prev}];
diff([], _, _) ->
    [].

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

ntz(Byte) ->
    T = {8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2,
         0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0,
         1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1,
         0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
         2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3,
         0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
         1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1,
         0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
         3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
         0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0,
         1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1,
         0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
         2, 0, 1, 0},
    element(Byte + 1, T).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
