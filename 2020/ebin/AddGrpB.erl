%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in AddGrpB.

-module('AddGrpB').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("AddGrpB.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'AddGrpB'},
            {options,[{i,"./ebin"},uper,jer,verbose,{i,"./asn"},{outdir,"./ebin"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_Angle/1,
enc_Day/1,
enc_DayOfWeek/1,
enc_DegreesLat/1,
enc_DegreesLong/1,
enc_Elevation/1,
enc_Holiday/1,
enc_Hour/1,
enc_LatitudeDMS/1,
enc_LongitudeDMS/1,
enc_MaxTimetoChange/1,
enc_MinTimetoChange/1,
enc_Minute/1,
enc_MinutesAngle/1,
enc_Month/1,
enc_MsgCount/1,
enc_Second/1,
enc_SecondsAngle/1,
enc_SummerTime/1,
enc_TenthSecond/1,
enc_TimeRemaining/1,
enc_Year/1,
enc_LatitudeDMS2/1,
enc_LongitudeDMS2/1,
'enc_Node-LLdms-48b'/1,
'enc_Node-LLdms-80b'/1,
'enc_LaneDataAttribute-addGrpB'/1,
'enc_MovementEvent-addGrpB'/1,
'enc_NodeOffsetPointXY-addGrpB'/1,
'enc_Position3D-addGrpB'/1,
enc_TimeMark/1
]).

-export([
dec_Angle/1,
dec_Day/1,
dec_DayOfWeek/1,
dec_DegreesLat/1,
dec_DegreesLong/1,
dec_Elevation/1,
dec_Holiday/1,
dec_Hour/1,
dec_LatitudeDMS/1,
dec_LongitudeDMS/1,
dec_MaxTimetoChange/1,
dec_MinTimetoChange/1,
dec_Minute/1,
dec_MinutesAngle/1,
dec_Month/1,
dec_MsgCount/1,
dec_Second/1,
dec_SecondsAngle/1,
dec_SummerTime/1,
dec_TenthSecond/1,
dec_TimeRemaining/1,
dec_Year/1,
dec_LatitudeDMS2/1,
dec_LongitudeDMS2/1,
'dec_Node-LLdms-48b'/1,
'dec_Node-LLdms-80b'/1,
'dec_LaneDataAttribute-addGrpB'/1,
'dec_MovementEvent-addGrpB'/1,
'dec_NodeOffsetPointXY-addGrpB'/1,
'dec_Position3D-addGrpB'/1,
dec_TimeMark/1
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('AddGrpB', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('AddGrpB', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('Angle', Data) -> enc_Angle(Data);
encode_disp('Day', Data) -> enc_Day(Data);
encode_disp('DayOfWeek', Data) -> enc_DayOfWeek(Data);
encode_disp('DegreesLat', Data) -> enc_DegreesLat(Data);
encode_disp('DegreesLong', Data) -> enc_DegreesLong(Data);
encode_disp('Elevation', Data) -> enc_Elevation(Data);
encode_disp('Holiday', Data) -> enc_Holiday(Data);
encode_disp('Hour', Data) -> enc_Hour(Data);
encode_disp('LatitudeDMS', Data) -> enc_LatitudeDMS(Data);
encode_disp('LongitudeDMS', Data) -> enc_LongitudeDMS(Data);
encode_disp('MaxTimetoChange', Data) -> enc_MaxTimetoChange(Data);
encode_disp('MinTimetoChange', Data) -> enc_MinTimetoChange(Data);
encode_disp('Minute', Data) -> enc_Minute(Data);
encode_disp('MinutesAngle', Data) -> enc_MinutesAngle(Data);
encode_disp('Month', Data) -> enc_Month(Data);
encode_disp('MsgCount', Data) -> enc_MsgCount(Data);
encode_disp('Second', Data) -> enc_Second(Data);
encode_disp('SecondsAngle', Data) -> enc_SecondsAngle(Data);
encode_disp('SummerTime', Data) -> enc_SummerTime(Data);
encode_disp('TenthSecond', Data) -> enc_TenthSecond(Data);
encode_disp('TimeRemaining', Data) -> enc_TimeRemaining(Data);
encode_disp('Year', Data) -> enc_Year(Data);
encode_disp('LatitudeDMS2', Data) -> enc_LatitudeDMS2(Data);
encode_disp('LongitudeDMS2', Data) -> enc_LongitudeDMS2(Data);
encode_disp('Node-LLdms-48b', Data) -> 'enc_Node-LLdms-48b'(Data);
encode_disp('Node-LLdms-80b', Data) -> 'enc_Node-LLdms-80b'(Data);
encode_disp('LaneDataAttribute-addGrpB', Data) -> 'enc_LaneDataAttribute-addGrpB'(Data);
encode_disp('MovementEvent-addGrpB', Data) -> 'enc_MovementEvent-addGrpB'(Data);
encode_disp('NodeOffsetPointXY-addGrpB', Data) -> 'enc_NodeOffsetPointXY-addGrpB'(Data);
encode_disp('Position3D-addGrpB', Data) -> 'enc_Position3D-addGrpB'(Data);
encode_disp('TimeMark', Data) -> enc_TimeMark(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('Angle', Data) -> dec_Angle(Data);
decode_disp('Day', Data) -> dec_Day(Data);
decode_disp('DayOfWeek', Data) -> dec_DayOfWeek(Data);
decode_disp('DegreesLat', Data) -> dec_DegreesLat(Data);
decode_disp('DegreesLong', Data) -> dec_DegreesLong(Data);
decode_disp('Elevation', Data) -> dec_Elevation(Data);
decode_disp('Holiday', Data) -> dec_Holiday(Data);
decode_disp('Hour', Data) -> dec_Hour(Data);
decode_disp('LatitudeDMS', Data) -> dec_LatitudeDMS(Data);
decode_disp('LongitudeDMS', Data) -> dec_LongitudeDMS(Data);
decode_disp('MaxTimetoChange', Data) -> dec_MaxTimetoChange(Data);
decode_disp('MinTimetoChange', Data) -> dec_MinTimetoChange(Data);
decode_disp('Minute', Data) -> dec_Minute(Data);
decode_disp('MinutesAngle', Data) -> dec_MinutesAngle(Data);
decode_disp('Month', Data) -> dec_Month(Data);
decode_disp('MsgCount', Data) -> dec_MsgCount(Data);
decode_disp('Second', Data) -> dec_Second(Data);
decode_disp('SecondsAngle', Data) -> dec_SecondsAngle(Data);
decode_disp('SummerTime', Data) -> dec_SummerTime(Data);
decode_disp('TenthSecond', Data) -> dec_TenthSecond(Data);
decode_disp('TimeRemaining', Data) -> dec_TimeRemaining(Data);
decode_disp('Year', Data) -> dec_Year(Data);
decode_disp('LatitudeDMS2', Data) -> dec_LatitudeDMS2(Data);
decode_disp('LongitudeDMS2', Data) -> dec_LongitudeDMS2(Data);
decode_disp('Node-LLdms-48b', Data) -> 'dec_Node-LLdms-48b'(Data);
decode_disp('Node-LLdms-80b', Data) -> 'dec_Node-LLdms-80b'(Data);
decode_disp('LaneDataAttribute-addGrpB', Data) -> 'dec_LaneDataAttribute-addGrpB'(Data);
decode_disp('MovementEvent-addGrpB', Data) -> 'dec_MovementEvent-addGrpB'(Data);
decode_disp('NodeOffsetPointXY-addGrpB', Data) -> 'dec_NodeOffsetPointXY-addGrpB'(Data);
decode_disp('Position3D-addGrpB', Data) -> 'dec_Position3D-addGrpB'(Data);
decode_disp('TimeMark', Data) -> dec_TimeMark(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_Angle(Val) ->
if 0 =< Val, Val < 240 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Angle(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Day(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Day(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DayOfWeek(Val) ->
if Val =:= unknown ->
<<0:3>>;
Val =:= monday ->
<<1:3>>;
Val =:= tuesday ->
<<2:3>>;
Val =:= wednesday ->
<<3:3>>;
Val =:= thursday ->
<<4:3>>;
Val =:= friday ->
<<5:3>>;
Val =:= saturday ->
<<6:3>>;
Val =:= sunday ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_DayOfWeek(Bytes) ->
begin
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> unknown;
1 -> monday;
2 -> tuesday;
3 -> wednesday;
4 -> thursday;
5 -> friday;
6 -> saturday;
7 -> sunday
end,
{V1@Int2,V1@Buf1}
end.

enc_DegreesLat(Val) ->
Val@sub = Val - -90,
if 0 =< Val@sub, Val@sub < 181 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DegreesLat(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -90,
{V1@Add2,V1@Buf1}
end.

enc_DegreesLong(Val) ->
Val@sub = Val - -180,
if 0 =< Val@sub, Val@sub < 361 ->
<<Val@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DegreesLong(Bytes) ->
begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -180,
{V1@Add2,V1@Buf1}
end.

enc_Elevation(Val) ->
Val@sub = Val - -32768,
if Val@sub bsr 16 =:= 0 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Elevation(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32768,
{V1@Add2,V1@Buf1}
end.

enc_Holiday(Val) ->
if Val =:= weekday ->
<<0:1>>;
Val =:= holiday ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_Holiday(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> weekday;
1 -> holiday
end,
{V1@Int2,V1@Buf1}
end.

enc_Hour(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Hour(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_LatitudeDMS(Val) ->
Val@sub = Val - -32400000,
if 0 =< Val@sub, Val@sub < 64800001 ->
<<Val@sub:26>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LatitudeDMS(Bytes) ->
begin
<<V1@V0:26,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -32400000,
{V1@Add2,V1@Buf1}
end.

enc_LongitudeDMS(Val) ->
Val@sub = Val - -64800000,
if 0 =< Val@sub, Val@sub < 129600001 ->
<<Val@sub:27>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_LongitudeDMS(Bytes) ->
begin
<<V1@V0:27,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -64800000,
{V1@Add2,V1@Buf1}
end.

enc_MaxTimetoChange(Val) ->
if 0 =< Val, Val < 2403 ->
<<Val:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MaxTimetoChange(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_MinTimetoChange(Val) ->
if 0 =< Val, Val < 2403 ->
<<Val:12>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MinTimetoChange(Bytes) ->
begin
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Minute(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Minute(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_MinutesAngle(Val) ->
if 0 =< Val, Val < 60 ->
<<Val:6>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MinutesAngle(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Month(Val) ->
Val@sub = Val - 1,
if 0 =< Val@sub, Val@sub < 255 ->
[Val@sub];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Month(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_MsgCount(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_MsgCount(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Second(Val) ->
if 0 =< Val, Val < 61 ->
<<Val:6>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Second(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SecondsAngle(Val) ->
if 0 =< Val, Val < 6000 ->
<<Val:13>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SecondsAngle(Bytes) ->
begin
<<V1@V0:13,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_SummerTime(Val) ->
if Val =:= notInSummerTime ->
<<0:1>>;
Val =:= inSummerTime ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_SummerTime(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> notInSummerTime;
1 -> inSummerTime
end,
{V1@Int2,V1@Buf1}
end.

enc_TenthSecond(Val) ->
if 0 =< Val, Val < 10 ->
<<Val:4>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TenthSecond(Bytes) ->
begin
<<V1@V0:4,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TimeRemaining(Val) ->
if 0 =< Val, Val < 9002 ->
<<Val:14>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TimeRemaining(Bytes) ->
begin
<<V1@V0:14,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_Year(Val) ->
Val@sub = Val - 1,
if 0 =< Val@sub, Val@sub < 65535 ->
<<Val@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_Year(Bytes) ->
begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end.

enc_LatitudeDMS2(Val) ->
[begin
%% attribute d(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -90,
if 0 =< Enc1@element@sub, Enc1@element@sub < 181 ->
Enc1@element@sub;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute m(2) with type INTEGER
Enc3@element = element(3, Val),
if 0 =< Enc3@element, Enc3@element < 60 ->
<<Enc3@element:6>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute s(3) with type INTEGER
Enc5@element = element(4, Val),
if 0 =< Enc5@element, Enc5@element < 6000 ->
<<Enc5@element:13>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_LatitudeDMS2(Bytes) ->

%% attribute d(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -90,
{V1@Add2,V1@Buf1}
end,

%% attribute m(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute s(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:13,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = {'LatitudeDMS2',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_LongitudeDMS2(Val) ->
[begin
%% attribute d(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -180,
if 0 =< Enc1@element@sub, Enc1@element@sub < 361 ->
<<Enc1@element@sub:9>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute m(2) with type INTEGER
Enc3@element = element(3, Val),
if 0 =< Enc3@element, Enc3@element < 60 ->
<<Enc3@element:6>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute s(3) with type INTEGER
Enc5@element = element(4, Val),
if 0 =< Enc5@element, Enc5@element < 6000 ->
<<Enc5@element:13>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_LongitudeDMS2(Bytes) ->

%% attribute d(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:9,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -180,
{V1@Add2,V1@Buf1}
end,

%% attribute m(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:6,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute s(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:13,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = {'LongitudeDMS2',Term1,Term2,Term3},
{Res1,Bytes3}.

'enc_Node-LLdms-48b'(Val) ->
[begin
%% attribute lon(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - -64800000,
if 0 =< Enc1@element@sub, Enc1@element@sub < 129600001 ->
<<Enc1@element@sub:27>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute lat(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - -32400000,
if 0 =< Enc3@element@sub, Enc3@element@sub < 64800001 ->
<<Enc3@element@sub:26>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


'dec_Node-LLdms-48b'(Bytes) ->

%% attribute lon(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:27,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -64800000,
{V1@Add2,V1@Buf1}
end,

%% attribute lat(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:26,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -32400000,
{V2@Add2,V2@Buf1}
end,
Res1 = {'Node-LLdms-48b',Term1,Term2},
{Res1,Bytes2}.

'enc_Node-LLdms-80b'(Val) ->
[begin
%% attribute lon(1) with type LongitudeDMS2
Enc1@element = element(2, Val),
enc_LongitudeDMS2(Enc1@element)
end|begin
%% attribute lat(2) with type LatitudeDMS2
Enc2@element = element(3, Val),
enc_LatitudeDMS2(Enc2@element)
end].


'dec_Node-LLdms-80b'(Bytes) ->

%% attribute lon(1) with type LongitudeDMS2
{Term1,Bytes1} = dec_LongitudeDMS2(Bytes),

%% attribute lat(2) with type LatitudeDMS2
{Term2,Bytes2} = dec_LatitudeDMS2(Bytes1),
Res1 = {'Node-LLdms-80b',Term1,Term2},
{Res1,Bytes2}.

'enc_LaneDataAttribute-addGrpB'(Val) ->
<<0:1>>.


'dec_LaneDataAttribute-addGrpB'(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% Extensions
{Extensions,Bytes2} = case Ext of
0 -> {<<>>,Bytes1};
1 ->
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes3= skipextensions(Bytes2, 1, Extensions),
Res1 = {'LaneDataAttribute-addGrpB'},
{Res1,Bytes3}.

'enc_MovementEvent-addGrpB'(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute startTime(1) with type INTEGER
Enc7@element = element(2, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
0 =< Enc7@element, Enc7@element < 9002 ->
<<Enc7@element:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end,
begin
%% attribute minEndTime(2) with type INTEGER
Enc10@element = element(3, Val),
if 0 =< Enc10@element, Enc10@element < 2403 ->
<<Enc10@element:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc10@element}}})
end
end,
begin
%% attribute maxEndTime(3) with type INTEGER
Enc12@element = element(4, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
0 =< Enc12@element, Enc12@element < 2403 ->
<<Enc12@element:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end,
begin
%% attribute likelyTime(4) with type INTEGER
Enc15@element = element(5, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
0 =< Enc15@element, Enc15@element < 9002 ->
<<Enc15@element:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc15@element}}})
end
end,
begin
%% attribute confidence(5) with type INTEGER
Enc18@element = element(6, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
Enc18@element bsr 4 =:= 0 ->
<<Enc18@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc18@element}}})
end
end|begin
%% attribute nextTime(6) with type INTEGER
Enc21@element = element(7, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
0 =< Enc21@element, Enc21@element < 9002 ->
<<Enc21@element:14>>;
true ->
exit({error,{asn1,{illegal_integer,Enc21@element}}})
end
end].


'dec_MovementEvent-addGrpB'(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute startTime(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V3@V0:14,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute minEndTime(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:12,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute maxEndTime(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:12,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute likelyTime(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:14,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute confidence(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V7@V0:4,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute nextTime(6) with type INTEGER
{Term6,Bytes8} = case Opt band 1 of
1 ->
begin
<<V8@V0:14,V8@Buf1/bitstring>> = Bytes7,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V9@V0,V9@Buf1} = case Bytes8 of
<<0:1,V9@V3:6,V9@Buf4/bitstring>> ->
V9@Add5 = V9@V3 + 1,
{V9@Add5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:7,V9@Buf7/bitstring>> when V9@V6 =/= 0 ->
{V9@V6,V9@Buf7};
<<1:1,0:1,V9@V7:14,V9@Buf8/bitstring>> when V9@V7 =/= 0 ->
{V9@V7,V9@Buf8};
<<1:1,1:1,V9@V7:6,V9@Buf8/bitstring>> when V9@V7 =/= 0 ->
V9@Mul9 = V9@V7 * 16384,
{V9@Mul9,V9@Buf8}
end,
{V9@V3,V9@Buf4}
end,
<<V9@V10:V9@V0/bitstring-unit:1,V9@Buf11/bitstring>> = V9@Buf1,
{V9@V10,V9@Buf11}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = {'MovementEvent-addGrpB',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes10}.

'enc_NodeOffsetPointXY-addGrpB'(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= posA ->
[<<0:1,0:1>>|'enc_Node-LLdms-48b'(ChoiceVal)];
ChoiceTag =:= posB ->
[<<0:1,1:1>>|'enc_Node-LLdms-80b'(ChoiceVal)]
end.


'dec_NodeOffsetPointXY-addGrpB'(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'dec_Node-LLdms-48b'(Bytes2)
end,
{{posA,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'dec_Node-LLdms-80b'(Bytes2)
end,
{{posB,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<0:1,V1@V6:7,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7};
<<1:1,0:1,V1@V7:14,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
{V1@V7,V1@Buf8};
<<1:1,1:1,V1@V7:6,V1@Buf8/bitstring>> when V1@V7 =/= 0 ->
V1@Mul9 = V1@V7 * 16384,
{V1@Mul9,V1@Buf8}
end,
<<V1@V10:V1@V3/unit:8,V1@Buf11/bitstring>> = V1@Buf4,
{V1@V10,V1@Buf11}
end,
{V1@V0,V1@Buf1}
end,
begin
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
'enc_Position3D-addGrpB'(Val) ->
[<<0:1>>,
begin
%% attribute latitude(1) with type LatitudeDMS2
Enc2@element = element(2, Val),
enc_LatitudeDMS2(Enc2@element)
end,
begin
%% attribute longitude(2) with type LongitudeDMS2
Enc3@element = element(3, Val),
enc_LongitudeDMS2(Enc3@element)
end|begin
%% attribute elevation(3) with type INTEGER
Enc4@element = element(4, Val),
Enc4@element@sub = Enc4@element - -32768,
if Enc4@element@sub bsr 16 =:= 0 ->
<<Enc4@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


'dec_Position3D-addGrpB'(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute latitude(1) with type LatitudeDMS2
{Term1,Bytes2} = dec_LatitudeDMS2(Bytes1),

%% attribute longitude(2) with type LongitudeDMS2
{Term2,Bytes3} = dec_LongitudeDMS2(Bytes2),

%% attribute elevation(3) with type INTEGER
{Term3,Bytes4} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes3,
V2@Add2 = V2@V0 + -32768,
{V2@Add2,V2@Buf1}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'Position3D-addGrpB',Term1,Term2,Term3},
{Res1,Bytes6}.

enc_TimeMark(Val) ->
[begin
%% attribute year(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - 1,
if 0 =< Enc1@element@sub, Enc1@element@sub < 65535 ->
<<Enc1@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute month(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 255 ->
Enc3@element@sub;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute day(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 8 =:= 0 ->
Enc5@element;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end,
begin
%% attribute summerTime(4) with type ENUMERATED
Enc7@element = element(5, Val),
%% attribute holiday(5) with type ENUMERATED
Enc9@element = element(6, Val),
if Enc7@element =:= notInSummerTime ->
if Enc9@element =:= weekday ->
<<0:1,0:1>>;
Enc9@element =:= holiday ->
<<0:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc9@element}}})
end;
Enc7@element =:= inSummerTime ->
if Enc9@element =:= weekday ->
<<1:1,0:1>>;
Enc9@element =:= holiday ->
<<1:1,1:1>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc9@element}}})
end;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end
end,
begin
%% attribute dayofWeek(6) with type ENUMERATED
Enc11@element = element(7, Val),
if Enc11@element =:= unknown ->
<<0:3>>;
Enc11@element =:= monday ->
<<1:3>>;
Enc11@element =:= tuesday ->
<<2:3>>;
Enc11@element =:= wednesday ->
<<3:3>>;
Enc11@element =:= thursday ->
<<4:3>>;
Enc11@element =:= friday ->
<<5:3>>;
Enc11@element =:= saturday ->
<<6:3>>;
Enc11@element =:= sunday ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc11@element}}})
end
end,
begin
%% attribute hour(7) with type INTEGER
Enc13@element = element(8, Val),
if Enc13@element bsr 8 =:= 0 ->
Enc13@element;
true ->
exit({error,{asn1,{illegal_integer,Enc13@element}}})
end
end,
begin
%% attribute minute(8) with type INTEGER
Enc15@element = element(9, Val),
if Enc15@element bsr 8 =:= 0 ->
Enc15@element;
true ->
exit({error,{asn1,{illegal_integer,Enc15@element}}})
end
end,
begin
%% attribute second(9) with type INTEGER
Enc17@element = element(10, Val),
if 0 =< Enc17@element, Enc17@element < 61 ->
<<Enc17@element:6>>;
true ->
exit({error,{asn1,{illegal_integer,Enc17@element}}})
end
end|begin
%% attribute tenthSecond(10) with type INTEGER
Enc19@element = element(11, Val),
if 0 =< Enc19@element, Enc19@element < 10 ->
<<Enc19@element:4>>;
true ->
exit({error,{asn1,{illegal_integer,Enc19@element}}})
end
end].


dec_TimeMark(Bytes) ->

%% attribute year(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:16,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
{V1@Add2,V1@Buf1}
end,

%% attribute month(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,

%% attribute day(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute summerTime(4) with type ENUMERATED
{Term4,Bytes4} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> notInSummerTime;
1 -> inSummerTime
end,
{V4@Int2,V4@Buf1}
end,

%% attribute holiday(5) with type ENUMERATED
{Term5,Bytes5} = begin
<<V5@V0:1,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> weekday;
1 -> holiday
end,
{V5@Int2,V5@Buf1}
end,

%% attribute dayofWeek(6) with type ENUMERATED
{Term6,Bytes6} = begin
<<V6@V0:3,V6@Buf1/bitstring>> = Bytes5,
V6@Int2 = case V6@V0 of
0 -> unknown;
1 -> monday;
2 -> tuesday;
3 -> wednesday;
4 -> thursday;
5 -> friday;
6 -> saturday;
7 -> sunday
end,
{V6@Int2,V6@Buf1}
end,

%% attribute hour(7) with type INTEGER
{Term7,Bytes7} = begin
<<V7@V0:8,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end,

%% attribute minute(8) with type INTEGER
{Term8,Bytes8} = begin
<<V8@V0:8,V8@Buf1/bitstring>> = Bytes7,
{V8@V0,V8@Buf1}
end,

%% attribute second(9) with type INTEGER
{Term9,Bytes9} = begin
<<V9@V0:6,V9@Buf1/bitstring>> = Bytes8,
{V9@V0,V9@Buf1}
end,

%% attribute tenthSecond(10) with type INTEGER
{Term10,Bytes10} = begin
<<V10@V0:4,V10@Buf1/bitstring>> = Bytes9,
{V10@V0,V10@Buf1}
end,
Res1 = {'TimeMark',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10},
{Res1,Bytes10}.

typeinfo('Angle') ->
  {'INTEGER',{0,239}};
typeinfo('Day') ->
  {'INTEGER',{0,255}};
typeinfo('DayOfWeek') ->
  {'ENUMERATED',#{unknown => 0,monday => 1,tuesday => 2,wednesday => 3,thursday => 4,friday => 5,saturday => 6,sunday => 7}};
typeinfo('DegreesLat') ->
  {'INTEGER',{-90,90}};
typeinfo('DegreesLong') ->
  {'INTEGER',{-180,180}};
typeinfo('Elevation') ->
  {'INTEGER',{-32768,32767}};
typeinfo('Holiday') ->
  {'ENUMERATED',#{weekday => 0,holiday => 1}};
typeinfo('Hour') ->
  {'INTEGER',{0,255}};
typeinfo('LatitudeDMS') ->
  {'INTEGER',{-32400000,32400000}};
typeinfo('LongitudeDMS') ->
  {'INTEGER',{-64800000,64800000}};
typeinfo('MaxTimetoChange') ->
  {'INTEGER',{0,2402}};
typeinfo('MinTimetoChange') ->
  {'INTEGER',{0,2402}};
typeinfo('Minute') ->
  {'INTEGER',{0,255}};
typeinfo('MinutesAngle') ->
  {'INTEGER',{0,59}};
typeinfo('Month') ->
  {'INTEGER',{1,255}};
typeinfo('MsgCount') ->
  {'INTEGER',{0,255}};
typeinfo('Second') ->
  {'INTEGER',{0,60}};
typeinfo('SecondsAngle') ->
  {'INTEGER',{0,5999}};
typeinfo('SummerTime') ->
  {'ENUMERATED',#{notInSummerTime => 0,inSummerTime => 1}};
typeinfo('TenthSecond') ->
  {'INTEGER',{0,9}};
typeinfo('TimeRemaining') ->
  {'INTEGER',{0,9001}};
typeinfo('Year') ->
  {'INTEGER',{1,65535}};
typeinfo('LatitudeDMS2') ->
  {sequence,'LatitudeDMS2',3,[{<<100>>,{'INTEGER',{-90,90}},mandatory},{<<109>>,{'INTEGER',{0,59}},mandatory},{<<115>>,{'INTEGER',{0,5999}},mandatory}]};
typeinfo('LongitudeDMS2') ->
  {sequence,'LongitudeDMS2',3,[{<<100>>,{'INTEGER',{-180,180}},mandatory},{<<109>>,{'INTEGER',{0,59}},mandatory},{<<115>>,{'INTEGER',{0,5999}},mandatory}]};
typeinfo('Node-LLdms-48b') ->
  {sequence,'Node-LLdms-48b',2,[{<<108,111,110>>,{'INTEGER',{-64800000,64800000}},mandatory},{<<108,97,116>>,{'INTEGER',{-32400000,32400000}},mandatory}]};
typeinfo('Node-LLdms-80b') ->
  {sequence,'Node-LLdms-80b',2,[{<<108,111,110>>,{typeinfo,{'AddGrpB','LongitudeDMS2'}},mandatory},{<<108,97,116>>,{typeinfo,{'AddGrpB','LatitudeDMS2'}},mandatory}]};
typeinfo('LaneDataAttribute-addGrpB') ->
  {sequence,'LaneDataAttribute-addGrpB',0,[]};
typeinfo('MovementEvent-addGrpB') ->
  {sequence,'MovementEvent-addGrpB',6,[{<<115,116,97,114,116,84,105,109,101>>,{'INTEGER',{0,9001}},'OPTIONAL'},{<<109,105,110,69,110,100,84,105,109,101>>,{'INTEGER',{0,2402}},mandatory},{<<109,97,120,69,110,100,84,105,109,101>>,{'INTEGER',{0,2402}},'OPTIONAL'},{<<108,105,107,101,108,121,84,105,109,101>>,{'INTEGER',{0,9001}},'OPTIONAL'},{<<99,111,110,102,105,100,101,110,99,101>>,{'INTEGER',{0,15}},'OPTIONAL'},{<<110,101,120,116,84,105,109,101>>,{'INTEGER',{0,9001}},'OPTIONAL'}]};
typeinfo('NodeOffsetPointXY-addGrpB') ->
  {choice,#{<<112,111,115,65>> => {typeinfo,{'AddGrpB','Node-LLdms-48b'}},<<112,111,115,66>> => {typeinfo,{'AddGrpB','Node-LLdms-80b'}}}};
typeinfo('Position3D-addGrpB') ->
  {sequence,'Position3D-addGrpB',3,[{<<108,97,116,105,116,117,100,101>>,{typeinfo,{'AddGrpB','LatitudeDMS2'}},mandatory},{<<108,111,110,103,105,116,117,100,101>>,{typeinfo,{'AddGrpB','LongitudeDMS2'}},mandatory},{<<101,108,101,118,97,116,105,111,110>>,{'INTEGER',{-32768,32767}},mandatory}]};
typeinfo('TimeMark') ->
  {sequence,'TimeMark',10,[{<<121,101,97,114>>,{'INTEGER',{1,65535}},mandatory},{<<109,111,110,116,104>>,{'INTEGER',{1,255}},mandatory},{<<100,97,121>>,{'INTEGER',{0,255}},mandatory},{<<115,117,109,109,101,114,84,105,109,101>>,{'ENUMERATED',#{notInSummerTime => 0,inSummerTime => 1}},mandatory},{<<104,111,108,105,100,97,121>>,{'ENUMERATED',#{weekday => 0,holiday => 1}},mandatory},{<<100,97,121,111,102,87,101,101,107>>,{'ENUMERATED',#{unknown => 0,monday => 1,tuesday => 2,wednesday => 3,thursday => 4,friday => 5,saturday => 6,sunday => 7}},mandatory},{<<104,111,117,114>>,{'INTEGER',{0,255}},mandatory},{<<109,105,110,117,116,101>>,{'INTEGER',{0,255}},mandatory},{<<115,101,99,111,110,100>>,{'INTEGER',{0,60}},mandatory},{<<116,101,110,116,104,83,101,99,111,110,100>>,{'INTEGER',{0,9}},mandatory}]};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
