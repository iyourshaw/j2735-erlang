%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in BasicSafetyMessage.

-module('BasicSafetyMessage').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("BasicSafetyMessage.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'BasicSafetyMessage'},
            {options,[{i,"./ebin"},uper,jer,verbose,{i,"./asn"},{outdir,"./ebin"},{i,"."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([typeinfo/1]).
-export([
enc_BasicSafetyMessage/1,
'enc_PartII-Id'/1,
enc_DisabledVehicle/1,
enc_EventDescription/1,
enc_ObstacleDetection/1,
enc_PivotPointDescription/1,
enc_RTCMPackage/1,
enc_SpecialVehicleExtensions/1,
enc_SpeedProfileMeasurementList/1,
enc_SpeedProfile/1,
enc_SupplementalVehicleExtensions/1,
enc_TrailerData/1,
enc_TrailerHistoryPointList/1,
enc_TrailerHistoryPoint/1,
enc_TrailerUnitDescriptionList/1,
enc_TrailerUnitDescription/1,
enc_VehicleData/1,
enc_WeatherProbe/1,
enc_WeatherReport/1,
enc_IsDolly/1,
enc_ObstacleDirection/1,
enc_PivotingAllowed/1,
enc_SpeedProfileMeasurement/1,
enc_TrailerMass/1,
'enc_VertOffset-B07'/1
]).

-export([
dec_BasicSafetyMessage/1,
'dec_PartII-Id'/1,
dec_DisabledVehicle/1,
dec_EventDescription/1,
dec_ObstacleDetection/1,
dec_PivotPointDescription/1,
dec_RTCMPackage/1,
dec_SpecialVehicleExtensions/1,
dec_SpeedProfileMeasurementList/1,
dec_SpeedProfile/1,
dec_SupplementalVehicleExtensions/1,
dec_TrailerData/1,
dec_TrailerHistoryPointList/1,
dec_TrailerHistoryPoint/1,
dec_TrailerUnitDescriptionList/1,
dec_TrailerUnitDescription/1,
dec_VehicleData/1,
dec_WeatherProbe/1,
dec_WeatherReport/1,
dec_IsDolly/1,
dec_ObstacleDirection/1,
dec_PivotingAllowed/1,
dec_SpeedProfileMeasurement/1,
dec_TrailerMass/1,
'dec_VertOffset-B07'/1
]).

-export([
vehicleSafetyExt/0,
specialVehicleExt/0,
supplementalVehicleExt/0
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


jer_encode(Type, Data) ->
try encode_jer('BasicSafetyMessage', Type, Data) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('BasicSafetyMessage', Type, json:decode(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('BasicSafetyMessage', Data) -> enc_BasicSafetyMessage(Data);
encode_disp('PartII-Id', Data) -> 'enc_PartII-Id'(Data);
encode_disp('DisabledVehicle', Data) -> enc_DisabledVehicle(Data);
encode_disp('EventDescription', Data) -> enc_EventDescription(Data);
encode_disp('ObstacleDetection', Data) -> enc_ObstacleDetection(Data);
encode_disp('PivotPointDescription', Data) -> enc_PivotPointDescription(Data);
encode_disp('RTCMPackage', Data) -> enc_RTCMPackage(Data);
encode_disp('SpecialVehicleExtensions', Data) -> enc_SpecialVehicleExtensions(Data);
encode_disp('SpeedProfileMeasurementList', Data) -> enc_SpeedProfileMeasurementList(Data);
encode_disp('SpeedProfile', Data) -> enc_SpeedProfile(Data);
encode_disp('SupplementalVehicleExtensions', Data) -> enc_SupplementalVehicleExtensions(Data);
encode_disp('TrailerData', Data) -> enc_TrailerData(Data);
encode_disp('TrailerHistoryPointList', Data) -> enc_TrailerHistoryPointList(Data);
encode_disp('TrailerHistoryPoint', Data) -> enc_TrailerHistoryPoint(Data);
encode_disp('TrailerUnitDescriptionList', Data) -> enc_TrailerUnitDescriptionList(Data);
encode_disp('TrailerUnitDescription', Data) -> enc_TrailerUnitDescription(Data);
encode_disp('VehicleData', Data) -> enc_VehicleData(Data);
encode_disp('WeatherProbe', Data) -> enc_WeatherProbe(Data);
encode_disp('WeatherReport', Data) -> enc_WeatherReport(Data);
encode_disp('IsDolly', Data) -> enc_IsDolly(Data);
encode_disp('ObstacleDirection', Data) -> enc_ObstacleDirection(Data);
encode_disp('PivotingAllowed', Data) -> enc_PivotingAllowed(Data);
encode_disp('SpeedProfileMeasurement', Data) -> enc_SpeedProfileMeasurement(Data);
encode_disp('TrailerMass', Data) -> enc_TrailerMass(Data);
encode_disp('VertOffset-B07', Data) -> 'enc_VertOffset-B07'(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('BasicSafetyMessage', Data) -> dec_BasicSafetyMessage(Data);
decode_disp('PartII-Id', Data) -> 'dec_PartII-Id'(Data);
decode_disp('DisabledVehicle', Data) -> dec_DisabledVehicle(Data);
decode_disp('EventDescription', Data) -> dec_EventDescription(Data);
decode_disp('ObstacleDetection', Data) -> dec_ObstacleDetection(Data);
decode_disp('PivotPointDescription', Data) -> dec_PivotPointDescription(Data);
decode_disp('RTCMPackage', Data) -> dec_RTCMPackage(Data);
decode_disp('SpecialVehicleExtensions', Data) -> dec_SpecialVehicleExtensions(Data);
decode_disp('SpeedProfileMeasurementList', Data) -> dec_SpeedProfileMeasurementList(Data);
decode_disp('SpeedProfile', Data) -> dec_SpeedProfile(Data);
decode_disp('SupplementalVehicleExtensions', Data) -> dec_SupplementalVehicleExtensions(Data);
decode_disp('TrailerData', Data) -> dec_TrailerData(Data);
decode_disp('TrailerHistoryPointList', Data) -> dec_TrailerHistoryPointList(Data);
decode_disp('TrailerHistoryPoint', Data) -> dec_TrailerHistoryPoint(Data);
decode_disp('TrailerUnitDescriptionList', Data) -> dec_TrailerUnitDescriptionList(Data);
decode_disp('TrailerUnitDescription', Data) -> dec_TrailerUnitDescription(Data);
decode_disp('VehicleData', Data) -> dec_VehicleData(Data);
decode_disp('WeatherProbe', Data) -> dec_WeatherProbe(Data);
decode_disp('WeatherReport', Data) -> dec_WeatherReport(Data);
decode_disp('IsDolly', Data) -> dec_IsDolly(Data);
decode_disp('ObstacleDirection', Data) -> dec_ObstacleDirection(Data);
decode_disp('PivotingAllowed', Data) -> dec_PivotingAllowed(Data);
decode_disp('SpeedProfileMeasurement', Data) -> dec_SpeedProfileMeasurement(Data);
decode_disp('TrailerMass', Data) -> dec_TrailerMass(Data);
decode_disp('VertOffset-B07', Data) -> 'dec_VertOffset-B07'(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_BasicSafetyMessage(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute coreData(1) with type BSMcoreData
Enc4@element = element(2, Val),
'Common':enc_BSMcoreData(Enc4@element)
end,
begin
%% attribute partII(2) with type SEQUENCE OF
Enc5@element = element(3, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
enc_BasicSafetyMessage_partII(Enc5@element)
end
end|begin
%% attribute regional(3) with type SEQUENCE OF
Enc7@element = element(4, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
enc_BasicSafetyMessage_regional(Enc7@element)
end
end].
enc_BasicSafetyMessage_partII(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 3 =:= 0 ->
[<<Enc1@len@sub:3>>|[enc_BasicSafetyMessage_partII_PartIIcontent(Comp) || Comp <- Val]]
end.

enc_BasicSafetyMessage_partII_PartIIcontent(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute partII-Id(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 6 =:= 0 ->
<<Enc2@element:6>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute partII-Value(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type1(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].
enc_BasicSafetyMessage_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_BasicSafetyMessage_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_BasicSafetyMessage_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type2(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_BasicSafetyMessage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute coreData(1) with type BSMcoreData
{Term1,Bytes3} = 'Common':dec_BSMcoreData(Bytes2),

%% attribute partII(2) with type SEQUENCE OF
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
dec_BasicSafetyMessage_partII(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute regional(3) with type SEQUENCE OF
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_BasicSafetyMessage_regional(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V3@V0,V3@Buf1} = case Bytes5 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'BasicSafetyMessage',Term1,Term2,Term3},
{Res1,Bytes7}.


dec_BasicSafetyMessage_partII(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components3(V1@Add2, V1@Buf1, []).


dec_BasicSafetyMessage_partII_PartIIcontent(Bytes) ->

%% attribute partII-Id(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute partII-Value(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type4(Tmpterm1, Term1),
Res1 = {'PartIIcontent',Term1,Term2},
{Res1,Bytes2}.


dec_BasicSafetyMessage_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components5(V1@Add2, V1@Buf1, []).


dec_BasicSafetyMessage_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type6(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

'enc_PartII-Id'(Val) ->
if Val bsr 6 =:= 0 ->
<<Val:6>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_PartII-Id'(Bytes) ->
begin
<<V1@V0:6,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DisabledVehicle(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute statusDetails(1) with type INTEGER
Enc3@element = element(2, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute locationDetails(2) with type ENUMERATED
Enc5@element = element(3, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
Enc5@element =:= 'on-bridges' ->
<<0:1,0:7>>;
Enc5@element =:= 'in-tunnels' ->
<<0:1,1:7>>;
Enc5@element =:= 'entering-or-leaving-tunnels' ->
<<0:1,2:7>>;
Enc5@element =:= 'on-ramps' ->
<<0:1,3:7>>;
Enc5@element =:= 'in-road-construction-area' ->
<<0:1,4:7>>;
Enc5@element =:= 'around-a-curve' ->
<<0:1,5:7>>;
Enc5@element =:= 'on-minor-roads' ->
<<0:1,6:7>>;
Enc5@element =:= 'in-the-opposing-lanes' ->
<<0:1,7:7>>;
Enc5@element =:= 'adjacent-to-roadway' ->
<<0:1,8:7>>;
Enc5@element =:= 'on-bend' ->
<<0:1,9:7>>;
Enc5@element =:= 'entire-intersection' ->
<<0:1,10:7>>;
Enc5@element =:= 'in-the-median' ->
<<0:1,11:7>>;
Enc5@element =:= 'moved-to-side-of-road' ->
<<0:1,12:7>>;
Enc5@element =:= 'moved-to-shoulder' ->
<<0:1,13:7>>;
Enc5@element =:= 'on-the-roadway' ->
<<0:1,14:7>>;
Enc5@element =:= 'in-shaded-areas' ->
<<0:1,15:7>>;
Enc5@element =:= 'in-low-lying-areas' ->
<<0:1,16:7>>;
Enc5@element =:= 'in-the-downtown-area' ->
<<0:1,17:7>>;
Enc5@element =:= 'in-the-inner-city-area' ->
<<0:1,18:7>>;
Enc5@element =:= 'in-parts' ->
<<0:1,19:7>>;
Enc5@element =:= 'in-some-places' ->
<<0:1,20:7>>;
Enc5@element =:= 'in-the-ditch' ->
<<0:1,21:7>>;
Enc5@element =:= 'in-the-valley' ->
<<0:1,22:7>>;
Enc5@element =:= 'on-hill-top' ->
<<0:1,23:7>>;
Enc5@element =:= 'near-the-foothills' ->
<<0:1,24:7>>;
Enc5@element =:= 'at-high-altitudes' ->
<<0:1,25:7>>;
Enc5@element =:= 'near-the-lake' ->
<<0:1,26:7>>;
Enc5@element =:= 'near-the-shore' ->
<<0:1,27:7>>;
Enc5@element =:= 'over-the-crest-of-a-hill' ->
<<0:1,28:7>>;
Enc5@element =:= 'other-than-on-the-roadway' ->
<<0:1,29:7>>;
Enc5@element =:= 'near-the-beach' ->
<<0:1,30:7>>;
Enc5@element =:= 'near-beach-access-point' ->
<<0:1,31:7>>;
Enc5@element =:= 'lower-level' ->
<<0:1,32:7>>;
Enc5@element =:= 'upper-level' ->
<<0:1,33:7>>;
Enc5@element =:= airport ->
<<0:1,34:7>>;
Enc5@element =:= concourse ->
<<0:1,35:7>>;
Enc5@element =:= gate ->
<<0:1,36:7>>;
Enc5@element =:= 'baggage-claim' ->
<<0:1,37:7>>;
Enc5@element =:= 'customs-point' ->
<<0:1,38:7>>;
Enc5@element =:= station ->
<<0:1,39:7>>;
Enc5@element =:= platform ->
<<0:1,40:7>>;
Enc5@element =:= dock ->
<<0:1,41:7>>;
Enc5@element =:= depot ->
<<0:1,42:7>>;
Enc5@element =:= 'ev-charging-point' ->
<<0:1,43:7>>;
Enc5@element =:= 'information-welcome-point' ->
<<0:1,44:7>>;
Enc5@element =:= 'at-rest-area' ->
<<0:1,45:7>>;
Enc5@element =:= 'at-service-area' ->
<<0:1,46:7>>;
Enc5@element =:= 'at-weigh-station' ->
<<0:1,47:7>>;
Enc5@element =:= 'picnic-areas' ->
<<0:1,48:7>>;
Enc5@element =:= 'rest-area' ->
<<0:1,49:7>>;
Enc5@element =:= 'service-stations' ->
<<0:1,50:7>>;
Enc5@element =:= toilets ->
<<0:1,51:7>>;
Enc5@element =:= 'on-the-right' ->
<<0:1,52:7>>;
Enc5@element =:= 'on-the-left' ->
<<0:1,53:7>>;
Enc5@element =:= 'in-the-center' ->
<<0:1,54:7>>;
Enc5@element =:= 'in-the-opposite-direction' ->
<<0:1,55:7>>;
Enc5@element =:= 'cross-traffic' ->
<<0:1,56:7>>;
Enc5@element =:= 'northbound-traffic' ->
<<0:1,57:7>>;
Enc5@element =:= 'eastbound-traffic' ->
<<0:1,58:7>>;
Enc5@element =:= 'southbound-traffic' ->
<<0:1,59:7>>;
Enc5@element =:= 'westbound-traffic' ->
<<0:1,60:7>>;
Enc5@element =:= north ->
<<0:1,61:7>>;
Enc5@element =:= south ->
<<0:1,62:7>>;
Enc5@element =:= east ->
<<0:1,63:7>>;
Enc5@element =:= west ->
<<0:1,64:7>>;
Enc5@element =:= northeast ->
<<0:1,65:7>>;
Enc5@element =:= northwest ->
<<0:1,66:7>>;
Enc5@element =:= southeast ->
<<0:1,67:7>>;
Enc5@element =:= southwest ->
<<0:1,68:7>>;
Enc5@element =:= 'mountain-pass' ->
<<0:1,69:7>>;
Enc5@element =:= 'reservation-center' ->
<<0:1,70:7>>;
Enc5@element =:= 'nearby-basin' ->
<<0:1,71:7>>;
Enc5@element =:= 'on-tracks' ->
<<0:1,72:7>>;
Enc5@element =:= dip ->
<<0:1,73:7>>;
Enc5@element =:= 'traffic-circle' ->
<<0:1,74:7>>;
Enc5@element =:= 'park-and-ride-lot' ->
<<0:1,75:7>>;
Enc5@element =:= to ->
<<0:1,76:7>>;
Enc5@element =:= by ->
<<0:1,77:7>>;
Enc5@element =:= through ->
<<0:1,78:7>>;
Enc5@element =:= 'area-of' ->
<<0:1,79:7>>;
Enc5@element =:= under ->
<<0:1,80:7>>;
Enc5@element =:= over ->
<<0:1,81:7>>;
Enc5@element =:= from ->
<<0:1,82:7>>;
Enc5@element =:= approaching ->
<<0:1,83:7>>;
Enc5@element =:= 'entering-at' ->
<<0:1,84:7>>;
Enc5@element =:= 'exiting-at' ->
<<0:1,85:7>>;
Enc5@element =:= 'across-tracks' ->
<<0:1,86:7>>;
Enc5@element =:= 'in-street' ->
<<0:1,87:7>>;
Enc5@element =:= 'on-curve' ->
<<0:1,88:7>>;
Enc5@element =:= shoulder ->
<<0:1,89:7>>;
Enc5@element =:= crossover ->
<<0:1,90:7>>;
Enc5@element =:= 'cross-road' ->
<<0:1,91:7>>;
Enc5@element =:= 'side-road' ->
<<0:1,92:7>>;
Enc5@element =:= 'bus-stop' ->
<<0:1,93:7>>;
Enc5@element =:= intersection ->
<<0:1,94:7>>;
Enc5@element =:= 'roadside-park' ->
<<0:1,95:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end].


dec_DisabledVehicle(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute statusDetails(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute locationDetails(2) with type ENUMERATED
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:7,V4@Buf4/bitstring>> ->
V4@Int5 = case V4@V3 of
0 -> 'on-bridges';
1 -> 'in-tunnels';
2 -> 'entering-or-leaving-tunnels';
3 -> 'on-ramps';
4 -> 'in-road-construction-area';
5 -> 'around-a-curve';
6 -> 'on-minor-roads';
7 -> 'in-the-opposing-lanes';
8 -> 'adjacent-to-roadway';
9 -> 'on-bend';
10 -> 'entire-intersection';
11 -> 'in-the-median';
12 -> 'moved-to-side-of-road';
13 -> 'moved-to-shoulder';
14 -> 'on-the-roadway';
15 -> 'in-shaded-areas';
16 -> 'in-low-lying-areas';
17 -> 'in-the-downtown-area';
18 -> 'in-the-inner-city-area';
19 -> 'in-parts';
20 -> 'in-some-places';
21 -> 'in-the-ditch';
22 -> 'in-the-valley';
23 -> 'on-hill-top';
24 -> 'near-the-foothills';
25 -> 'at-high-altitudes';
26 -> 'near-the-lake';
27 -> 'near-the-shore';
28 -> 'over-the-crest-of-a-hill';
29 -> 'other-than-on-the-roadway';
30 -> 'near-the-beach';
31 -> 'near-beach-access-point';
32 -> 'lower-level';
33 -> 'upper-level';
34 -> airport;
35 -> concourse;
36 -> gate;
37 -> 'baggage-claim';
38 -> 'customs-point';
39 -> station;
40 -> platform;
41 -> dock;
42 -> depot;
43 -> 'ev-charging-point';
44 -> 'information-welcome-point';
45 -> 'at-rest-area';
46 -> 'at-service-area';
47 -> 'at-weigh-station';
48 -> 'picnic-areas';
49 -> 'rest-area';
50 -> 'service-stations';
51 -> toilets;
52 -> 'on-the-right';
53 -> 'on-the-left';
54 -> 'in-the-center';
55 -> 'in-the-opposite-direction';
56 -> 'cross-traffic';
57 -> 'northbound-traffic';
58 -> 'eastbound-traffic';
59 -> 'southbound-traffic';
60 -> 'westbound-traffic';
61 -> north;
62 -> south;
63 -> east;
64 -> west;
65 -> northeast;
66 -> northwest;
67 -> southeast;
68 -> southwest;
69 -> 'mountain-pass';
70 -> 'reservation-center';
71 -> 'nearby-basin';
72 -> 'on-tracks';
73 -> dip;
74 -> 'traffic-circle';
75 -> 'park-and-ride-lot';
76 -> to;
77 -> by;
78 -> through;
79 -> 'area-of';
80 -> under;
81 -> over;
82 -> from;
83 -> approaching;
84 -> 'entering-at';
85 -> 'exiting-at';
86 -> 'across-tracks';
87 -> 'in-street';
88 -> 'on-curve';
89 -> shoulder;
90 -> crossover;
91 -> 'cross-road';
92 -> 'side-road';
93 -> 'bus-stop';
94 -> intersection;
95 -> 'roadside-park';
_ -> exit({error,{asn1,{decode_enumerated,V4@V3}}})
end,
{V4@Int5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V6,V4@Buf7};
<<1:1,V4@Buf5/bitstring>> ->
{V4@V6,V4@Buf7} = case V4@Buf5 of
<<0:1,V4@V9:7,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10};
<<1:1,0:1,V4@V10:14,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
{V4@V10,V4@Buf11};
<<1:1,1:1,V4@V10:6,V4@Buf11/bitstring>> when V4@V10 =/= 0 ->
V4@Mul12 = V4@V10 * 16384,
{V4@Mul12,V4@Buf11}
end,
<<V4@V13:V4@V6/unit:8,V4@Buf14/bitstring>> = V4@Buf7,
{V4@V13,V4@Buf14}
end,
V4@Int15 = case V4@V3 of
_ -> {asn1_enum,V4@V3}
end,
{V4@Int15,V4@Buf4}
end,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'DisabledVehicle',Term1,Term2},
{Res1,Bytes6}.

enc_EventDescription(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute typeEvent(1) with type INTEGER
Enc7@element = element(2, Val),
if Enc7@element bsr 16 =:= 0 ->
<<Enc7@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end,
begin
%% attribute description(2) with type SEQUENCE OF
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
enc_EventDescription_description(Enc9@element)
end
end,
begin
%% attribute priority(3) with type OCTET STRING
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc12@len = byte_size(Enc11@element),
if Enc12@len =:= 1 ->
Enc11@element
end
end
end
end,
begin
%% attribute heading(4) with type BIT STRING
Enc14@element = element(5, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc15@bs = try bit_string_name2pos_7(Enc14@element) of
Enc15@positions ->
bitstring_from_positions(Enc15@positions, 16)
catch throw:invalid ->
adjust_trailing_zeroes(Enc14@element, 16)
end,
Enc15@bits = bit_size(Enc15@bs),
if Enc15@bits =:= 16 ->
Enc15@bs
end
end
end
end,
begin
%% attribute extent(5) with type ENUMERATED
Enc17@element = element(6, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
Enc17@element =:= useInstantlyOnly ->
<<0:4>>;
Enc17@element =:= useFor3meters ->
<<1:4>>;
Enc17@element =:= useFor10meters ->
<<2:4>>;
Enc17@element =:= useFor50meters ->
<<3:4>>;
Enc17@element =:= useFor100meters ->
<<4:4>>;
Enc17@element =:= useFor500meters ->
<<5:4>>;
Enc17@element =:= useFor1000meters ->
<<6:4>>;
Enc17@element =:= useFor5000meters ->
<<7:4>>;
Enc17@element =:= useFor10000meters ->
<<8:4>>;
Enc17@element =:= useFor50000meters ->
<<9:4>>;
Enc17@element =:= useFor100000meters ->
<<10:4>>;
Enc17@element =:= useFor500000meters ->
<<11:4>>;
Enc17@element =:= useFor1000000meters ->
<<12:4>>;
Enc17@element =:= useFor5000000meters ->
<<13:4>>;
Enc17@element =:= useFor10000000meters ->
<<14:4>>;
Enc17@element =:= forever ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc17@element}}})
end
end|begin
%% attribute regional(6) with type SEQUENCE OF
Enc20@element = element(7, Val),
if Enc20@element =:= asn1_NOVALUE ->
[];
true ->
enc_EventDescription_regional(Enc20@element)
end
end].
enc_EventDescription_description(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if Enc2@len@sub bsr 3 =:= 0 ->
[<<Enc2@len@sub:3>>|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.

enc_EventDescription_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_EventDescription_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_EventDescription_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type2(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_EventDescription(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute typeEvent(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:16,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute description(2) with type SEQUENCE OF
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
dec_EventDescription_description(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute priority(3) with type OCTET STRING
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V4@V0:1/binary-unit:8,V4@Buf1/bitstring>> = Bytes4,
V4@Conv2 = binary:copy(V4@V0),
{V4@Conv2,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute heading(4) with type BIT STRING
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:16/binary-unit:1,V5@Buf1/bitstring>> = Bytes5,
{V5@V2,V5@Buf3}  = {decode_named_bit_string(V5@V0, [{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]),V5@Buf1},
{V5@V2,V5@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute extent(5) with type ENUMERATED
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V6@V0:4,V6@Buf1/bitstring>> = Bytes6,
V6@Int2 = case V6@V0 of
0 -> useInstantlyOnly;
1 -> useFor3meters;
2 -> useFor10meters;
3 -> useFor50meters;
4 -> useFor100meters;
5 -> useFor500meters;
6 -> useFor1000meters;
7 -> useFor5000meters;
8 -> useFor10000meters;
9 -> useFor50000meters;
10 -> useFor100000meters;
11 -> useFor500000meters;
12 -> useFor1000000meters;
13 -> useFor5000000meters;
14 -> useFor10000000meters;
15 -> forever
end,
{V6@Int2,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute regional(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_EventDescription_regional(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V7@V0,V7@Buf1} = case Bytes8 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = {'EventDescription',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes10}.


dec_EventDescription_description(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components8(V1@Add2, V1@Buf1, []).


dec_EventDescription_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components9(V1@Add2, V1@Buf1, []).


dec_EventDescription_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type6(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_ObstacleDetection(Val) ->
[begin
Enc1@element = element(4, Val),
Enc2@element = element(5, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(7, Val),
if Enc3@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute obDist(1) with type INTEGER
Enc5@element = element(2, Val),
if Enc5@element bsr 15 =:= 0 ->
<<Enc5@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end,
begin
%% attribute obDirect(2) with type INTEGER
Enc7@element = element(3, Val),
if 0 =< Enc7@element, Enc7@element < 28801 ->
<<Enc7@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc7@element}}})
end
end,
begin
%% attribute description(3) with type INTEGER
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
Enc9@element bsr 16 =:= 0 ->
<<Enc9@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end,
begin
%% attribute locationDetails(4) with type ENUMERATED
Enc12@element = element(5, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
Enc12@element =:= 'on-bridges' ->
<<0:1,0:7>>;
Enc12@element =:= 'in-tunnels' ->
<<0:1,1:7>>;
Enc12@element =:= 'entering-or-leaving-tunnels' ->
<<0:1,2:7>>;
Enc12@element =:= 'on-ramps' ->
<<0:1,3:7>>;
Enc12@element =:= 'in-road-construction-area' ->
<<0:1,4:7>>;
Enc12@element =:= 'around-a-curve' ->
<<0:1,5:7>>;
Enc12@element =:= 'on-minor-roads' ->
<<0:1,6:7>>;
Enc12@element =:= 'in-the-opposing-lanes' ->
<<0:1,7:7>>;
Enc12@element =:= 'adjacent-to-roadway' ->
<<0:1,8:7>>;
Enc12@element =:= 'on-bend' ->
<<0:1,9:7>>;
Enc12@element =:= 'entire-intersection' ->
<<0:1,10:7>>;
Enc12@element =:= 'in-the-median' ->
<<0:1,11:7>>;
Enc12@element =:= 'moved-to-side-of-road' ->
<<0:1,12:7>>;
Enc12@element =:= 'moved-to-shoulder' ->
<<0:1,13:7>>;
Enc12@element =:= 'on-the-roadway' ->
<<0:1,14:7>>;
Enc12@element =:= 'in-shaded-areas' ->
<<0:1,15:7>>;
Enc12@element =:= 'in-low-lying-areas' ->
<<0:1,16:7>>;
Enc12@element =:= 'in-the-downtown-area' ->
<<0:1,17:7>>;
Enc12@element =:= 'in-the-inner-city-area' ->
<<0:1,18:7>>;
Enc12@element =:= 'in-parts' ->
<<0:1,19:7>>;
Enc12@element =:= 'in-some-places' ->
<<0:1,20:7>>;
Enc12@element =:= 'in-the-ditch' ->
<<0:1,21:7>>;
Enc12@element =:= 'in-the-valley' ->
<<0:1,22:7>>;
Enc12@element =:= 'on-hill-top' ->
<<0:1,23:7>>;
Enc12@element =:= 'near-the-foothills' ->
<<0:1,24:7>>;
Enc12@element =:= 'at-high-altitudes' ->
<<0:1,25:7>>;
Enc12@element =:= 'near-the-lake' ->
<<0:1,26:7>>;
Enc12@element =:= 'near-the-shore' ->
<<0:1,27:7>>;
Enc12@element =:= 'over-the-crest-of-a-hill' ->
<<0:1,28:7>>;
Enc12@element =:= 'other-than-on-the-roadway' ->
<<0:1,29:7>>;
Enc12@element =:= 'near-the-beach' ->
<<0:1,30:7>>;
Enc12@element =:= 'near-beach-access-point' ->
<<0:1,31:7>>;
Enc12@element =:= 'lower-level' ->
<<0:1,32:7>>;
Enc12@element =:= 'upper-level' ->
<<0:1,33:7>>;
Enc12@element =:= airport ->
<<0:1,34:7>>;
Enc12@element =:= concourse ->
<<0:1,35:7>>;
Enc12@element =:= gate ->
<<0:1,36:7>>;
Enc12@element =:= 'baggage-claim' ->
<<0:1,37:7>>;
Enc12@element =:= 'customs-point' ->
<<0:1,38:7>>;
Enc12@element =:= station ->
<<0:1,39:7>>;
Enc12@element =:= platform ->
<<0:1,40:7>>;
Enc12@element =:= dock ->
<<0:1,41:7>>;
Enc12@element =:= depot ->
<<0:1,42:7>>;
Enc12@element =:= 'ev-charging-point' ->
<<0:1,43:7>>;
Enc12@element =:= 'information-welcome-point' ->
<<0:1,44:7>>;
Enc12@element =:= 'at-rest-area' ->
<<0:1,45:7>>;
Enc12@element =:= 'at-service-area' ->
<<0:1,46:7>>;
Enc12@element =:= 'at-weigh-station' ->
<<0:1,47:7>>;
Enc12@element =:= 'picnic-areas' ->
<<0:1,48:7>>;
Enc12@element =:= 'rest-area' ->
<<0:1,49:7>>;
Enc12@element =:= 'service-stations' ->
<<0:1,50:7>>;
Enc12@element =:= toilets ->
<<0:1,51:7>>;
Enc12@element =:= 'on-the-right' ->
<<0:1,52:7>>;
Enc12@element =:= 'on-the-left' ->
<<0:1,53:7>>;
Enc12@element =:= 'in-the-center' ->
<<0:1,54:7>>;
Enc12@element =:= 'in-the-opposite-direction' ->
<<0:1,55:7>>;
Enc12@element =:= 'cross-traffic' ->
<<0:1,56:7>>;
Enc12@element =:= 'northbound-traffic' ->
<<0:1,57:7>>;
Enc12@element =:= 'eastbound-traffic' ->
<<0:1,58:7>>;
Enc12@element =:= 'southbound-traffic' ->
<<0:1,59:7>>;
Enc12@element =:= 'westbound-traffic' ->
<<0:1,60:7>>;
Enc12@element =:= north ->
<<0:1,61:7>>;
Enc12@element =:= south ->
<<0:1,62:7>>;
Enc12@element =:= east ->
<<0:1,63:7>>;
Enc12@element =:= west ->
<<0:1,64:7>>;
Enc12@element =:= northeast ->
<<0:1,65:7>>;
Enc12@element =:= northwest ->
<<0:1,66:7>>;
Enc12@element =:= southeast ->
<<0:1,67:7>>;
Enc12@element =:= southwest ->
<<0:1,68:7>>;
Enc12@element =:= 'mountain-pass' ->
<<0:1,69:7>>;
Enc12@element =:= 'reservation-center' ->
<<0:1,70:7>>;
Enc12@element =:= 'nearby-basin' ->
<<0:1,71:7>>;
Enc12@element =:= 'on-tracks' ->
<<0:1,72:7>>;
Enc12@element =:= dip ->
<<0:1,73:7>>;
Enc12@element =:= 'traffic-circle' ->
<<0:1,74:7>>;
Enc12@element =:= 'park-and-ride-lot' ->
<<0:1,75:7>>;
Enc12@element =:= to ->
<<0:1,76:7>>;
Enc12@element =:= by ->
<<0:1,77:7>>;
Enc12@element =:= through ->
<<0:1,78:7>>;
Enc12@element =:= 'area-of' ->
<<0:1,79:7>>;
Enc12@element =:= under ->
<<0:1,80:7>>;
Enc12@element =:= over ->
<<0:1,81:7>>;
Enc12@element =:= from ->
<<0:1,82:7>>;
Enc12@element =:= approaching ->
<<0:1,83:7>>;
Enc12@element =:= 'entering-at' ->
<<0:1,84:7>>;
Enc12@element =:= 'exiting-at' ->
<<0:1,85:7>>;
Enc12@element =:= 'across-tracks' ->
<<0:1,86:7>>;
Enc12@element =:= 'in-street' ->
<<0:1,87:7>>;
Enc12@element =:= 'on-curve' ->
<<0:1,88:7>>;
Enc12@element =:= shoulder ->
<<0:1,89:7>>;
Enc12@element =:= crossover ->
<<0:1,90:7>>;
Enc12@element =:= 'cross-road' ->
<<0:1,91:7>>;
Enc12@element =:= 'side-road' ->
<<0:1,92:7>>;
Enc12@element =:= 'bus-stop' ->
<<0:1,93:7>>;
Enc12@element =:= intersection ->
<<0:1,94:7>>;
Enc12@element =:= 'roadside-park' ->
<<0:1,95:7>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc12@element}}})
end
end,
begin
%% attribute dateTime(5) with type DDateTime
Enc15@element = element(6, Val),
'Common':enc_DDateTime(Enc15@element)
end|begin
%% attribute vertEvent(6) with type BIT STRING
Enc16@element = element(7, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc17@bs = try bit_string_name2pos_10(Enc16@element) of
Enc17@positions ->
bitstring_from_positions(Enc17@positions, 5)
catch throw:invalid ->
adjust_trailing_zeroes(Enc16@element, 5)
end,
Enc17@bits = bit_size(Enc17@bs),
if Enc17@bits =:= 5 ->
Enc17@bs
end
end
end
end].


dec_ObstacleDetection(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute obDist(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute obDirect(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:15,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute description(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute locationDetails(4) with type ENUMERATED
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:7,V6@Buf4/bitstring>> ->
V6@Int5 = case V6@V3 of
0 -> 'on-bridges';
1 -> 'in-tunnels';
2 -> 'entering-or-leaving-tunnels';
3 -> 'on-ramps';
4 -> 'in-road-construction-area';
5 -> 'around-a-curve';
6 -> 'on-minor-roads';
7 -> 'in-the-opposing-lanes';
8 -> 'adjacent-to-roadway';
9 -> 'on-bend';
10 -> 'entire-intersection';
11 -> 'in-the-median';
12 -> 'moved-to-side-of-road';
13 -> 'moved-to-shoulder';
14 -> 'on-the-roadway';
15 -> 'in-shaded-areas';
16 -> 'in-low-lying-areas';
17 -> 'in-the-downtown-area';
18 -> 'in-the-inner-city-area';
19 -> 'in-parts';
20 -> 'in-some-places';
21 -> 'in-the-ditch';
22 -> 'in-the-valley';
23 -> 'on-hill-top';
24 -> 'near-the-foothills';
25 -> 'at-high-altitudes';
26 -> 'near-the-lake';
27 -> 'near-the-shore';
28 -> 'over-the-crest-of-a-hill';
29 -> 'other-than-on-the-roadway';
30 -> 'near-the-beach';
31 -> 'near-beach-access-point';
32 -> 'lower-level';
33 -> 'upper-level';
34 -> airport;
35 -> concourse;
36 -> gate;
37 -> 'baggage-claim';
38 -> 'customs-point';
39 -> station;
40 -> platform;
41 -> dock;
42 -> depot;
43 -> 'ev-charging-point';
44 -> 'information-welcome-point';
45 -> 'at-rest-area';
46 -> 'at-service-area';
47 -> 'at-weigh-station';
48 -> 'picnic-areas';
49 -> 'rest-area';
50 -> 'service-stations';
51 -> toilets;
52 -> 'on-the-right';
53 -> 'on-the-left';
54 -> 'in-the-center';
55 -> 'in-the-opposite-direction';
56 -> 'cross-traffic';
57 -> 'northbound-traffic';
58 -> 'eastbound-traffic';
59 -> 'southbound-traffic';
60 -> 'westbound-traffic';
61 -> north;
62 -> south;
63 -> east;
64 -> west;
65 -> northeast;
66 -> northwest;
67 -> southeast;
68 -> southwest;
69 -> 'mountain-pass';
70 -> 'reservation-center';
71 -> 'nearby-basin';
72 -> 'on-tracks';
73 -> dip;
74 -> 'traffic-circle';
75 -> 'park-and-ride-lot';
76 -> to;
77 -> by;
78 -> through;
79 -> 'area-of';
80 -> under;
81 -> over;
82 -> from;
83 -> approaching;
84 -> 'entering-at';
85 -> 'exiting-at';
86 -> 'across-tracks';
87 -> 'in-street';
88 -> 'on-curve';
89 -> shoulder;
90 -> crossover;
91 -> 'cross-road';
92 -> 'side-road';
93 -> 'bus-stop';
94 -> intersection;
95 -> 'roadside-park';
_ -> exit({error,{asn1,{decode_enumerated,V6@V3}}})
end,
{V6@Int5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:6,V6@Buf7/bitstring>> ->
{V6@V6,V6@Buf7};
<<1:1,V6@Buf5/bitstring>> ->
{V6@V6,V6@Buf7} = case V6@Buf5 of
<<0:1,V6@V9:7,V6@Buf10/bitstring>> when V6@V9 =/= 0 ->
{V6@V9,V6@Buf10};
<<1:1,0:1,V6@V10:14,V6@Buf11/bitstring>> when V6@V10 =/= 0 ->
{V6@V10,V6@Buf11};
<<1:1,1:1,V6@V10:6,V6@Buf11/bitstring>> when V6@V10 =/= 0 ->
V6@Mul12 = V6@V10 * 16384,
{V6@Mul12,V6@Buf11}
end,
<<V6@V13:V6@V6/unit:8,V6@Buf14/bitstring>> = V6@Buf7,
{V6@V13,V6@Buf14}
end,
V6@Int15 = case V6@V3 of
_ -> {asn1_enum,V6@V3}
end,
{V6@Int15,V6@Buf4}
end,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute dateTime(5) with type DDateTime
{Term5,Bytes7} = 'Common':dec_DDateTime(Bytes6),

%% attribute vertEvent(6) with type BIT STRING
{Term6,Bytes8} = case Opt band 1 of
1 ->
begin
<<V7@V0:5/binary-unit:1,V7@Buf1/bitstring>> = Bytes7,
{V7@V2,V7@Buf3}  = {decode_named_bit_string(V7@V0, [{notEquipped,0},{leftFront,1},{leftRear,2},{rightFront,3},{rightRear,4}]),V7@Buf1},
{V7@V2,V7@Buf3}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V8@V0,V8@Buf1} = case Bytes8 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8};
<<1:1,1:1,V8@V7:6,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
V8@Mul9 = V8@V7 * 16384,
{V8@Mul9,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V10:V8@V0/bitstring-unit:1,V8@Buf11/bitstring>> = V8@Buf1,
{V8@V10,V8@Buf11}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = {'ObstacleDetection',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes10}.

enc_PivotPointDescription(Val) ->
[begin
%% attribute pivotOffset(1) with type INTEGER
Enc2@element = element(2, Val),
Enc2@element@sub = Enc2@element - -1024,
if Enc2@element@sub bsr 11 =:= 0 ->
<<0:1,Enc2@element@sub:11>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute pivotAngle(2) with type INTEGER
Enc4@element = element(3, Val),
if 0 =< Enc4@element, Enc4@element < 28801 ->
<<Enc4@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end|begin
%% attribute pivots(3) with type BOOLEAN
Enc6@element = element(4, Val),
if Enc6@element =:= false ->
<<0:1>>;
Enc6@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc6@element}}})
end
end].


dec_PivotPointDescription(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute pivotOffset(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:11,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + -1024,
{V2@Add2,V2@Buf1}
end,

%% attribute pivotAngle(2) with type INTEGER
{Term2,Bytes3} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute pivots(3) with type BOOLEAN
{Term3,Bytes4} = begin
<<V4@V0:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> false;
1 -> true
end,
{V4@Int2,V4@Buf1}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'PivotPointDescription',Term1,Term2,Term3},
{Res1,Bytes6}.

enc_RTCMPackage(Val) ->
[begin
Enc1@element = element(2, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
%% attribute rtcmHeader(1) with type RTCMheader
Enc3@element = element(2, Val),
if Enc3@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_RTCMheader(Enc3@element)
end
end|begin
%% attribute msgs(2) with type RTCMmessageList
Enc5@element = element(3, Val),
'Common':enc_RTCMmessageList(Enc5@element)
end].


dec_RTCMPackage(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute rtcmHeader(1) with type RTCMheader
{Term1,Bytes3} = case Opt band 1 of
1 ->
'Common':dec_RTCMheader(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute msgs(2) with type RTCMmessageList
{Term2,Bytes4} = 'Common':dec_RTCMmessageList(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'RTCMPackage',Term1,Term2},
{Res1,Bytes6}.

enc_SpecialVehicleExtensions(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
if Enc3@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute vehicleAlerts(1) with type EmergencyDetails
Enc5@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_EmergencyDetails(Enc5@element)
end
end,
begin
%% attribute description(2) with type EventDescription
Enc7@element = element(3, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
enc_EventDescription(Enc7@element)
end
end|begin
%% attribute trailers(3) with type TrailerData
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
enc_TrailerData(Enc9@element)
end
end].


dec_SpecialVehicleExtensions(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute vehicleAlerts(1) with type EmergencyDetails
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
'Common':dec_EmergencyDetails(Bytes2);
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute description(2) with type EventDescription
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
dec_EventDescription(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute trailers(3) with type TrailerData
{Term3,Bytes5} = case Opt band 1 of
1 ->
dec_TrailerData(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V3@V0,V3@Buf1} = case Bytes5 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'SpecialVehicleExtensions',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_SpeedProfileMeasurementList(Val) ->
Enc2@len = length(Val),
Enc2@len@sub = Enc2@len - 1,
if 0 =< Enc2@len@sub, Enc2@len@sub < 20 ->
[<<Enc2@len@sub:5>>|[if Comp bsr 5 =:= 0 ->
<<Comp:5>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]]
end.



dec_SpeedProfileMeasurementList(Bytes) ->
%% Length with constraint {1,20}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components11(V1@Add2, V1@Buf1, []).

enc_SpeedProfile(Val) ->
[<<0:1>>|begin
%% attribute speedReports(1) with type SpeedProfileMeasurementList
Enc2@element = element(2, Val),
enc_SpeedProfileMeasurementList(Enc2@element)
end].


dec_SpeedProfile(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute speedReports(1) with type SpeedProfileMeasurementList
{Term1,Bytes2} = dec_SpeedProfileMeasurementList(Bytes1),

%% Extensions
{Extensions,Bytes3} = case Ext of
0 -> {<<>>,Bytes2};
1 ->
{V2@V0,V2@Buf1} = case Bytes2 of
<<0:1,V2@V3:6,V2@Buf4/bitstring>> ->
V2@Add5 = V2@V3 + 1,
{V2@Add5,V2@Buf4};
<<1:1,V2@Buf2/bitstring>> ->
{V2@V3,V2@Buf4} = case V2@Buf2 of
<<0:1,V2@V6:7,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7};
<<1:1,0:1,V2@V7:14,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
{V2@V7,V2@Buf8};
<<1:1,1:1,V2@V7:6,V2@Buf8/bitstring>> when V2@V7 =/= 0 ->
V2@Mul9 = V2@V7 * 16384,
{V2@Mul9,V2@Buf8}
end,
{V2@V3,V2@Buf4}
end,
<<V2@V10:V2@V0/bitstring-unit:1,V2@Buf11/bitstring>> = V2@Buf1,
{V2@V10,V2@Buf11}
end,
Bytes4= skipextensions(Bytes3, 1, Extensions),
Res1 = {'SpeedProfile',Term1},
{Res1,Bytes4}.

enc_SupplementalVehicleExtensions(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(6, Val),
Enc6@element = element(7, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(8, Val),
Enc8@element = element(9, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc9@element = element(10, Val),
Enc10@element = element(11, Val),
if Enc9@element =:= asn1_NOVALUE ->
if Enc10@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc10@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute classification(1) with type INTEGER
Enc12@element = element(2, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
Enc12@element bsr 8 =:= 0 ->
Enc12@element;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end,
begin
%% attribute classDetails(2) with type VehicleClassification
Enc15@element = element(3, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_VehicleClassification(Enc15@element)
end
end,
begin
%% attribute vehicleData(3) with type VehicleData
Enc17@element = element(4, Val),
if Enc17@element =:= asn1_NOVALUE ->
[];
true ->
enc_VehicleData(Enc17@element)
end
end,
begin
%% attribute weatherReport(4) with type WeatherReport
Enc19@element = element(5, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
enc_WeatherReport(Enc19@element)
end
end,
begin
%% attribute weatherProbe(5) with type WeatherProbe
Enc21@element = element(6, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
enc_WeatherProbe(Enc21@element)
end
end,
begin
%% attribute obstacle(6) with type ObstacleDetection
Enc23@element = element(7, Val),
if Enc23@element =:= asn1_NOVALUE ->
[];
true ->
enc_ObstacleDetection(Enc23@element)
end
end,
begin
%% attribute status(7) with type DisabledVehicle
Enc25@element = element(8, Val),
if Enc25@element =:= asn1_NOVALUE ->
[];
true ->
enc_DisabledVehicle(Enc25@element)
end
end,
begin
%% attribute speedProfile(8) with type SpeedProfile
Enc27@element = element(9, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
enc_SpeedProfile(Enc27@element)
end
end,
begin
%% attribute theRTCM(9) with type RTCMPackage
Enc29@element = element(10, Val),
if Enc29@element =:= asn1_NOVALUE ->
[];
true ->
enc_RTCMPackage(Enc29@element)
end
end|begin
%% attribute regional(10) with type SEQUENCE OF
Enc31@element = element(11, Val),
if Enc31@element =:= asn1_NOVALUE ->
[];
true ->
enc_SupplementalVehicleExtensions_regional(Enc31@element)
end
end].
enc_SupplementalVehicleExtensions_regional(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 2 =:= 0 ->
[<<Enc1@len@sub:2>>|[enc_SupplementalVehicleExtensions_regional_RegionalExtension(Comp) || Comp <- Val]]
end.

enc_SupplementalVehicleExtensions_regional_RegionalExtension(Val) ->
Enc1@element = element(2, Val),
[begin
%% attribute regionId(1) with type INTEGER
Enc2@element = Enc1@element,
if Enc2@element bsr 8 =:= 0 ->
Enc2@element;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end|begin
%% attribute regExtValue(2) with type Type
Enc4@element = element(3, Val),
Enc5@output = enc_os_Type2(Enc4@element, Enc1@element),
Enc5@bin = complete(Enc5@output),
Enc5@len = byte_size(Enc5@bin),
if Enc5@len < 128 ->
[Enc5@len|Enc5@bin];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc5@bin];
true ->
encode_fragmented(Enc5@bin, 8)
end
end].


dec_SupplementalVehicleExtensions(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:10,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute classification(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 9) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute classDetails(2) with type VehicleClassification
{Term2,Bytes4} = case (Opt bsr 8) band 1 of
1 ->
'Common':dec_VehicleClassification(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute vehicleData(3) with type VehicleData
{Term3,Bytes5} = case (Opt bsr 7) band 1 of
1 ->
dec_VehicleData(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute weatherReport(4) with type WeatherReport
{Term4,Bytes6} = case (Opt bsr 6) band 1 of
1 ->
dec_WeatherReport(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute weatherProbe(5) with type WeatherProbe
{Term5,Bytes7} = case (Opt bsr 5) band 1 of
1 ->
dec_WeatherProbe(Bytes6);
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute obstacle(6) with type ObstacleDetection
{Term6,Bytes8} = case (Opt bsr 4) band 1 of
1 ->
dec_ObstacleDetection(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute status(7) with type DisabledVehicle
{Term7,Bytes9} = case (Opt bsr 3) band 1 of
1 ->
dec_DisabledVehicle(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute speedProfile(8) with type SpeedProfile
{Term8,Bytes10} = case (Opt bsr 2) band 1 of
1 ->
dec_SpeedProfile(Bytes9);
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute theRTCM(9) with type RTCMPackage
{Term9,Bytes11} = case (Opt bsr 1) band 1 of
1 ->
dec_RTCMPackage(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute regional(10) with type SEQUENCE OF
{Term10,Bytes12} = case Opt band 1 of
1 ->
dec_SupplementalVehicleExtensions_regional(Bytes11);
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% Extensions
{Extensions,Bytes13} = case Ext of
0 -> {<<>>,Bytes12};
1 ->
{V4@V0,V4@Buf1} = case Bytes12 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<1:1,1:1,V4@V7:6,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
V4@Mul9 = V4@V7 * 16384,
{V4@Mul9,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes14= skipextensions(Bytes13, 1, Extensions),
Res1 = {'SupplementalVehicleExtensions',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10},
{Res1,Bytes14}.


dec_SupplementalVehicleExtensions_regional(Bytes) ->
%% Length with constraint {1,4}
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components12(V1@Add2, V1@Buf1, []).


dec_SupplementalVehicleExtensions_regional_RegionalExtension(Bytes) ->

%% attribute regionId(1) with type INTEGER
{Term1,Bytes1} = begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute regExtValue(2) with type Type
{Tmpterm1, Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
{V2@V0,V2@Buf1}
end,
Term2 = dec_os_Type6(Tmpterm1, Term1),
Res1 = {'RegionalExtension',Term1,Term2},
{Res1,Bytes2}.

enc_TrailerData(Val) ->
[begin
%% attribute notUsed(1) with type INTEGER
Enc2@element = element(2, Val),
if Enc2@element bsr 5 =:= 0 ->
<<0:1,Enc2@element:5>>;
true ->
exit({error,{asn1,{illegal_integer,Enc2@element}}})
end
end,
begin
%% attribute connection(2) with type PivotPointDescription
Enc4@element = element(3, Val),
enc_PivotPointDescription(Enc4@element)
end|begin
%% attribute units(3) with type TrailerUnitDescriptionList
Enc5@element = element(4, Val),
enc_TrailerUnitDescriptionList(Enc5@element)
end].


dec_TrailerData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute notUsed(1) with type INTEGER
{Term1,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute connection(2) with type PivotPointDescription
{Term2,Bytes3} = dec_PivotPointDescription(Bytes2),

%% attribute units(3) with type TrailerUnitDescriptionList
{Term3,Bytes4} = dec_TrailerUnitDescriptionList(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8};
<<1:1,1:1,V3@V7:6,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
V3@Mul9 = V3@V7 * 16384,
{V3@Mul9,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V10:V3@V0/bitstring-unit:1,V3@Buf11/bitstring>> = V3@Buf1,
{V3@V10,V3@Buf11}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'TrailerData',Term1,Term2,Term3},
{Res1,Bytes6}.

enc_TrailerHistoryPointList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if 0 =< Enc1@len@sub, Enc1@len@sub < 23 ->
[<<Enc1@len@sub:5>>|[enc_TrailerHistoryPoint(Comp) || Comp <- Val]]
end.



dec_TrailerHistoryPointList(Bytes) ->
%% Length with constraint {1,23}
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components13(V1@Add2, V1@Buf1, []).

enc_TrailerHistoryPoint(Val) ->
[begin
Enc1@element = element(5, Val),
Enc2@element = element(6, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute pivotAngle(1) with type INTEGER
Enc4@element = element(2, Val),
if 0 =< Enc4@element, Enc4@element < 28801 ->
<<Enc4@element:15>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end,
begin
%% attribute timeOffset(2) with type INTEGER
Enc6@element = element(3, Val),
Enc6@element@sub = Enc6@element - 1,
if 0 =< Enc6@element@sub, Enc6@element@sub < 65535 ->
<<Enc6@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end,
begin
%% attribute positionOffset(3) with type Node-XY-24b
Enc8@element = element(4, Val),
'Common':'enc_Node-XY-24b'(Enc8@element)
end,
begin
%% attribute elevationOffset(4) with type INTEGER
Enc9@element = element(5, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc9@element@sub = Enc9@element - -64,
if Enc9@element@sub bsr 7 =:= 0 ->
<<Enc9@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end
end
end|begin
%% attribute heading(5) with type INTEGER
Enc12@element = element(6, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
0 =< Enc12@element, Enc12@element < 241 ->
[Enc12@element];
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end].


dec_TrailerHistoryPoint(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute pivotAngle(1) with type INTEGER
{Term1,Bytes3} = begin
<<V3@V0:15,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute timeOffset(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
{V4@Add2,V4@Buf1}
end,

%% attribute positionOffset(3) with type Node-XY-24b
{Term3,Bytes5} = 'Common':'dec_Node-XY-24b'(Bytes4),

%% attribute elevationOffset(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:7,V5@Buf1/bitstring>> = Bytes5,
V5@Add2 = V5@V0 + -64,
{V5@Add2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute heading(5) with type INTEGER
{Term5,Bytes7} = case Opt band 1 of
1 ->
begin
<<V6@V0:8,V6@Buf1/bitstring>> = Bytes6,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V7@V0,V7@Buf1} = case Bytes7 of
<<0:1,V7@V3:6,V7@Buf4/bitstring>> ->
V7@Add5 = V7@V3 + 1,
{V7@Add5,V7@Buf4};
<<1:1,V7@Buf2/bitstring>> ->
{V7@V3,V7@Buf4} = case V7@Buf2 of
<<0:1,V7@V6:7,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7};
<<1:1,0:1,V7@V7:14,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
{V7@V7,V7@Buf8};
<<1:1,1:1,V7@V7:6,V7@Buf8/bitstring>> when V7@V7 =/= 0 ->
V7@Mul9 = V7@V7 * 16384,
{V7@Mul9,V7@Buf8}
end,
{V7@V3,V7@Buf4}
end,
<<V7@V10:V7@V0/bitstring-unit:1,V7@Buf11/bitstring>> = V7@Buf1,
{V7@V10,V7@Buf11}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'TrailerHistoryPoint',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes9}.

enc_TrailerUnitDescriptionList(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 3 =:= 0 ->
[<<Enc1@len@sub:3>>|[enc_TrailerUnitDescription(Comp) || Comp <- Val]]
end.



dec_TrailerUnitDescriptionList(Bytes) ->
%% Length with constraint {1,8}
<<V1@V0:3,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components14(V1@Add2, V1@Buf1, []).

enc_TrailerUnitDescription(Val) ->
[begin
Enc1@element = element(5, Val),
Enc2@element = element(6, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(7, Val),
Enc4@element = element(8, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(10, Val),
Enc6@element = element(11, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc6@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc6@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc7@element = element(13, Val),
Enc8@element = element(14, Val),
if Enc7@element =:= asn1_NOVALUE ->
if Enc8@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc8@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute isDolly(1) with type BOOLEAN
Enc10@element = element(2, Val),
if Enc10@element =:= false ->
<<0:1>>;
Enc10@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc10@element}}})
end
end,
begin
%% attribute width(2) with type INTEGER
Enc12@element = element(3, Val),
if Enc12@element bsr 10 =:= 0 ->
<<Enc12@element:10>>;
true ->
exit({error,{asn1,{illegal_integer,Enc12@element}}})
end
end,
begin
%% attribute length(3) with type INTEGER
Enc14@element = element(4, Val),
if Enc14@element bsr 12 =:= 0 ->
<<Enc14@element:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc14@element}}})
end
end,
begin
%% attribute height(4) with type INTEGER
Enc16@element = element(5, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
Enc16@element bsr 7 =:= 0 ->
<<Enc16@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc16@element}}})
end
end,
begin
%% attribute mass(5) with type INTEGER
Enc19@element = element(6, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
Enc19@element bsr 8 =:= 0 ->
Enc19@element;
true ->
exit({error,{asn1,{illegal_integer,Enc19@element}}})
end
end,
begin
%% attribute bumperHeights(6) with type BumperHeights
Enc22@element = element(7, Val),
if Enc22@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_BumperHeights(Enc22@element)
end
end,
begin
%% attribute centerOfGravity(7) with type INTEGER
Enc24@element = element(8, Val),
if Enc24@element =:= asn1_NOVALUE ->
[];
Enc24@element bsr 7 =:= 0 ->
<<Enc24@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc24@element}}})
end
end,
begin
%% attribute frontPivot(8) with type PivotPointDescription
Enc27@element = element(9, Val),
enc_PivotPointDescription(Enc27@element)
end,
begin
%% attribute rearPivot(9) with type PivotPointDescription
Enc28@element = element(10, Val),
if Enc28@element =:= asn1_NOVALUE ->
[];
true ->
enc_PivotPointDescription(Enc28@element)
end
end,
begin
%% attribute rearWheelOffset(10) with type INTEGER
Enc30@element = element(11, Val),
if Enc30@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc30@element@sub = Enc30@element - -2048,
if Enc30@element@sub bsr 12 =:= 0 ->
<<Enc30@element@sub:12>>;
true ->
exit({error,{asn1,{illegal_integer,Enc30@element}}})
end
end
end
end,
begin
%% attribute positionOffset(11) with type Node-XY-24b
Enc33@element = element(12, Val),
'Common':'enc_Node-XY-24b'(Enc33@element)
end,
begin
%% attribute elevationOffset(12) with type INTEGER
Enc34@element = element(13, Val),
if Enc34@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc34@element@sub = Enc34@element - -64,
if Enc34@element@sub bsr 7 =:= 0 ->
<<Enc34@element@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc34@element}}})
end
end
end
end|begin
%% attribute crumbData(13) with type TrailerHistoryPointList
Enc37@element = element(14, Val),
if Enc37@element =:= asn1_NOVALUE ->
[];
true ->
enc_TrailerHistoryPointList(Enc37@element)
end
end].


dec_TrailerUnitDescription(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute isDolly(1) with type BOOLEAN
{Term1,Bytes3} = begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end,

%% attribute width(2) with type INTEGER
{Term2,Bytes4} = begin
<<V4@V0:10,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute length(3) with type INTEGER
{Term3,Bytes5} = begin
<<V5@V0:12,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end,

%% attribute height(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V6@V0:7,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute mass(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V7@V0:8,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute bumperHeights(6) with type BumperHeights
{Term6,Bytes8} = case (Opt bsr 5) band 1 of
1 ->
'Common':dec_BumperHeights(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute centerOfGravity(7) with type INTEGER
{Term7,Bytes9} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V8@V0:7,V8@Buf1/bitstring>> = Bytes8,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute frontPivot(8) with type PivotPointDescription
{Term8,Bytes10} = dec_PivotPointDescription(Bytes9),

%% attribute rearPivot(9) with type PivotPointDescription
{Term9,Bytes11} = case (Opt bsr 3) band 1 of
1 ->
dec_PivotPointDescription(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% attribute rearWheelOffset(10) with type INTEGER
{Term10,Bytes12} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V9@V0:12,V9@Buf1/bitstring>> = Bytes11,
V9@Add2 = V9@V0 + -2048,
{V9@Add2,V9@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes11}
end,

%% attribute positionOffset(11) with type Node-XY-24b
{Term11,Bytes13} = 'Common':'dec_Node-XY-24b'(Bytes12),

%% attribute elevationOffset(12) with type INTEGER
{Term12,Bytes14} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V10@V0:7,V10@Buf1/bitstring>> = Bytes13,
V10@Add2 = V10@V0 + -64,
{V10@Add2,V10@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes13}
end,

%% attribute crumbData(13) with type TrailerHistoryPointList
{Term13,Bytes15} = case Opt band 1 of
1 ->
dec_TrailerHistoryPointList(Bytes14);
0 ->
{asn1_NOVALUE,Bytes14}
end,

%% Extensions
{Extensions,Bytes16} = case Ext of
0 -> {<<>>,Bytes15};
1 ->
{V11@V0,V11@Buf1} = case Bytes15 of
<<0:1,V11@V3:6,V11@Buf4/bitstring>> ->
V11@Add5 = V11@V3 + 1,
{V11@Add5,V11@Buf4};
<<1:1,V11@Buf2/bitstring>> ->
{V11@V3,V11@Buf4} = case V11@Buf2 of
<<0:1,V11@V6:7,V11@Buf7/bitstring>> when V11@V6 =/= 0 ->
{V11@V6,V11@Buf7};
<<1:1,0:1,V11@V7:14,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
{V11@V7,V11@Buf8};
<<1:1,1:1,V11@V7:6,V11@Buf8/bitstring>> when V11@V7 =/= 0 ->
V11@Mul9 = V11@V7 * 16384,
{V11@Mul9,V11@Buf8}
end,
{V11@V3,V11@Buf4}
end,
<<V11@V10:V11@V0/bitstring-unit:1,V11@Buf11/bitstring>> = V11@Buf1,
{V11@V10,V11@Buf11}
end,
Bytes17= skipextensions(Bytes16, 1, Extensions),
Res1 = {'TrailerUnitDescription',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11,Term12,Term13},
{Res1,Bytes17}.

enc_VehicleData(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
Enc4@element = element(5, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
%% attribute height(1) with type INTEGER
Enc6@element = element(2, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element bsr 7 =:= 0 ->
<<Enc6@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end,
begin
%% attribute bumpers(2) with type BumperHeights
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_BumperHeights(Enc9@element)
end
end,
begin
%% attribute mass(3) with type INTEGER
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
Enc11@element bsr 8 =:= 0 ->
Enc11@element;
true ->
exit({error,{asn1,{illegal_integer,Enc11@element}}})
end
end|begin
%% attribute trailerWeight(4) with type INTEGER
Enc14@element = element(5, Val),
if Enc14@element =:= asn1_NOVALUE ->
[];
0 =< Enc14@element, Enc14@element < 64256 ->
<<Enc14@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc14@element}}})
end
end].


dec_VehicleData(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:4,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute height(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V3@V0:7,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute bumpers(2) with type BumperHeights
{Term2,Bytes4} = case (Opt bsr 2) band 1 of
1 ->
'Common':dec_BumperHeights(Bytes3);
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute mass(3) with type INTEGER
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes4,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute trailerWeight(4) with type INTEGER
{Term4,Bytes6} = case Opt band 1 of
1 ->
begin
<<V5@V0:16,V5@Buf1/bitstring>> = Bytes5,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V6@V0,V6@Buf1} = case Bytes6 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8};
<<1:1,1:1,V6@V7:6,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
V6@Mul9 = V6@V7 * 16384,
{V6@Mul9,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V10:V6@V0/bitstring-unit:1,V6@Buf11/bitstring>> = V6@Buf1,
{V6@V10,V6@Buf11}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
Res1 = {'VehicleData',Term1,Term2,Term3,Term4},
{Res1,Bytes8}.

enc_WeatherProbe(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(4, Val),
if Enc3@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute airTemp(1) with type INTEGER
Enc5@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
0 =< Enc5@element, Enc5@element < 192 ->
Enc5@element;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end,
begin
%% attribute airPressure(2) with type INTEGER
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
Enc8@element bsr 8 =:= 0 ->
Enc8@element;
true ->
exit({error,{asn1,{illegal_integer,Enc8@element}}})
end
end|begin
%% attribute rainRates(3) with type WiperSet
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
'Common':enc_WiperSet(Enc11@element)
end
end].


dec_WeatherProbe(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:3,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute airTemp(1) with type INTEGER
{Term1,Bytes3} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V3@V0:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute airPressure(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V4@V0:8,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute rainRates(3) with type WiperSet
{Term3,Bytes5} = case Opt band 1 of
1 ->
'Common':dec_WiperSet(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V5@V0,V5@Buf1} = case Bytes5 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<0:1,V5@V6:7,V5@Buf7/bitstring>> when V5@V6 =/= 0 ->
{V5@V6,V5@Buf7};
<<1:1,0:1,V5@V7:14,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
{V5@V7,V5@Buf8};
<<1:1,1:1,V5@V7:6,V5@Buf8/bitstring>> when V5@V7 =/= 0 ->
V5@Mul9 = V5@V7 * 16384,
{V5@Mul9,V5@Buf8}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V10:V5@V0/bitstring-unit:1,V5@Buf11/bitstring>> = V5@Buf1,
{V5@V10,V5@Buf11}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'WeatherProbe',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_WeatherReport(Val) ->
[begin
Enc1@element = element(3, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc3@element = element(5, Val),
Enc4@element = element(6, Val),
if Enc3@element =:= asn1_NOVALUE ->
if Enc4@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc4@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc5@element = element(7, Val),
%% attribute isRaining(1) with type ENUMERATED
Enc7@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
if Enc7@element =:= precip ->
<<0:1,0:2>>;
Enc7@element =:= noPrecip ->
<<0:1,1:2>>;
Enc7@element =:= error ->
<<0:1,2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end;
true ->
if Enc7@element =:= precip ->
<<1:1,0:2>>;
Enc7@element =:= noPrecip ->
<<1:1,1:2>>;
Enc7@element =:= error ->
<<1:1,2:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end
end
end,
begin
%% attribute rainRate(2) with type INTEGER
Enc9@element = element(3, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
Enc9@element bsr 16 =:= 0 ->
<<Enc9@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc9@element}}})
end
end,
begin
%% attribute precipSituation(3) with type ENUMERATED
Enc12@element = element(4, Val),
if Enc12@element =:= asn1_NOVALUE ->
[];
Enc12@element =:= other ->
<<0:4>>;
Enc12@element =:= unknown ->
<<1:4>>;
Enc12@element =:= noPrecipitation ->
<<2:4>>;
Enc12@element =:= unidentifiedSlight ->
<<3:4>>;
Enc12@element =:= unidentifiedModerate ->
<<4:4>>;
Enc12@element =:= unidentifiedHeavy ->
<<5:4>>;
Enc12@element =:= snowSlight ->
<<6:4>>;
Enc12@element =:= snowModerate ->
<<7:4>>;
Enc12@element =:= snowHeavy ->
<<8:4>>;
Enc12@element =:= rainSlight ->
<<9:4>>;
Enc12@element =:= rainModerate ->
<<10:4>>;
Enc12@element =:= rainHeavy ->
<<11:4>>;
Enc12@element =:= frozenPrecipitationSlight ->
<<12:4>>;
Enc12@element =:= frozenPrecipitationModerate ->
<<13:4>>;
Enc12@element =:= frozenPrecipitationHeavy ->
<<14:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc12@element}}})
end
end,
begin
%% attribute solarRadiation(4) with type INTEGER
Enc15@element = element(5, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
Enc15@element bsr 16 =:= 0 ->
<<Enc15@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc15@element}}})
end
end,
begin
%% attribute friction(5) with type INTEGER
Enc18@element = element(6, Val),
if Enc18@element =:= asn1_NOVALUE ->
[];
0 =< Enc18@element, Enc18@element < 102 ->
<<Enc18@element:7>>;
true ->
exit({error,{asn1,{illegal_integer,Enc18@element}}})
end
end|begin
%% attribute roadFriction(6) with type INTEGER
Enc21@element = element(7, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
0 =< Enc21@element, Enc21@element < 51 ->
<<Enc21@element:6>>;
true ->
exit({error,{asn1,{illegal_integer,Enc21@element}}})
end
end].


dec_WeatherReport(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:5,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute isRaining(1) with type ENUMERATED
{Term1,Bytes3} = begin
<<V3@V0:2,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> precip;
1 -> noPrecip;
2 -> error;
_ -> exit({error,{asn1,{decode_enumerated,V3@V0}}})
end,
{V3@Int2,V3@Buf1}
end,

%% attribute rainRate(2) with type INTEGER
{Term2,Bytes4} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V4@V0:16,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute precipSituation(3) with type ENUMERATED
{Term3,Bytes5} = case (Opt bsr 3) band 1 of
1 ->
begin
<<V5@V0:4,V5@Buf1/bitstring>> = Bytes4,
V5@Int2 = case V5@V0 of
0 -> other;
1 -> unknown;
2 -> noPrecipitation;
3 -> unidentifiedSlight;
4 -> unidentifiedModerate;
5 -> unidentifiedHeavy;
6 -> snowSlight;
7 -> snowModerate;
8 -> snowHeavy;
9 -> rainSlight;
10 -> rainModerate;
11 -> rainHeavy;
12 -> frozenPrecipitationSlight;
13 -> frozenPrecipitationModerate;
14 -> frozenPrecipitationHeavy;
_ -> exit({error,{asn1,{decode_enumerated,V5@V0}}})
end,
{V5@Int2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute solarRadiation(4) with type INTEGER
{Term4,Bytes6} = case (Opt bsr 2) band 1 of
1 ->
begin
<<V6@V0:16,V6@Buf1/bitstring>> = Bytes5,
{V6@V0,V6@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute friction(5) with type INTEGER
{Term5,Bytes7} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V7@V0:7,V7@Buf1/bitstring>> = Bytes6,
{V7@V0,V7@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute roadFriction(6) with type INTEGER
{Term6,Bytes8} = case Opt band 1 of
1 ->
begin
<<V8@V0:6,V8@Buf1/bitstring>> = Bytes7,
{V8@V0,V8@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% Extensions
{Extensions,Bytes9} = case Ext of
0 -> {<<>>,Bytes8};
1 ->
{V9@V0,V9@Buf1} = case Bytes8 of
<<0:1,V9@V3:6,V9@Buf4/bitstring>> ->
V9@Add5 = V9@V3 + 1,
{V9@Add5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<0:1,V9@V6:7,V9@Buf7/bitstring>> when V9@V6 =/= 0 ->
{V9@V6,V9@Buf7};
<<1:1,0:1,V9@V7:14,V9@Buf8/bitstring>> when V9@V7 =/= 0 ->
{V9@V7,V9@Buf8};
<<1:1,1:1,V9@V7:6,V9@Buf8/bitstring>> when V9@V7 =/= 0 ->
V9@Mul9 = V9@V7 * 16384,
{V9@Mul9,V9@Buf8}
end,
{V9@V3,V9@Buf4}
end,
<<V9@V10:V9@V0/bitstring-unit:1,V9@Buf11/bitstring>> = V9@Buf1,
{V9@V10,V9@Buf11}
end,
Bytes10= skipextensions(Bytes9, 1, Extensions),
Res1 = {'WeatherReport',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes10}.

enc_IsDolly(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_IsDolly(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_ObstacleDirection(Val) ->
if 0 =< Val, Val < 28801 ->
<<Val:15>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ObstacleDirection(Bytes) ->
begin
<<V1@V0:15,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_PivotingAllowed(Val) ->
if Val =:= false ->
<<0:1>>;
Val =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Val}}})
end.


dec_PivotingAllowed(Bytes) ->
begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end.

enc_SpeedProfileMeasurement(Val) ->
if Val bsr 5 =:= 0 ->
<<Val:5>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_SpeedProfileMeasurement(Bytes) ->
begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TrailerMass(Val) ->
if Val bsr 8 =:= 0 ->
[Val];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TrailerMass(Bytes) ->
begin
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

'enc_VertOffset-B07'(Val) ->
Val@sub = Val - -64,
if Val@sub bsr 7 =:= 0 ->
<<Val@sub:7>>;
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


'dec_VertOffset-B07'(Bytes) ->
begin
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + -64,
{V1@Add2,V1@Buf1}
end.

vehicleSafetyExt() ->
0.

specialVehicleExt() ->
1.

supplementalVehicleExt() ->
2.

typeinfo('BasicSafetyMessage') ->
  {sequence,'BasicSafetyMessage',3,[{<<99,111,114,101,68,97,116,97>>,{typeinfo,{'Common','BSMcoreData'}},mandatory},{<<112,97,114,116,73,73>>,{sof,{sequence,'BasicSafetyMessage_partII_SEQOF',2,[{<<112,97,114,116,73,73,45,73,100>>,{'INTEGER',{0,63}},mandatory},{<<112,97,114,116,73,73,45,86,97,108,117,101>>,{'ObjClassFieldType',{'partII-Id',1},{componentrelation,{objectset,164,{'Externaltypereference',undefined,'BasicSafetyMessage',internal_object_set_argument_1}},[{outermost,[{'Externalvaluereference',164,'BasicSafetyMessage','partII-Id'}]}]}},mandatory}]}},'OPTIONAL'},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'BasicSafetyMessage_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,121,{'Externaltypereference',undefined,'BasicSafetyMessage',internal_object_set_argument_2}},[{outermost,[{'Externalvaluereference',121,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('PartII-Id') ->
  {'INTEGER',{0,63}};
typeinfo('DisabledVehicle') ->
  {sequence,'DisabledVehicle',2,[{<<115,116,97,116,117,115,68,101,116,97,105,108,115>>,{'INTEGER',{0,65535}},mandatory},{<<108,111,99,97,116,105,111,110,68,101,116,97,105,108,115>>,{'ENUMERATED_EXT',#{'ev-charging-point' => 7980,station => 7976,gate => 7973,'near-the-shore' => 7964,'customs-point' => 7975,'rest-area' => 7986,through => 8016,'in-the-valley' => 7959,'lower-level' => 7969,northeast => 8002,'on-the-left' => 7990,'at-weigh-station' => 7984,'eastbound-traffic' => 7995,'in-some-places' => 7957,'at-high-altitudes' => 7962,'on-tracks' => 8009,over => 8019,east => 8000,'in-the-center' => 7991,dip => 8010,'on-bend' => 7946,'near-the-beach' => 7967,southwest => 8005,'baggage-claim' => 7974,'near-the-foothills' => 7961,'service-stations' => 7987,'in-the-downtown-area' => 7954,'side-road' => 8030,'in-the-inner-city-area' => 7955,'adjacent-to-roadway' => 7945,'other-than-on-the-roadway' => 7966,'entering-at' => 8022,'mountain-pass' => 8006,'near-the-lake' => 7963,under => 8018,'in-parts' => 7956,'in-tunnels' => 7938,'in-road-construction-area' => 7941,approaching => 8021,depot => 7979,'upper-level' => 7970,'in-the-opposite-direction' => 7992,'in-shaded-areas' => 7952,to => 8014,'over-the-crest-of-a-hill' => 7965,concourse => 7972,'area-of' => 8017,'entering-or-leaving-tunnels' => 7939,southeast => 8004,'southbound-traffic' => 7996,'park-and-ride-lot' => 8012,'on-minor-roads' => 7943,'near-beach-access-point' => 7968,'in-the-opposing-lanes' => 7944,'information-welcome-point' => 7981,dock => 7978,'westbound-traffic' => 7997,by => 8015,'bus-stop' => 8031,platform => 7977,'across-tracks' => 8024,'reservation-center' => 8007,'around-a-curve' => 7942,south => 7999,intersection => 8032,'on-ramps' => 7940,west => 8001,'moved-to-side-of-road' => 7949,crossover => 8028,'cross-traffic' => 7993,'in-street' => 8025,'in-the-median' => 7948,'in-low-lying-areas' => 7953,'at-service-area' => 7983,'at-rest-area' => 7982,'on-the-roadway' => 7951,'exiting-at' => 8023,'on-the-right' => 7989,'on-curve' => 8026,shoulder => 8027,'on-bridges' => 7937,north => 7998,'nearby-basin' => 8008,'in-the-ditch' => 7958,'cross-road' => 8029,from => 8020,'northbound-traffic' => 7994,'picnic-areas' => 7985,toilets => 7988,northwest => 8003,'moved-to-shoulder' => 7950,'entire-intersection' => 7947,'on-hill-top' => 7960,airport => 7971,'roadside-park' => 8033,'traffic-circle' => 8011}},'OPTIONAL'}]};
typeinfo('EventDescription') ->
  {sequence,'EventDescription',6,[{<<116,121,112,101,69,118,101,110,116>>,{'INTEGER',{0,65535}},mandatory},{<<100,101,115,99,114,105,112,116,105,111,110>>,{sof,{'INTEGER',{0,65535}}},'OPTIONAL'},{<<112,114,105,111,114,105,116,121>>,octet_string,'OPTIONAL'},{<<104,101,97,100,105,110,103>>,{{bit_string_nnl,[{'from000-0to022-5degrees',0},{'from022-5to045-0degrees',1},{'from045-0to067-5degrees',2},{'from067-5to090-0degrees',3},{'from090-0to112-5degrees',4},{'from112-5to135-0degrees',5},{'from135-0to157-5degrees',6},{'from157-5to180-0degrees',7},{'from180-0to202-5degrees',8},{'from202-5to225-0degrees',9},{'from225-0to247-5degrees',10},{'from247-5to270-0degrees',11},{'from270-0to292-5degrees',12},{'from292-5to315-0degrees',13},{'from315-0to337-5degrees',14},{'from337-5to360-0degrees',15}]},16},'OPTIONAL'},{<<101,120,116,101,110,116>>,{'ENUMERATED',#{useInstantlyOnly => 0,useFor3meters => 1,useFor10meters => 2,useFor50meters => 3,useFor100meters => 4,useFor500meters => 5,useFor1000meters => 6,useFor5000meters => 7,useFor10000meters => 8,useFor50000meters => 9,useFor100000meters => 10,useFor500000meters => 11,useFor1000000meters => 12,useFor5000000meters => 13,useFor10000000meters => 14,forever => 15}},'OPTIONAL'},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'EventDescription_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,121,{'Externaltypereference',undefined,'BasicSafetyMessage',internal_object_set_argument_3}},[{outermost,[{'Externalvaluereference',121,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('ObstacleDetection') ->
  {sequence,'ObstacleDetection',6,[{<<111,98,68,105,115,116>>,{'INTEGER',{0,32767}},mandatory},{<<111,98,68,105,114,101,99,116>>,{'INTEGER',{0,28800}},mandatory},{<<100,101,115,99,114,105,112,116,105,111,110>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<108,111,99,97,116,105,111,110,68,101,116,97,105,108,115>>,{'ENUMERATED_EXT',#{'ev-charging-point' => 7980,station => 7976,gate => 7973,'near-the-shore' => 7964,'customs-point' => 7975,'rest-area' => 7986,through => 8016,'in-the-valley' => 7959,'lower-level' => 7969,northeast => 8002,'on-the-left' => 7990,'at-weigh-station' => 7984,'eastbound-traffic' => 7995,'in-some-places' => 7957,'at-high-altitudes' => 7962,'on-tracks' => 8009,over => 8019,east => 8000,'in-the-center' => 7991,dip => 8010,'on-bend' => 7946,'near-the-beach' => 7967,southwest => 8005,'baggage-claim' => 7974,'near-the-foothills' => 7961,'service-stations' => 7987,'in-the-downtown-area' => 7954,'side-road' => 8030,'in-the-inner-city-area' => 7955,'adjacent-to-roadway' => 7945,'other-than-on-the-roadway' => 7966,'entering-at' => 8022,'mountain-pass' => 8006,'near-the-lake' => 7963,under => 8018,'in-parts' => 7956,'in-tunnels' => 7938,'in-road-construction-area' => 7941,approaching => 8021,depot => 7979,'upper-level' => 7970,'in-the-opposite-direction' => 7992,'in-shaded-areas' => 7952,to => 8014,'over-the-crest-of-a-hill' => 7965,concourse => 7972,'area-of' => 8017,'entering-or-leaving-tunnels' => 7939,southeast => 8004,'southbound-traffic' => 7996,'park-and-ride-lot' => 8012,'on-minor-roads' => 7943,'near-beach-access-point' => 7968,'in-the-opposing-lanes' => 7944,'information-welcome-point' => 7981,dock => 7978,'westbound-traffic' => 7997,by => 8015,'bus-stop' => 8031,platform => 7977,'across-tracks' => 8024,'reservation-center' => 8007,'around-a-curve' => 7942,south => 7999,intersection => 8032,'on-ramps' => 7940,west => 8001,'moved-to-side-of-road' => 7949,crossover => 8028,'cross-traffic' => 7993,'in-street' => 8025,'in-the-median' => 7948,'in-low-lying-areas' => 7953,'at-service-area' => 7983,'at-rest-area' => 7982,'on-the-roadway' => 7951,'exiting-at' => 8023,'on-the-right' => 7989,'on-curve' => 8026,shoulder => 8027,'on-bridges' => 7937,north => 7998,'nearby-basin' => 8008,'in-the-ditch' => 7958,'cross-road' => 8029,from => 8020,'northbound-traffic' => 7994,'picnic-areas' => 7985,toilets => 7988,northwest => 8003,'moved-to-shoulder' => 7950,'entire-intersection' => 7947,'on-hill-top' => 7960,airport => 7971,'roadside-park' => 8033,'traffic-circle' => 8011}},'OPTIONAL'},{<<100,97,116,101,84,105,109,101>>,{typeinfo,{'Common','DDateTime'}},mandatory},{<<118,101,114,116,69,118,101,110,116>>,{{bit_string_nnl,[{notEquipped,0},{leftFront,1},{leftRear,2},{rightFront,3},{rightRear,4}]},5},'OPTIONAL'}]};
typeinfo('PivotPointDescription') ->
  {sequence,'PivotPointDescription',3,[{<<112,105,118,111,116,79,102,102,115,101,116>>,{'INTEGER',{-1024,1023}},mandatory},{<<112,105,118,111,116,65,110,103,108,101>>,{'INTEGER',{0,28800}},mandatory},{<<112,105,118,111,116,115>>,'BOOLEAN',mandatory}]};
typeinfo('RTCMPackage') ->
  {sequence,'RTCMPackage',2,[{<<114,116,99,109,72,101,97,100,101,114>>,{typeinfo,{'Common','RTCMheader'}},'OPTIONAL'},{<<109,115,103,115>>,{typeinfo,{'Common','RTCMmessageList'}},mandatory}]};
typeinfo('SpecialVehicleExtensions') ->
  {sequence,'SpecialVehicleExtensions',3,[{<<118,101,104,105,99,108,101,65,108,101,114,116,115>>,{typeinfo,{'Common','EmergencyDetails'}},'OPTIONAL'},{<<100,101,115,99,114,105,112,116,105,111,110>>,{typeinfo,{'BasicSafetyMessage','EventDescription'}},'OPTIONAL'},{<<116,114,97,105,108,101,114,115>>,{typeinfo,{'BasicSafetyMessage','TrailerData'}},'OPTIONAL'}]};
typeinfo('SpeedProfileMeasurementList') ->
  {sof,{'INTEGER',{0,31}}};
typeinfo('SpeedProfile') ->
  {sequence,'SpeedProfile',1,[{<<115,112,101,101,100,82,101,112,111,114,116,115>>,{typeinfo,{'BasicSafetyMessage','SpeedProfileMeasurementList'}},mandatory}]};
typeinfo('SupplementalVehicleExtensions') ->
  {sequence,'SupplementalVehicleExtensions',10,[{<<99,108,97,115,115,105,102,105,99,97,116,105,111,110>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<99,108,97,115,115,68,101,116,97,105,108,115>>,{typeinfo,{'Common','VehicleClassification'}},'OPTIONAL'},{<<118,101,104,105,99,108,101,68,97,116,97>>,{typeinfo,{'BasicSafetyMessage','VehicleData'}},'OPTIONAL'},{<<119,101,97,116,104,101,114,82,101,112,111,114,116>>,{typeinfo,{'BasicSafetyMessage','WeatherReport'}},'OPTIONAL'},{<<119,101,97,116,104,101,114,80,114,111,98,101>>,{typeinfo,{'BasicSafetyMessage','WeatherProbe'}},'OPTIONAL'},{<<111,98,115,116,97,99,108,101>>,{typeinfo,{'BasicSafetyMessage','ObstacleDetection'}},'OPTIONAL'},{<<115,116,97,116,117,115>>,{typeinfo,{'BasicSafetyMessage','DisabledVehicle'}},'OPTIONAL'},{<<115,112,101,101,100,80,114,111,102,105,108,101>>,{typeinfo,{'BasicSafetyMessage','SpeedProfile'}},'OPTIONAL'},{<<116,104,101,82,84,67,77>>,{typeinfo,{'BasicSafetyMessage','RTCMPackage'}},'OPTIONAL'},{<<114,101,103,105,111,110,97,108>>,{sof,{sequence,'SupplementalVehicleExtensions_regional_SEQOF',2,[{<<114,101,103,105,111,110,73,100>>,{'INTEGER',{0,255}},mandatory},{<<114,101,103,69,120,116,86,97,108,117,101>>,{'ObjClassFieldType',{regionId,1},{componentrelation,{objectset,121,{'Externaltypereference',undefined,'BasicSafetyMessage',internal_object_set_argument_5}},[{outermost,[{'Externalvaluereference',121,'Common',regionId}]}]}},mandatory}]}},'OPTIONAL'}]};
typeinfo('TrailerData') ->
  {sequence,'TrailerData',3,[{<<110,111,116,85,115,101,100>>,{'INTEGER',{0,31}},mandatory},{<<99,111,110,110,101,99,116,105,111,110>>,{typeinfo,{'BasicSafetyMessage','PivotPointDescription'}},mandatory},{<<117,110,105,116,115>>,{typeinfo,{'BasicSafetyMessage','TrailerUnitDescriptionList'}},mandatory}]};
typeinfo('TrailerHistoryPointList') ->
  {sof,{typeinfo,{'BasicSafetyMessage','TrailerHistoryPoint'}}};
typeinfo('TrailerHistoryPoint') ->
  {sequence,'TrailerHistoryPoint',5,[{<<112,105,118,111,116,65,110,103,108,101>>,{'INTEGER',{0,28800}},mandatory},{<<116,105,109,101,79,102,102,115,101,116>>,{'INTEGER',{1,65535}},mandatory},{<<112,111,115,105,116,105,111,110,79,102,102,115,101,116>>,{typeinfo,{'Common','Node-XY-24b'}},mandatory},{<<101,108,101,118,97,116,105,111,110,79,102,102,115,101,116>>,{'INTEGER',{-64,63}},'OPTIONAL'},{<<104,101,97,100,105,110,103>>,{'INTEGER',{0,240}},'OPTIONAL'}]};
typeinfo('TrailerUnitDescriptionList') ->
  {sof,{typeinfo,{'BasicSafetyMessage','TrailerUnitDescription'}}};
typeinfo('TrailerUnitDescription') ->
  {sequence,'TrailerUnitDescription',13,[{<<105,115,68,111,108,108,121>>,'BOOLEAN',mandatory},{<<119,105,100,116,104>>,{'INTEGER',{0,1023}},mandatory},{<<108,101,110,103,116,104>>,{'INTEGER',{0,4095}},mandatory},{<<104,101,105,103,104,116>>,{'INTEGER',{0,127}},'OPTIONAL'},{<<109,97,115,115>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<98,117,109,112,101,114,72,101,105,103,104,116,115>>,{typeinfo,{'Common','BumperHeights'}},'OPTIONAL'},{<<99,101,110,116,101,114,79,102,71,114,97,118,105,116,121>>,{'INTEGER',{0,127}},'OPTIONAL'},{<<102,114,111,110,116,80,105,118,111,116>>,{typeinfo,{'BasicSafetyMessage','PivotPointDescription'}},mandatory},{<<114,101,97,114,80,105,118,111,116>>,{typeinfo,{'BasicSafetyMessage','PivotPointDescription'}},'OPTIONAL'},{<<114,101,97,114,87,104,101,101,108,79,102,102,115,101,116>>,{'INTEGER',{-2048,2047}},'OPTIONAL'},{<<112,111,115,105,116,105,111,110,79,102,102,115,101,116>>,{typeinfo,{'Common','Node-XY-24b'}},mandatory},{<<101,108,101,118,97,116,105,111,110,79,102,102,115,101,116>>,{'INTEGER',{-64,63}},'OPTIONAL'},{<<99,114,117,109,98,68,97,116,97>>,{typeinfo,{'BasicSafetyMessage','TrailerHistoryPointList'}},'OPTIONAL'}]};
typeinfo('VehicleData') ->
  {sequence,'VehicleData',4,[{<<104,101,105,103,104,116>>,{'INTEGER',{0,127}},'OPTIONAL'},{<<98,117,109,112,101,114,115>>,{typeinfo,{'Common','BumperHeights'}},'OPTIONAL'},{<<109,97,115,115>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<116,114,97,105,108,101,114,87,101,105,103,104,116>>,{'INTEGER',{0,64255}},'OPTIONAL'}]};
typeinfo('WeatherProbe') ->
  {sequence,'WeatherProbe',3,[{<<97,105,114,84,101,109,112>>,{'INTEGER',{0,191}},'OPTIONAL'},{<<97,105,114,80,114,101,115,115,117,114,101>>,{'INTEGER',{0,255}},'OPTIONAL'},{<<114,97,105,110,82,97,116,101,115>>,{typeinfo,{'Common','WiperSet'}},'OPTIONAL'}]};
typeinfo('WeatherReport') ->
  {sequence,'WeatherReport',6,[{<<105,115,82,97,105,110,105,110,103>>,{'ENUMERATED',#{error => 3,precip => 1,noPrecip => 2}},mandatory},{<<114,97,105,110,82,97,116,101>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<112,114,101,99,105,112,83,105,116,117,97,116,105,111,110>>,{'ENUMERATED',#{other => 1,unknown => 2,noPrecipitation => 3,unidentifiedSlight => 4,unidentifiedModerate => 5,unidentifiedHeavy => 6,snowSlight => 7,snowModerate => 8,snowHeavy => 9,rainSlight => 10,rainModerate => 11,rainHeavy => 12,frozenPrecipitationSlight => 13,frozenPrecipitationModerate => 14,frozenPrecipitationHeavy => 15}},'OPTIONAL'},{<<115,111,108,97,114,82,97,100,105,97,116,105,111,110>>,{'INTEGER',{0,65535}},'OPTIONAL'},{<<102,114,105,99,116,105,111,110>>,{'INTEGER',{0,101}},'OPTIONAL'},{<<114,111,97,100,70,114,105,99,116,105,111,110>>,{'INTEGER',{0,50}},'OPTIONAL'}]};
typeinfo('IsDolly') ->
  'BOOLEAN';
typeinfo('ObstacleDirection') ->
  {'INTEGER',{0,28800}};
typeinfo('PivotingAllowed') ->
  'BOOLEAN';
typeinfo('SpeedProfileMeasurement') ->
  {'INTEGER',{0,31}};
typeinfo('TrailerMass') ->
  {'INTEGER',{0,255}};
typeinfo('VertOffset-B07') ->
  {'INTEGER',{-64,63}};
typeinfo(Type) ->
  exit({error,{asn1,{undefined_type,Type}}}).


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

bit_string_name2pos_10([notEquipped | T]) ->
    [0 | bit_string_name2pos_10(T)];
bit_string_name2pos_10([leftFront | T]) ->
    [1 | bit_string_name2pos_10(T)];
bit_string_name2pos_10([leftRear | T]) ->
    [2 | bit_string_name2pos_10(T)];
bit_string_name2pos_10([rightFront | T]) ->
    [3 | bit_string_name2pos_10(T)];
bit_string_name2pos_10([rightRear | T]) ->
    [4 | bit_string_name2pos_10(T)];
bit_string_name2pos_10([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_10(T)];
bit_string_name2pos_10([]) ->
    [];
bit_string_name2pos_10(_) ->
    throw(invalid).

bit_string_name2pos_7(['from000-0to022-5degrees' | T]) ->
    [0 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from022-5to045-0degrees' | T]) ->
    [1 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from045-0to067-5degrees' | T]) ->
    [2 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from067-5to090-0degrees' | T]) ->
    [3 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from090-0to112-5degrees' | T]) ->
    [4 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from112-5to135-0degrees' | T]) ->
    [5 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from135-0to157-5degrees' | T]) ->
    [6 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from157-5to180-0degrees' | T]) ->
    [7 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from180-0to202-5degrees' | T]) ->
    [8 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from202-5to225-0degrees' | T]) ->
    [9 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from225-0to247-5degrees' | T]) ->
    [10 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from247-5to270-0degrees' | T]) ->
    [11 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from270-0to292-5degrees' | T]) ->
    [12 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from292-5to315-0degrees' | T]) ->
    [13 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from315-0to337-5degrees' | T]) ->
    [14 | bit_string_name2pos_7(T)];
bit_string_name2pos_7(['from337-5to360-0degrees' | T]) ->
    [15 | bit_string_name2pos_7(T)];
bit_string_name2pos_7([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_7(T)];
bit_string_name2pos_7([]) ->
    [];
bit_string_name2pos_7(_) ->
    throw(invalid).

dec_components11(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components11(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V1@V0:5,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
dec_components11(Num-1, Remain, [Term|Acc]).

dec_components12(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components12(Num, Bytes, Acc) ->
{Term,Remain} = dec_SupplementalVehicleExtensions_regional_RegionalExtension(Bytes),
dec_components12(Num-1, Remain, [Term|Acc]).

dec_components13(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components13(Num, Bytes, Acc) ->
{Term,Remain} = dec_TrailerHistoryPoint(Bytes),
dec_components13(Num-1, Remain, [Term|Acc]).

dec_components14(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components14(Num, Bytes, Acc) ->
{Term,Remain} = dec_TrailerUnitDescription(Bytes),
dec_components14(Num-1, Remain, [Term|Acc]).

dec_components3(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components3(Num, Bytes, Acc) ->
{Term,Remain} = dec_BasicSafetyMessage_partII_PartIIcontent(Bytes),
dec_components3(Num-1, Remain, [Term|Acc]).

dec_components5(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components5(Num, Bytes, Acc) ->
{Term,Remain} = dec_BasicSafetyMessage_regional_RegionalExtension(Bytes),
dec_components5(Num-1, Remain, [Term|Acc]).

dec_components8(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components8(Num, Bytes, Acc) ->
{Term,Remain} = begin
<<V2@V0:16,V2@Buf1/bitstring>> = Bytes,
{V2@V0,V2@Buf1}
end,
dec_components8(Num-1, Remain, [Term|Acc]).

dec_components9(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components9(Num, Bytes, Acc) ->
{Term,Remain} = dec_EventDescription_regional_RegionalExtension(Bytes),
dec_components9(Num-1, Remain, [Term|Acc]).

dec_os_Type4(Bytes, Id) when Id =:= 0 ->
{Term,_} = 'Common':dec_VehicleSafetyExtensions(Bytes),
Term;
dec_os_Type4(Bytes, Id) when Id =:= 1 ->
{Term,_} = dec_SpecialVehicleExtensions(Bytes),
Term;
dec_os_Type4(Bytes, Id) when Id =:= 2 ->
{Term,_} = dec_SupplementalVehicleExtensions(Bytes),
Term;
dec_os_Type4(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


dec_os_Type6(Bytes, Id) ->
{asn1_OPENTYPE,Bytes}.


enc_os_Type1(Val, Id) ->
if Id =:= 0 ->
'Common':enc_VehicleSafetyExtensions(Val);
Id =:= 1 ->
enc_SpecialVehicleExtensions(Val);
Id =:= 2 ->
enc_SupplementalVehicleExtensions(Val);
true ->
open_type_to_binary(Val)
end.

enc_os_Type2(Val, Id) ->
open_type_to_binary(Val).

adjust_trailing_zeroes(Bs0, Lb) ->
    case bit_size(Bs0) of
        Sz when Sz < Lb ->
            <<Bs0:Sz/bits,0:(Lb - Sz)>>;
        Lb ->
            Bs0;
        _ ->
            <<_:Lb/bits,Tail/bits>> = Bs0,
            Sz = Lb + bit_size(bs_drop_trailing_zeroes(Tail)),
            <<Bs:Sz/bits,_/bits>> = Bs0,
            Bs
    end.

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

bitstring_from_positions(L0, Lb) ->
    L1 = lists:sort(L0),
    L = diff(L1, -1, Lb - 1),
    << 
      <<B:(N + 0)>> ||
          {B, N} <- L
    >>.

bs_drop_trailing_zeroes(Bs) ->
    bs_drop_trailing_zeroes(Bs, bit_size(Bs)).

bs_drop_trailing_zeroes(Bs, 0) ->
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) when Sz0 < 8 ->
    <<Byte:Sz0>> = Bs0,
    Sz = Sz0 - ntz(Byte),
    <<Bs:Sz/bits,_/bits>> = Bs0,
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) ->
    Sz1 = Sz0 - 8,
    <<Bs1:Sz1/bits,Byte:8>> = Bs0,
    case ntz(Byte) of
        8 ->
            bs_drop_trailing_zeroes(Bs1, Sz1);
        Ntz ->
            Sz = Sz0 - Ntz,
            <<Bs:Sz/bits,_:Ntz/bits>> = Bs0,
            Bs
    end.

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, Type, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    decode_jer_component_map(CompInfos, Value, []);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer({container, Type, _Containing}, Val) ->
    decode_jer(Type, Val);
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_jer_component_map([{Name, AtomName, Type, _OptOrDefault} |
                          CompInfos],
                         VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component_map(CompInfos, VMap, [{AtomName, Dec} | Acc]);
decode_jer_component_map([{_Name, _AtomName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap, Acc);
decode_jer_component_map([{_Name, AtomName, _Type, {'DEFAULT', Dvalue}} |
                          CompInfos],
                         VMap, Acc) ->
    decode_jer_component_map(CompInfos, VMap,
                             [{AtomName, Dvalue} | Acc]);
decode_jer_component_map([{Name, _AtomName, _Type, _OptOrDefault} |
                          _CompInfos],
                         VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component_map([], _, Acc) ->
    maps:from_list(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

decode_named_bit_string(Val, NNL) ->
    Bits =
        [ 
         B ||
             <<B:1>> <= Val
        ],
    decode_named_bit_string_1(0, Bits, NNL, []).

decode_named_bit_string_1(Pos, [0 | Bt], Names, Acc) ->
    decode_named_bit_string_1(Pos + 1, Bt, Names, Acc);
decode_named_bit_string_1(Pos, [1 | Bt], Names, Acc) ->
    case lists:keyfind(Pos, 2, Names) of
        {Name, _} ->
            decode_named_bit_string_1(Pos + 1, Bt, Names, [Name | Acc]);
        false ->
            decode_named_bit_string_1(Pos + 1,
                                      Bt, Names,
                                      [{bit, Pos} | Acc])
    end;
decode_named_bit_string_1(_Pos, [], _Names, Acc) ->
    lists:reverse(Acc).

diff([H | T], Prev, Last) ->
    [{1, H - Prev} | diff(T, H, Last)];
diff([], Prev, Last) when Last >= Prev ->
    [{0, Last - Prev}];
diff([], _, _) ->
    [].

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_jer(Module, Type, Val) ->
    Info = Module:typeinfo(Type),
    Enc = encode_jer(Info, Val),
    EncFun =
        fun({'KV_LIST', Value}, Encode) ->
               json:encode_key_value_list(Value, Encode);
           (Other, Encode) ->
               json:encode_value(Other, Encode)
        end,
    iolist_to_binary(json:encode(Enc, EncFun)).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence_map, _Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    encode_jer_component_map(CompInfos, Value, []);
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Type}}, Val) ->
    TypeInfo = Module:typeinfo(Type),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer({container, Type, _Containing}, Val) ->
    encode_jer(Type, Val);
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, Acc) ->
    {'KV_LIST', lists:reverse(Acc)}.

encode_jer_component_map([{Name, AName, Type, _OptOrDefault} |
                          CompInfos],
                         MapVal, Acc)
    when is_map_key(AName, MapVal) ->
    Value = maps:get(AName, MapVal),
    Enc = encode_jer(Type, Value),
    encode_jer_component_map(CompInfos, MapVal, [{Name, Enc} | Acc]);
encode_jer_component_map([{_Name, _AName, _Type, 'OPTIONAL'} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([{_Name, _AName, _Type, {'DEFAULT', _}} |
                          CompInfos],
                         MapVal, Acc) ->
    encode_jer_component_map(CompInfos, MapVal, Acc);
encode_jer_component_map([], MapVal, Acc)
    when map_size(MapVal) =:= length(Acc) ->
    {'KV_LIST', lists:reverse(Acc)};
encode_jer_component_map(_, MapVal, Acc) ->
    ErroneousKeys =
        maps:keys(MapVal)
        --
        [ 
         K ||
             {K, _V} <- Acc
        ],
    exit({error,
          {asn1,
           {{encode, 'SEQUENCE'}, {erroneous_keys, ErroneousKeys}}}}).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    jer_encode_bitstring(BitList).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, <<Val>>);
jer_encode_bitstring(Val) ->
    jer_unused_bitlist(Val, <<>>).

jer_encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Acc) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    jer_encode_bitstring(Rest, [Acc, Val]);
jer_encode_bitstring([], Acc) ->
    Acc;
jer_encode_bitstring(Rest, Acc) ->
    jer_unused_bitlist(Rest, Acc).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

jer_unused_bitlist([], Acc) ->
    Acc;
jer_unused_bitlist([Bit | Rest], Acc) ->
    jer_unused_bitlist(Rest, <<Acc/bitstring,Bit:1>>).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

ntz(Byte) ->
    T = {8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2,
         0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0,
         1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1,
         0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
         2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3,
         0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
         1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1,
         0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
         3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
         0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0,
         1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1,
         0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
         2, 0, 1, 0},
    element(Byte + 1, T).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

open_type_to_binary({asn1_OPENTYPE, Bin}) when is_binary(Bin) ->
    Bin.

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
